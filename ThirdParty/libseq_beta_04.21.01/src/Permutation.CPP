/////////////////////////////////////////////////////////////////////////////
//                                                                         
// Permutation.C, 8.8.99, Ilja Friedel                       
//
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// Status: testing, VectorRandomPermutation::operator++ buggy ?
//
/////////////////////////////////////////////////////////////////////////////

#include "Permutation.h"
using namespace std;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

Permutation::~Permutation()
{
   if(X) delete [] X;
   X=nullptr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

VectorRandomPermutation::~VectorRandomPermutation()
{
   L_int i;

   for(i=0;i<dim;i++) 
     {
       delete P[i];
       P[i]=nullptr;
     }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

R_Elem Permutation::operator[](const UL_int j)
     {
#ifdef DEBUG
       if(j>=base)
	 {
	   cerr << "Error: Access out of range! ("<<j<<">=base="<<base;
	   cerr << " in RandomPermutation::operator[])"<<endl;
	   if(this==nullptr) 
	     cerr << "(Call to a not allocated permutation! [this==nullptr])"
		  <<endl;
	   else cerr << "[this!=nullptr]" << endl;
	   exit(1);
	  }
#endif
       return(X[j]);
     }

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void RandomPermutation::operator++(void)
{
   L_int i,pos;
   R_Elem tmp;

   for(i=(L_int)base-1;i>=1;i--)
     {
       pos=(L_int)random_Ring_Element(i+1);   
       
       tmp    = X[i];
       X[i]   = X[pos];
       X[pos] = tmp;
     }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void VectorRandomPermutation::operator++(void)
{
   L_int   i,j;
   RVector tmp;

   for(i=0;i<dim;i++)
     {
       N[i]=0;
       ++(*(P[i]));
     }

   for(i=0;i<base;i++)
     {
       tmp=0;
       for(j=(L_int)dim-1;j>=0;j--)
	 {
	   tmp=tmp*dim_base+(*(P[j]))[N[j]];
	 }
       X[i]=tmp;

       j=0;
       do
	 {
	   N[j]=(N[j]+1)%dim_base;
	   j++;
	 }
       while((j<=dim)&&(N[j-1]==0));
     }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

R_Elem LazyRandomPermutation::operator[](const UL_int j) 
{ 
   UL_int i,dl,dr;

   if(clean)
     {
/////////////////////////////////////////////////////////////////////////////
// initialize statistics
/////////////////////////////////////////////////////////////////////////////
       left =base+j-1;
       right=base+j+1;
       clean=0;
     }
   else
     {
/////////////////////////////////////////////////////////////////////////////
// update statistics
/////////////////////////////////////////////////////////////////////////////
       i=j+base;
       if((left<i)&&(i<right))        return(X[j]);
       if(i+base<right)               return(X[j]);
       if(i-base>left)                return(X[j]);

       if(j==(right)%base) {right++;  return(X[j]);}
       if(j==(left )%base) {left--;   return(X[j]);}
       
       dl=(left-j)%base;          // distance on torus from left
       dr=(i+base-right)%base;    // distance on torus to right

       if(dl<dr) left =left -dl-1;
       else      right=right+dr+1;
     }
   return X[j];   
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void LazyRandomPermutation::operator++(void)
{
   L_int i,pos,li,lp;
   R_Elem tmp;

   if(clean||newPerm)
     {
///////////////////////////////////////////////////////////////////////////// 
// compute a completely new random permutation
/////////////////////////////////////////////////////////////////////////////
       newPerm=0;
       for(i=(L_int)base-1;i>=1;i--)
	 {
	   pos=(L_int)random_Ring_Element(i+1);   
       
	   tmp    = X[i];
	   X[i]   = X[pos];
	   X[pos] = tmp;
	 }
     }
   else
     {
/////////////////////////////////////////////////////////////////////////////
// recycle the old permutation
// the user has seen values _between_ <left> and <right>
/////////////////////////////////////////////////////////////////////////////
       for(i=1;i<right-left;i++)
	 {
    	   pos    = i+(L_int)random_Ring_Element(base-i+1);

	   li=(L_int)((left+i  )%base);
	   lp=(L_int)((left+pos)%base);

	   tmp     = X[li];
	   X[li]   = X[lp];
	   X[lp]   = tmp;
	 }
     }
   clean=1;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
