/////////////////////////////////////////////////////////////////////////////
//                                                                         
// Permutation.h, 8.8.99, Ilja Friedel                       
//
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// Status: ok
//
/////////////////////////////////////////////////////////////////////////////

#ifndef PERMUTATION_USED
#define PERMUTATION_USED

#include <stdio.h>
#include <assert.h>
#include "own_types.h"
#include "options.h"
#include "digit_gen.h"
using namespace std;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class Permutation
{
protected:
   UL_int  base;
   UL_int  memory;

public:
   R_Elem         *X;
   inline         Permutation(UL_int);
   virtual       ~Permutation();
   UL_int         Base(void)       {return(base);}
   UL_int         memory_used(void){return(memory);}
   inline  void   print(void);
   virtual R_Elem operator[](const UL_int j);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class RandomPermutation : public Permutation
{
public:
   inline        RandomPermutation(const UL_int b):Permutation(b){}
   virtual void  operator++(void);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class VectorRandomPermutation : public RandomPermutation
{
   RandomPermutation *P[32];
   UL_int             N[32];
   UL_int             dim;
   UL_int             dim_base;

public:
   inline        VectorRandomPermutation(UL_int, UL_int);
   virtual      ~VectorRandomPermutation();
          void   operator++(void);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class LazyRandomPermutation : public RandomPermutation
{
   UL_int  left,right,single;
   int clean,newPerm;

public:
   inline        LazyRandomPermutation(const UL_int b);
          void   operator++(void);
          R_Elem operator[](const UL_int j);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// and now the inline functions ...
/////////////////////////////////////////////////////////////////////////////

inline Permutation::Permutation(UL_int b)
{
   L_int i;

   X = new R_Elem[b];
   if(X==nullptr)
     {
       cerr << "Error: Out of memory! (Permutation(" << b << ")" << endl;  
       exit(1);
     }
   for(i=0;i< L_int(b);i++) X[i]=i;
   base=b;
   memory=b*sizeof(R_Elem)+sizeof(Permutation);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

inline void Permutation::print(void)
{
   L_int i;

   cout << "Permutation: base=" << base << ", <";
   for(i=0;i< L_int(base-1);i++) cout << X[i] << " ";
   cout << X[base-1] << ">" << endl;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

inline VectorRandomPermutation::VectorRandomPermutation(UL_int b, UL_int n):RandomPermutation(int_pow(b,n))
{
   L_int i;

   for(i=0;i< L_int(n);i++)
     {
       P[i]=new RandomPermutation(b);
       if(P[i]==nullptr)
	 {
	   cerr << "Error: Out of memory! ";
	   cerr << "(VectorRandomPermutation::VectorRandomPermutation())";
	   cerr << endl;
	   exit(1);
	 }
       memory+=P[i]->memory_used();
       N[i]=0;
     }

   dim      = n;
   dim_base = b;
   memory+=sizeof(VectorRandomPermutation);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

inline LazyRandomPermutation::LazyRandomPermutation(const UL_int b):RandomPermutation(b)
{
   clean   = 1;
   newPerm = 1;
   memory += sizeof(LazyRandomPermutation);
} 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#endif
