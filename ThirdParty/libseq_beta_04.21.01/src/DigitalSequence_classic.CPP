//////////////////////////////////////////////////////////////////////////////
//
// DigitalSequence_classic.C, 11.8.99, Ilja Friedel
//
//////////////////////////////////////////////////////////////////////////////
//
// Status: finished,
//         it is possible to improve speed of restart()
//
//////////////////////////////////////////////////////////////////////////////


#include "DigitalSequence.h"
using namespace std;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

DigitalSequence_classic::~DigitalSequence_classic()
{
   L_int i,j;

   for(i=0;i<=NumDigits;i++)
     {
       if(psi) if(psi[i]) delete psi[i];
       if(eta) 
	 for(j=0;j<dimension;j++) 
	   {
	     if(eta[j*(NumDigits+1)+i]) delete eta[j*(NumDigits+1)+i];
	   }
     }
   if(psi) delete[] psi;
   if(eta) delete[] eta;
   psi=nullptr;
   eta=nullptr;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

DigitalSequence_classic::DigitalSequence_classic(C_matrix *C):DigitalSequence(C->dimension)
{
   init(C,C->dimension,0);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

DigitalSequence_classic::DigitalSequence_classic(C_matrix *C,UL_int dimension):DigitalSequence(dimension)
{
   init(C,dimension,0);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

DigitalSequence_classic::DigitalSequence_classic(C_matrix *C,UL_int dimension, UL_int offset):DigitalSequence(dimension)
{
   init(C,dimension,offset);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_classic::init(C_matrix *C, UL_int dim, UL_int offset)
{
   L_int i,j;
   UL_int base;

#ifdef DEBUG
   check_own_types();
#endif

//////////////////////////////////////////////////////////////////////////////
// initializing variables 
//////////////////////////////////////////////////////////////////////////////
   R           = C->R;
   base        = R->base;
   inv_base    = 1.0/((double)base);
   CM          = C;
   NumDigits   = C->NumDigits; 
   dimension   = dim;
   check_arguments();

   n0          = offset;
   n           = n0;

//////////////////////////////////////////////////////////////////////////////
// new permutations, they are for all x: p(x)=x
//////////////////////////////////////////////////////////////////////////////
   init_psi_and_eta();

//////////////////////////////////////////////////////////////////////////////
// new counter
////////////////////////////////////////////////////////////////////////////// 
   N           = new Counter(R,NumDigits,psi);
   if(!N)
     {
       cerr << "Error: Out of memory!" << endl;
       exit(1);
     }
//////////////////////////////////////////////////////////////////////////////
// new buffer for digits of the sequence
//////////////////////////////////////////////////////////////////////////////
   Digit       = new UL_int * [dimension];
   if(!(N&&Digit))
     {
       cerr << "Error: Out of memory!" << endl;
       exit(1);
     }
   for(i=0;i<dimension;i++)
     {
       Digit[i] = new UL_int[NumDigits];
       if(!(Digit[i]))
	 {
	   cerr << "Error: Out of memory!" << endl;
	   exit(1);
	 }
       for(j=0;j<NumDigits;j++) Digit[i][j]=0;
     }
//////////////////////////////////////////////////////////////////////////////
// actualizing used memory
//////////////////////////////////////////////////////////////////////////////
   memory     += sizeof(DigitalSequence_classic);
   memory     += sizeof(UL_int)*dimension*NumDigits;

   N->set(n0);
   operator++();
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_classic::operator++()
{
   L_int row,column,akdim,i;
   double dtmp;

   check_next_dim();
   reset_next_dim();
//////////////////////////////////////////////////////////////////////////////
// we have to reset next_dim in every <<::operator++()>>
//////////////////////////////////////////////////////////////////////////////
// solving generation equation
//////////////////////////////////////////////////////////////////////////////
   for(column=0;column<=N->LastChangingDigit;column++)	 
     {
       if((N->difference(column))!=0)
	 {
	   for(akdim=0;akdim<dimension;akdim++)
	     {	 
	       for(row=0;row<NumDigits;row++) // row<=C->LastDigitNotNull
		 {	       
		   Digit[akdim][row]=R->add(Digit[akdim][row],
				        R->mult(CM->query(akdim,row,column),
				           N->difference(column)));
		 }   
	     }
	 }
     }
//////////////////////////////////////////////////////////////////////////////
// solving conversion equation
//////////////////////////////////////////////////////////////////////////////
   for(akdim=0;akdim<dimension;akdim++)
     {
       dtmp=0.0;

       for(i=(L_int)NumDigits-1;i>=0;i--)
	 {  
	   dtmp=(dtmp+
		 (double)(*(eta[akdim*(NumDigits+1)+i]))[Digit[akdim][i]]
		 )*inv_base;
	 }
       
       X[akdim]=dtmp;
     }
//////////////////////////////////////////////////////////////////////////////
// next vector
//////////////////////////////////////////////////////////////////////////////
   n++;
   ++(*N);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_classic::random_restart(void) 
{
   L_int i,j;
   
   for(i=0;i<dimension;i++)
     {
       for(j=0;j<NumDigits;j++) Digit[i][j]=0;
     }

//////////////////////////////////////////////////////////////////////////////
// choose new random permutations and set n and N to the initial value.
// (This order! Don't change psi after setting N!)
//////////////////////////////////////////////////////////////////////////////
   for(i=0;i<=NumDigits;i++)
   { 
      ++(*(psi[i]));
      for(j=0;j<dimension;j++)
      {
         ++(*(eta[j*(NumDigits+1)+i]));
      }
   }
   n = n0;
   N->reset();
   N->set(n0);

   operator++();
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_classic::restart(void) 
{
   L_int i,j;

   for(i=0;i<dimension;i++)
     {
       for(j=0;j<NumDigits;j++) Digit[i][j]=0;
     }

//////////////////////////////////////////////////////////////////////////////
// It is possible to restart the generator without clearing the buffer
// Digit[][] and N->reset(), but I don't have enough time to do that.
// (Ilja Friedel, 1.8.99)
//////////////////////////////////////////////////////////////////////////////
   n = n0;
   N->reset();
   N->set(n0);

   operator++();
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_classic::init_psi_and_eta(void)
{

//////////////////////////////////////////////////////////////////////////////
// create new permutations, but don't randomize them
//////////////////////////////////////////////////////////////////////////////
  
   L_int i,j;
   UL_int base;
   
   base=R->base;
   
   psi=new RandomPermutation * [NumDigits+1];
   memory+=sizeof(RandomPermutation *)*(NumDigits+1);
   
   if(!psi)
     {
       cerr << "Error: Out of memory! ";
       cerr << "(DigitalSequence_classic::init_psi_and_eta())" << endl;
       exit(1);
     }
   
   eta=new RandomPermutation * [dimension*(NumDigits+1)];
   memory+=sizeof(RandomPermutation *)*(NumDigits+1)*dimension;
   
   if(!eta)
     {
       cerr << "Error: Out of memory! ";
       cerr << "(DigitalSequence_classic::init_psi_and_eta())" << endl;
       exit(1);
     }
   
//////////////////////////////////////////////////////////////////////////////

   for(i=0;i<=NumDigits;i++)
     { 
       psi[i]=new RandomPermutation(base);
       memory+=psi[i]->memory_used();
       
       if(!psi[i])
	 {
	   cerr << "Error: Out of memory! ";
	   cerr << "(DigitalSequence_classic::init_psi_and_eta())";
	   exit(1);
	 } 
       for(j=0;j<dimension;j++)
	 {
	   
	   eta[j*(NumDigits+1)+i]=new RandomPermutation(base);
	   memory+=eta[i]->memory_used();
	   
	   if(eta[j*(NumDigits+1)+i]==nullptr)
	     {
	       cerr << "Error: Out of memory! ";
	       cerr << "(DigitalSequence_classic::init_psi_and_eta())";
	       exit(1);
	     }
	 }
     }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

