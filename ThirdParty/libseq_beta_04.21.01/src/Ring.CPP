//////////////////////////////////////////////////////////////////////////////
//
// Ring.C, 8.7.99, Ilja Friedel
//
//////////////////////////////////////////////////////////////////////////////
//
// Status: always memory consuming in Ring::Ring(UL_int b)
//
//////////////////////////////////////////////////////////////////////////////

#include "Ring.h"
#include "Polynomial.h"
using namespace std;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

Ring::Ring(UL_int b)
{
   int i,j;

   if(!is_prime(b))
     {
       cerr << "Warning: creating a ring, which is not a field. "
	    << "The function for constructing irreducible polynomials "
	    << "in DigitalSequence might not work for this input. "
	    << "If you are trying to specify a Galoais field, "
	    << "use Ring::Ring(base,power) instead." << endl;
     }

   method = 0;
   sprintf(name,"Z/pZ");

//////////////////////////////////////////////////////////////////////////////
// We burn memory here on purpose. If you don't like it,
// use remainder arithmetic instead. This might be faster or slower,
// depending on your machine.
//////////////////////////////////////////////////////////////////////////////

   base      = b;
   _add      = new R_Elem[base*base];
   _mult     = new R_Elem[base*base];
   _a_inverse= new R_Elem[base];
   memory=sizeof(R_Elem)*base*(2*base+1)+sizeof(Ring);

   if(!(_add && _mult && _a_inverse))
     {
       cerr << "Error: Out of memory!" << endl;
       exit(1);
     }
   
   for(i=0;i<base;i++)
     {
       for(j=0;j<base;j++)
	 {
	   _add [i+j*base]=(i+j)%base;
	   _mult[i+j*base]=(i*j)%base;
	 }
       _a_inverse[i]=(base-i)%base;
     }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// The Galois field construction function was never "really" tested.
// Please be carefull.
//////////////////////////////////////////////////////////////////////////////

Ring::Ring(UL_int p, UL_int n)
{
   int i,j;
   Ring R(p);
   Polynomial IRP(&R);

   if(!is_prime(p))
     {
       cerr << "Error: Can't create a Galois field with p=" << p 
	    << "not being a prime. (Ring::Ring(UL_int p, UL_int n))"
	    << endl;
       exit(1);
     }

   if(n==0)
     {
       cerr << "Error: Can't create a Galois field with n=0. "
	    << "(Ring::Ring(UL_int p, UL_int n))"
	    << endl;
       exit(1);
     }

   method = 0;
   base=int_pow(p,n);
   sprintf(name,"GF(p,n)");

   _add      = new R_Elem[base*base];
   _mult     = new R_Elem[base*base];
   _a_inverse= new R_Elem[base];
   memory=sizeof(R_Elem)*base*(2*base+1)+sizeof(Ring);

   if(!(_add && _mult && _a_inverse))
     {
       cerr << "Error: Out of memory!" << endl;
       exit(1);
     }

   IRP=get_irr_poly_of_deg(n,&R);
   
   for(i=0;i<base;i++)
     {
       Polynomial A(&R,i);
       for(j=0;j<base;j++)
	 {
	   Polynomial B(&R,j);

	   _add [i+j*base]=((A+B)%IRP).return_int();
	   _mult[i+j*base]=((A*B)%IRP).return_int();
	 }
       _a_inverse[i]=((Polynomial(&R)-A)%IRP).return_int();
     }
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

Ring::Ring(char * filename)
{
   if(strncmp(filename,"FILE:",5)==0)
     {
       sprintf(name,"%s",filename);
       load(filename+5);
       return;
     }
   else
     {
       cerr << "Error: Method <<" << filename;
       cerr << ">> unknown! (Ring::Ring(char * filename))";
       cerr << endl;
       cerr << "(Loading a file with 'FILE:path/filename'.)";
       cerr << endl;
       exit(1);
     }
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

Ring::~Ring()
{
  if(_add)        delete [] _add;
  if(_mult)       delete [] _mult;
  if(_a_inverse)  delete [] _a_inverse;
  _add      =nullptr;
  _mult     =nullptr;
  _a_inverse=nullptr;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void  Ring::save(char * file)
{
   FILE *fid;
   int i,j;

   fid=fopen(file,"wt");

   fprintf(fid,"RING\n");
   fprintf(fid,"# [abelian] ring, generated by Ring::save('%s')\n",file);
   fprintf(fid,"# Ring has %d elements\n",base);
   fprintf(fid,"# Zero is '0' and One is '1'\n\n");
   fprintf(fid,"NAME %s\n",name);
   fprintf(fid,"METHOD %d\n",method);
   fprintf(fid,"CARD %d\n\n",base);
   if(method==0)
     {
       fprintf(fid,"ADD\n");
       for(i=0;i<base;i++)
	 {
	   for(j=0;j<base;j++) fprintf(fid,"%d ",_add[i+j*base]);
	   fprintf(fid,"END_LINE\n");
	 }
       fprintf(fid,"END_ADD\n\n");
       
       fprintf(fid,"MULT\n");
       for(i=0;i<base;i++)
	 {
	   for(j=0;j<base;j++) fprintf(fid,"%d ",_mult[i+j*base]);
	   fprintf(fid,"END_LINE\n");
	 }
       fprintf(fid,"END_MULT\n");
     }
   fprintf(fid,"END_RING\n");

#ifdef DEBUG
   fprintf(fid,"\n# ");
   for(j=0;j<base;j++) fprintf(fid,"%d ",_a_inverse[j]);
#endif

   fclose(fid);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void Ring::ignore_comments(FILE * fid)
{
   char c;

   do
   {
      c=getc(fid);
      if(c=='#')
      {
         do c=getc(fid);
         while (c!='\n');
      }
   }
   while (c==' ' || c=='\n' || c=='\t');
 
   ungetc(c,fid);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void  Ring::load(char * file)
{
   FILE *fid;
   int i,j;

   fid=fopen(file,"rt");

   if(fscanf(fid,"RING")>-1)
     {
       ignore_comments(fid);
       
       if(fscanf(fid,"NAME %s",name)<1)
	 {
	   cerr << "Error: No NAME specification or wrong place!" << endl;
	   exit(1);
	 }
       ignore_comments(fid);
       
       if(fscanf(fid,"METHOD %d",&method)<1)
	 {
	   cerr << "Error: No METHOD specification or wrong place!" << endl;
	   exit(1);
	 }
       
       if(fscanf(fid,"CARD %d",&base)<1)
	 {
	   cerr << "Error: No CARD specification or wrong place!" << endl;
	   exit(1);
	 }
#ifdef WARNINGS_EXTERNAL
       if(base>=100) cerr << "Warning: Loading huge ring! (Ring::load)"<<endl;
#endif
//////////////////////////////////////////////////////////////////////////////
       
       if(method==0)
	 {
	   _add       = new R_Elem[base*base];
	   _mult      = new R_Elem[base*base];
	   _a_inverse = new R_Elem[base];
	   
	   if(!(_add && _mult && _a_inverse))
	     {
	       cerr << "Error: Out of memory!" << endl;
	       exit(1);
	     }
	   
	   ignore_comments(fid);
	   if(fscanf(fid,"ADD")<0)
	     {
	       cerr << "Error: No ADD specification or wrong place!" << endl;
	       exit(1);
	     }
	   ignore_comments(fid);
	   
	   for(i=0;i<base;i++)
	     {
	       int inv;
	       inv=0;
	       
	       for(j=0;j<base;j++) 
		 {
		   fscanf(fid,"%d",&(_add[i+j*base]));
		   if(_add[i+j*base]>=base)
		     {
		       cerr << "Error: Element out of range!" << endl;
		       exit(1);
		     }
		   ignore_comments(fid);
		   if(_add[i+j*base]==0) {_a_inverse[i]=j;inv++;}
		 }
	       if(inv!=1)
		 {
		   cerr << "Error while reading '" << file;
		   cerr << "': Found " << inv;
		   cerr << "inverse elements for element " << i << endl; 
		   exit(1);
		}
	      fscanf(fid,"END_LINE");
	    }
	  ignore_comments(fid);
	  if(fscanf(fid,"END_ADD")<0)
	    {
	      cerr << "Error: No END_ADD found!" << endl;
	      exit(1);
	    }
	  ignore_comments(fid);
	  
//////////////////////////////////////////////////////////////////////////////
	  
	  if(fscanf(fid,"MULT")<0)
	    {
	      cerr << "Error: No MULT specification or wrong place!" << endl;
	      exit(1);
	    }
	  ignore_comments(fid);
	  
	  for(i=0;i<base;i++)
	    {
	      for(j=0;j<base;j++) 
		{
		  fscanf(fid,"%d",&(_mult[i+j*base]));
		  ignore_comments(fid);
		}
	      fscanf(fid,"END_LINE");
	    }
	  ignore_comments(fid);
	  
	  if(fscanf(fid,"END_MULT")<0)
	    {
	      cerr << "Error: No END_MULT found!" << endl;
	      exit(1);
	    }
	}
      ignore_comments(fid);

      if(fscanf(fid,"END_RING")<0)
	{
	  cerr << "Error: No END_RING found!" << endl;
	  exit(1);
	}
     }
//////////////////////////////////////////////////////////////////////////////
   
   else
     { 
       cerr << "'" << file;
       cerr << "' is not a RING file! (First keyword must be 'RING'.)";
       cerr << endl;
       exit(1);
     }
   fclose(fid);
   
#ifdef DEBUG
   cerr << "Warning: Didn't check if the loaded ring is really Abelian! "
	<< endl;
#endif
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

