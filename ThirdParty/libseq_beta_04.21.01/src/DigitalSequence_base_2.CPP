//////////////////////////////////////////////////////////////////////////////
//
// DigitalSequence_base_2.C, Ilja Friedel, 1.8.99
//
//////////////////////////////////////////////////////////////////////////////
//
// Status:  nearly finished
//
//////////////////////////////////////////////////////////////////////////////
//
// Warning: using function "new_DigitalSequence" will cause
//          memory leakage, because no call to ~DigitalSequence_base_2()
//          will occur
//
/////////////////////////////////////////////////////////////////////:-(//////

#include "DigitalSequence.h"
using namespace std;

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

DigitalSequence_base_2::~DigitalSequence_base_2()
{
   if(C)      delete[] C;
   C     =nullptr;
   if(bitmap) delete[] bitmap;
   bitmap=nullptr;
   if(eta)    delete[] eta;
   eta   =nullptr;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

DigitalSequence_base_2::DigitalSequence_base_2(C_matrix *C) :DigitalSequence(C->dimension)
{
   init(C,0);
}

//////////////////////////////////////////////////////////////////////////////

DigitalSequence_base_2::DigitalSequence_base_2(C_matrix *C, 
					       UL_int dimension) :DigitalSequence(dimension)
{
  init(C,0);
}

//////////////////////////////////////////////////////////////////////////////

DigitalSequence_base_2::DigitalSequence_base_2(C_matrix *C, 
					       UL_int dimension, 
					       UL_int offset) :DigitalSequence(dimension)
{
   init(C,offset);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_base_2::init(C_matrix *cm, 
				  UL_int    offset)
{
   UL_int i;

   sprintf(name,"DigitalSequence_base_2");
   n0        = offset;
   n         = n0;
   CM        = cm;
   R         = CM->R;
   check_arguments();
   // dimension is set by DigitalSequence

   inv_base  = pow(2.0,-32.0);
   NumDigits = 32;

//////////////////////////////////////////////////////////////////////////////
// we calculate always with 32 bit accuracy in this class
//////////////////////////////////////////////////////////////////////////////

   C         = new UL_int[dimension*NumDigits];
   bitmap    = new UL_int[dimension];
   eta       = new UL_int[dimension];

   if(!(bitmap && eta && C))
     {
       cerr << "Error: Out of memory! (DigitalSequence_base_2::init())";
       cerr << endl;
       exit(1);
     }

   transfer_C(); 
//////////////////////////////////////////////////////////////////////////////
// write CM in a more convenient form to C
//////////////////////////////////////////////////////////////////////////////

   psi = 0;
   for(i=0;i<dimension;i++)
   {
      eta[i]    = 0;
      bitmap[i] = 0;
      X[i]      = 0.0;
   }
   calc_vector(n);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_base_2::operator++()
{
   UL_int old_n,diff,sum,column;
   UL_int akdim;

   check_next_dim();
   reset_next_dim();
//////////////////////////////////////////////////////////////////////////////
// we have to reset next_dim in every <<::operator++()>>
//////////////////////////////////////////////////////////////////////////////

   old_n=n;
   n++;

   for(akdim=0;akdim<dimension;akdim++)
     {
       sum    = 0;
       column = 0;
       diff   = old_n^n;

       while(diff&&(column<NumDigits))
         {
	   sum=sum^C[NumDigits*akdim+column];
	   diff=diff>>1;
	   column++;
         }
       bitmap[akdim]=bitmap[akdim]^sum;
     }
   
   for(akdim=0;akdim<dimension;akdim++) 
     {
       X[akdim]=((double)bitmap[akdim])*inv_base;
     }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// operator++() is exactly 10 times as fast as calc_vector()
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_base_2::calc_vector(UL_int tmp)
{
   UL_int sum,column,a;
   UL_int akdim;
   
   n=tmp;

   for(akdim=0;akdim<dimension;akdim++)
     {
       a=tmp^psi;
         
       sum=0;
       for(column=0;column<NumDigits;column++)
         {
           if(a&1) sum=sum^C[NumDigits*akdim+column];
           a=a>>1;
         }
       bitmap[akdim]=sum^eta[akdim];
     }
   
   for(akdim=0;akdim<dimension;akdim++) 
     {
       X[akdim]=((double)bitmap[akdim])*inv_base;
     }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_base_2::transfer_C(void)
{
   L_int row,column,akdim;

   if(CM->R->base!=2)
     {
       cerr << "Error: C_matrix is over ring in base=" << CM->R->base;
       cerr << ", must be base=2!" << endl;
       exit(1);
     }
    
   for(akdim=0;akdim<dimension;akdim++)
     {
       for(column=0;column<NumDigits;column++)
	 {
	   C[NumDigits*akdim+column]=0;
	   for(row=0;row<NumDigits;row++) 
	     {
	       if((row<CM->NumDigits)&&(column<CM->NumDigits))
		 {
		   C[NumDigits*akdim+column]=C[NumDigits*akdim+column]<<1 
		     | (CM->query(akdim,row,column));
		 }
	       else
		 {
		   C[NumDigits*akdim+column]=C[NumDigits*akdim+column]<<1 
		     |  0;
		 }	       
	     }
	 }
     }
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

FixPoint DigitalSequence_base_2::query_bitmap(UL_int dim)
{
  return(bitmap[dim]);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_base_2::restart(void)
{
  calc_vector(n0);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void DigitalSequence_base_2::random_restart(void)
{
   int i;
   
   psi = get_32_random_bits();
  
   for(i=0;i<dimension;i++)
     {
       eta[i] = get_32_random_bits();
     }
   calc_vector(n0);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
