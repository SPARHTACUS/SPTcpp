////////////////////////////////////////////////////////////////////////////
//                                                                        
// Ring.h, 22.5.99, Ilja Friedel                              
//
////////////////////////////////////////////////////////////////////////////
//
// Status: Z/qZ possible
//         reading arbitrary rings via disk possible
//
// to do: int  check_abelian()
////////////////////////////////////////////////////////////////////////////
//                                                                        
// The following operations define an algebraic ring.
// Please note that the algorithm for creating irreducible
// polynomials ONLY works with fields.
// 
// We assume that zero=(UL_int)0 and one=(UL_int)1.
// The number of elements is b and all elements are in (UL_int){0,..,b-1}
//                                                                        
////////////////////////////////////////////////////////////////////////////

#ifndef RING_USED
#define RING_USED

//////////////////////////////////////////////////////////////////////////////
// own include files 
//////////////////////////////////////////////////////////////////////////////

#include "own_types.h"
#include "options.h"
#include "digit_gen.h"

//////////////////////////////////////////////////////////////////////////////
// standard include files 
//////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>

//////////////////////////////////////////////////////////////////////////////
// Include for loading/saving files
//////////////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include <fcntl.h>
//#include <unistd.h>
//#include <sys/uio.h>

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

class Ring
{
public:
//protected:
          UL_int method;
          UL_int memory; 

          void   ignore_comments(FILE *);
          void   load(char * fname);
          void   save(char * file);

//        int  check_abelian(); ************************
public:
          R_Elem * _add;   // public only for VectorRing
          R_Elem * _mult;
          R_Elem * _a_inverse;
	  //          R_Elem * _m_inverse;

          UL_int base;
          char   name    [256];
          char   filename[256];

   inline R_Elem add      (R_Elem, R_Elem);
   inline R_Elem mult     (R_Elem, R_Elem); 
   inline R_Elem minus(R_Elem);
   inline R_Elem invert(R_Elem);
   inline R_Elem power    (R_Elem, L_int);

   inline UL_int used_memory(void){return(memory);}

                 Ring(UL_int);
                 Ring(UL_int, UL_int);
                 Ring(char *);
   virtual      ~Ring();
};


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

inline R_Elem Ring::add(R_Elem a, R_Elem b)
{  
   if(method) return((a+b)%base);
   else       return(_add[a+b*base]);
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

inline R_Elem Ring::mult(R_Elem a, R_Elem b) 
{
   if(method) return((a*b)%base);
   else       return(_mult[a+b*base]);
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

inline R_Elem Ring::minus(R_Elem a) 
{
   if(method) return((base-a)%base);
   else       return(_a_inverse[a]);
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

inline R_Elem Ring::invert(R_Elem a) 
{
  L_int i;
  for(i=1;i< L_int(base);i++) if(mult(i,a)==1) return(i);

#ifdef DEBUG
  cerr << "Warning: Multiplicative inverse ";
  cerr << "does not exist! (Ring::invert(R_Elem "<<a<<"))"<<endl;
#endif

  return(0);
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
// function will also work with 64 bit (signed or not) power
////////////////////////////////////////////////////////////////////////////

inline R_Elem Ring::power(R_Elem a,L_int n) 
{
  R_Elem pow; 
  R_Elem tmp[65];
  int i;

  if(n==0) return(1); //0^0=1
  pow=1;
  if(n<0)
    {
      n=-n;
      tmp[0]=invert(a);
    }
  else tmp[0]=a;

  if(tmp[0]==0) return(0);

  i=0;
  // while((n!=0)&&(pow!=0)&&(tmp[i]!=1)) also possible
  while(n!=0)
    {
      if(n&1) pow=mult(pow,tmp[i]);
      tmp[i+1]=mult(tmp[i],tmp[i]);
      i++;
      n=n>>1;
    }
  return(pow);
}

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#endif
