#include "C_LeituraCEPEL.h"
#include "C_EntradaSaidaDados.h"
#include <iostream>
#include <fstream>

//////////////////////////////////////////////////////////////////////////
//Parâmetros para simular o CP em modo DC

const bool somente_volume_meta_no_ultimo_estagio = false;
const bool leitura_vazao_evaporada_meta = false;
const bool teste_hidreletrica_volume_meta = false;
const bool teste_hidreletrica_vazao_turbinada_disponivel_meta = false;
const bool teste_hidreletrica_potencia_disponivel_meta = false;
const bool teste_termeletrica_potencia_disponivel_meta = false;
/////////////////////////////////////////////////////////////////////////


IdEstagio idEstagioMaximo = IdEstagio_3; //Decomposição adoptada para o CP

const IdEstagio estagio_acoplamento_pre_estudo = IdEstagio_2; //Acoplamento com o PD

SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao_DC; //Somente é usado na leitura de dados do DECOMP para mapear a data do estágio DC e carregar a info no horizonte_estudo do SPT
														 //Os iteradores horizonte_otimizacao_DC são o horizonte_estocastico (forma como realiza a variável aleatória)

SmartEnupla<Periodo, bool> horizonte_processo_estocastico;
SmartEnupla<Periodo, int> numero_realizacoes_por_periodo;

std::vector<std::vector<double>> vazao_no_posto; //Linha: nó / Coluna: posto

Periodo data_execucao; //Periodo no qual o DC é executado (dia anterior ao periodo_inicial do horizonte de estudo)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Afluências passadas 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Notas:
//1. Se uma hidrelétrica tem mudança de posto entre o DECOMP  e NEWAVE -> As afluências observadas vão ser obtidas dos arquivos VAZOES.DAT e prevs.RVX do GEVAZP com os postos do DECOMP
//2. Se uma hidrelétrica NÃO tem mudança de posto entre o DECOMP  e NEWAVE -> As afluências observadas vão ser obtidas do arquivo VAZOES.RVX do DECOMP com os postos do DECOMP

SmartEnupla<int, SmartEnupla <Periodo, double>>  valor_afluencia_passadas_GEVAZP; //Valores de afluência dos meses e semanas passadas
SmartEnupla<int, SmartEnupla <Periodo, double>>  valor_afluencia_passadas_DECOMP; //Valores de afluência dos meses e semanas passadas
SmartEnupla<int, SmartEnupla <Periodo, double>>  valor_afluencia_historica; //Valores de afluência dos meses e semanas passadas

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Vazao defluente historica minima
SmartEnupla<int, SmartEnupla<Periodo, double>> porcentagem_vazao_minima_historica_REE;
bool inicializa_vetor_porcentagem_vazao_minima_historica_REE = true;
////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
//Restrições RHV (energia armazenada)

SmartEnupla<int, int> codigo_restricao_energia_armazenada;
SmartEnupla<int, IdReservatorioEquivalente> idReservatorioEquivalente_restricao_energia_armazenada;

////////////////////////////////////////////////////////////////////////////////////////
//SmartEnuplas auxiliares para a conversão
SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>                                 percentual_duracao_patamar_carga_deck; //Necessário para a conversão com a modulação informada na preConfig PD 
SmartEnupla <IdSubmercado, SmartEnupla<Periodo, double>>                                  demanda_media_deck; //Necessário para a conversão com a modulação informada na preConfig PD 
SmartEnupla <IdSubmercado, SmartEnupla<IdUsinaNaoSimulada, SmartEnupla<Periodo, double>>> geracao_usina_nao_simulada_media_deck; //Necessário para a conversão com a modulação informada na preConfig PD 

void LeituraCEPEL::leitura_DECOMP(Dados& a_dados, const std::string a_diretorio) {

	try {
		bool readPoliJusHidr_dat = true;
		const std::string revisao = leitura_CASO_201906_DC29(a_diretorio + "//CASO.DAT");

		//////////////////////////
		//Dados
		///////////////////////

		instancia_horizonte_preConfig(a_dados, a_dados.getAtributo(AttComumDados_diretorio_entrada_dados, std::string()) + "_PRECONFIG");
		instancia_dados_preConfig(a_dados, a_dados.getAtributo(AttComumDados_diretorio_entrada_dados, std::string()) + "_PRECONFIG");
		instancia_dados_matriz_preConfig(a_dados, a_dados.getAtributo(AttComumDados_diretorio_entrada_dados, std::string()) + "_PRECONFIG");

		if (!dadosPreConfig_instanciados) {
			a_dados.setAtributo(AttComumDados_tipo_geracao_cenario_hidrologico, TipoGeracaoCenario_serie_informada);
			a_dados.setAtributo(AttComumDados_mes_penalizacao_volume_util_minimo, IdMes_Nenhum);
		}//if (!dadosPreConfig_instanciados) {
		else {
			if(a_dados.getAtributo(AttComumDados_tipo_geracao_cenario_hidrologico, TipoGeracaoCenario()) != TipoGeracaoCenario_serie_informada)
				throw std::invalid_argument("Pre-config deve ter tipo_geracao_cenario_hidrologico igual a TipoGeracaoCenario_serie_informada");
		}//	else {


		////////////////////////////////////////////////////////////////////
		//Hidrelétricas
		////////////////////////////////////////////////////////////////////

		instancia_hidreletricas_preConfig(a_dados, a_dados.getAtributo(AttComumDados_diretorio_entrada_dados, std::string()) + "_PRECONFIG");
		std::ifstream myfile(a_diretorio + "/polinjus.dat");
		if (myfile.is_open()) { readPoliJusHidr_dat = false; }

		if (a_dados.getMaiorId(IdHidreletrica()) > IdHidreletrica_Nenhum)
			hidreletricasPreConfig_instanciadas = true;

		if (!hidreletricasPreConfig_instanciadas)
			instanciar_hidreletricas_from_VAZOES_201906_DC29(a_dados, a_diretorio + "//VAZOES." + revisao);


		instancia_processoEstocasticoHidrologico_preConfig(a_dados, a_dados.getAtributo(AttComumDados_diretorio_entrada_dados, std::string()) + "_PRECONFIG");

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Filosofia: 
		//1. Ler VAZOES para definir os horizontes de estudo e otimização, armazenando os valores de afluência de todos os postos em vetor local
		//2. Ler DADGER e ver as modificações "NUMPOS" para complementar o registro de postos do HIDR.DAT
		//3. Atualizar os valores de VARIAVEL_ALEATORIA_INTERNA_cenarios_realizacao_espaco_amostral e VARIAVEL_ALEATORIA_residuo_espaco_amostral
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		///////////////////////////////////////////////////////////////////////////////////////////////////////
		const bool imprimeArquivoVazoesRVX = false;

		if (imprimeArquivoVazoesRVX)//Somente para teste
			imprime_VAZOES_201906_DC29(a_dados, a_diretorio + "//VAZOES." + revisao);

		definir_horizonte_otimizacao_DC_from_VAZOES_201906_DC29(a_dados, a_diretorio + "//VAZOES." + revisao);

		defineHorizontes_CP(a_dados);

		if (!processoEstocasticoHidrologicoPreConfig_instanciado) {
			instanciar_processo_estocastico_CP(a_dados);

			ler_afluencia_passada_from_VAZOES_201906_DC29(a_dados, a_diretorio + "//VAZOES." + revisao);

			//Leitura da árvore de cenários

			if (numero_realizacoes_por_periodo.size() == 0)
				ler_vazao_probabilidade_estrutura_arvore_cenarios_from_VAZOES_201906_DC29(a_dados, a_diretorio + "//VAZOES." + revisao);//Lê árvore DC
		}
		//////////////////////////////////////////////////////////////////////////
		//Set numero_aberturas (vai mudar com a estrutura árvore)
		//////////////////////////////////////////////////////////////////////////


		if (a_dados.getSizeVetor(AttVetorDados_numero_aberturas) == 0) {

			if (!processoEstocasticoHidrologicoPreConfig_instanciado) {
				SmartEnupla<IdEstagio, int> vetor_numero_realizacoes(IdEstagio_1, std::vector<int>(int(a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo()).getIteradorFinal()), 1));
				vetor_numero_realizacoes.setElemento(a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo()).getIteradorFinal(), numero_realizacoes_por_periodo.getElemento(numero_realizacoes_por_periodo.getIteradorFinal()));
				a_dados.setVetor(AttVetorDados_numero_aberturas, vetor_numero_realizacoes);
			}
			else {
				const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
				for (IdEstagio idEstagio = a_dados.getIteradorInicial(AttVetorDados_horizonte_otimizacao, IdEstagio()); idEstagio <= a_dados.getIteradorFinal(AttVetorDados_horizonte_otimizacao, IdEstagio()); idEstagio++) {
					const Periodo periodo_otimizacao = a_dados.getElementoVetor(AttVetorDados_horizonte_otimizacao, idEstagio, Periodo());
					const Periodo periodo = horizonte_estudo.getIteradores(periodo_otimizacao).at(0);
					const int numero_aberturas = a_dados.processoEstocastico_hidrologico.getSize2Matriz(IdVariavelAleatoria_1, AttMatrizVariavelAleatoria_residuo_espaco_amostral, periodo);
					a_dados.addElemento(AttVetorDados_numero_aberturas, idEstagio, numero_aberturas);
					numero_realizacoes_por_periodo.addElemento(periodo_otimizacao, numero_aberturas);
				}
			}

		}//if (a_dados.getSizeVetor(AttVetorDados_numero_aberturas) == 0) {
		else {
			if (numero_realizacoes_por_periodo.size() == 0) {
				for (IdEstagio idEstagio = a_dados.getIteradorInicial(AttVetorDados_horizonte_otimizacao, IdEstagio()); idEstagio <= a_dados.getIteradorFinal(AttVetorDados_horizonte_otimizacao, IdEstagio()); idEstagio++) {
					const Periodo periodo_otimizacao = a_dados.getElementoVetor(AttVetorDados_horizonte_otimizacao, idEstagio, Periodo());
					numero_realizacoes_por_periodo.addElemento(periodo_otimizacao, a_dados.getElementoVetor(AttVetorDados_numero_aberturas, idEstagio, int()));
				}
			}
		}

		//*******************************************************************************
		//Cria o horizonte_processo_estocastico
		//***************************************************

		////////////////////////////////////////////////////
		//1.Periodos que pertencem ao horizonte SEM extensão
		////////////////////////////////////////////////////
		if (!processoEstocasticoHidrologicoPreConfig_instanciado) {
			const SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());
			SmartEnupla<Periodo, int> numero_realizacoes_por_periodo_atualizado;

			for (IdEstagio idEstagio_DC = IdEstagio_1; idEstagio_DC <= horizonte_otimizacao_DC.getIteradorFinal(); idEstagio_DC++) {

				const Periodo periodo_DC = horizonte_otimizacao_DC.at(idEstagio_DC);

				double soma_sobreposicao = 0.0;

				bool is_encontrada_sobreposicao = false;

				for (IdEstagio idEstagio_otimizacao = horizonte_otimizacao.getIteradorInicial(); idEstagio_otimizacao <= horizonte_otimizacao.getIteradorFinal(); idEstagio_otimizacao++) {

					const Periodo periodo_otimizacao = horizonte_otimizacao.getElemento(idEstagio_otimizacao);

					const double sobreposicao = periodo_DC.sobreposicao(periodo_otimizacao);

					if (sobreposicao > 0.0) {

						is_encontrada_sobreposicao = true;

						///////////////////////////////////////////////////////
						//Determina o periodo do processo estocástico (pega a menor granularidade entre o periodo_DC e o periodo_otimizacao)
						// E identifica se é o primeiro período com sobreposição
						///////////////////////////////////////////////////////

						Periodo periodo_processo_estocastico = periodo_DC;
						bool is_first_sobreposicao = false;

						if (periodo_DC.getTipoPeriodo() <= periodo_otimizacao.getTipoPeriodo()) { //Granularidade do periodo_otimizacao <= periodo_DC

							if (periodo_DC.getTipoPeriodo() < periodo_otimizacao.getTipoPeriodo())
								a_dados.processoEstocastico_hidrologico.setAtributo(AttComumProcessoEstocastico_tipo_lag_autocorrelacao, TipoLagAutocorrelacao_semanal_sab);

							periodo_processo_estocastico = periodo_otimizacao;

							if (periodo_otimizacao.sobreposicao(periodo_DC) == 1.0)//Garante que o periodo_otimizacao esteja "dentro" do periodo_DC
								soma_sobreposicao += sobreposicao;

							//////////////
							const Periodo periodo_teste = Periodo(periodo_otimizacao.getTipoPeriodo(), periodo_DC);

							if (periodo_teste == periodo_otimizacao)
								is_first_sobreposicao = true;


						}//if (periodo_DC.getTipoPeriodo() < periodo_otimizacao.getTipoPeriodo()) {
						else { //Granularidade do periodo_otimizacao > periodo_DC
							soma_sobreposicao += sobreposicao;
							is_first_sobreposicao = true;

						}//else {

						//////////////////////////////////////////////////////
						horizonte_processo_estocastico.addElemento(periodo_processo_estocastico, true);

						if (is_first_sobreposicao)
							numero_realizacoes_por_periodo_atualizado.addElemento(periodo_processo_estocastico, numero_realizacoes_por_periodo.at(periodo_DC));
						else
							numero_realizacoes_por_periodo_atualizado.addElemento(periodo_processo_estocastico, 1);

					}//if (sobreposicao_preenche_periodo_DC > 0 ) {

					if (is_encontrada_sobreposicao && sobreposicao == 0.0) {

						if (!doubleCompara(1e-6, soma_sobreposicao, 1.0))
							throw std::invalid_argument("Periodo do processo estocastico nao subsituido por uma decomposicao equivalente");

						break;

					}//if (is_encontrada_sobreposicao && sobreposicao == 0.0) {

				}//for (IdEstagio idEstagio_otimizacao = horizonte_otimizacao.getIteradorInicial(); idEstagio_otimizacao <= horizonte_otimizacao.getIteradorFinal(); idEstagio_otimizacao++) {


			}//for (IdEstagio idEstagio_DC = IdEstagio_1; idEstagio_DC <= horizonte_otimizacao_DC.getIteradorFinal(); idEstagio_DC++) {

			////////////////////////////////////////////////////
			//2.Periodos que pertencem ao horizonte COM extensão
			////////////////////////////////////////////////////

			const Periodo periodo_extensao = Periodo(TipoPeriodo_mensal, horizonte_otimizacao_DC.at(horizonte_otimizacao_DC.getIteradorFinal())+1);

			for (IdEstagio idEstagio_otimizacao = horizonte_otimizacao.getIteradorInicial(); idEstagio_otimizacao <= horizonte_otimizacao.getIteradorFinal(); idEstagio_otimizacao++) {

				const Periodo periodo_otimizacao = horizonte_otimizacao.getElemento(idEstagio_otimizacao);

				if (periodo_otimizacao >= periodo_extensao) {
					horizonte_processo_estocastico.addElemento(periodo_otimizacao, true);
					numero_realizacoes_por_periodo_atualizado.addElemento(periodo_otimizacao, a_dados.getElementoVetor(AttVetorDados_numero_aberturas, idEstagio_otimizacao, int()));
				}//if (periodo_otimizacao > periodo_extensao) {

			}//for (IdEstagio idEstagio_otimizacao = horizonte_otimizacao.getIteradorInicial(); idEstagio_otimizacao <= horizonte_otimizacao.getIteradorFinal(); idEstagio_otimizacao++) {

			//*******************************************************************************


			//Atualiza o numero_realizacoes_por_periodo (pode ter novos periodos do processo estocástico dependendo do horizonte_otimizacao
			numero_realizacoes_por_periodo = numero_realizacoes_por_periodo_atualizado;


			define_numero_cenarios_CP(a_dados);
		} // if (!processoEstocasticoHidrologicoPreConfig_instanciado) {

		///////////////////////////////////////////////////////////////////////////////////////////////////////

		instanciar_membros_das_hidreletricas_instanciadas(a_dados);

		leitura_DADGER_201906_DC29(a_dados, a_diretorio + "//DADGER." + revisao);

		leitura_DADGNL_201906_DC29_A(a_dados, a_diretorio + "//DADGNL." + revisao, a_diretorio + "//relgnl." + revisao, a_diretorio + "//DadosAdicionais//relgnl." + revisao);// Ajustar que a geração comandada pode estar fora do horizonte_estudo
		leitura_DADGNL_201906_DC29_B(a_dados, a_diretorio, "DADGNL." + revisao);// Ajustar que a geração comandada pode estar fora do horizonte_estudo

		leitura_CADUSIH_201904_NW25_DC29_DES16(a_dados, a_diretorio + "//HIDR.DAT", hidreletricasPreConfig_instanciadas, readPoliJusHidr_dat, true, false, 0);

		leitura_PERDAS_201906_DC29(a_dados, a_diretorio + "//PERDAS.DAT");

		leitura_MLT_201906_DC29(a_dados, a_diretorio + "//MLT.DAT");

		leitura_POLIJUS(a_dados, a_diretorio + "//polinjus.dat");

		leitura_setPercentualVolumeCalculoFPH(a_dados);

		//Instancia intercâmbio hidráulicos das jusantes_desvio
		//adicionaIntercambiosHidraulicosApartirJusanteDesvio(a_dados);

		adicionaLimitesDesvioApartirJusanteDesvio(a_dados);

		////////////////////////////////////////////////////////////////////////////////
		//Determina se o arquivo de tendencia imprime os registros das vazões observadas
		////////////////////////////////////////////////////////////////////////////////
		if (!processoEstocasticoHidrologicoPreConfig_instanciado) {
			const bool criar_tendencia_temporal_com_vazoes_observadas = criar_tendencia_temporal_com_vazoes_observadas_CP(a_diretorio, revisao);

			if (criar_tendencia_temporal_com_vazoes_observadas) {

				std::string arquivo_vazoes_dat = a_diretorio + "//VAZOES.DAT";

				std::ifstream leituraArquivo_vazoes_dat(arquivo_vazoes_dat);

				if (!leituraArquivo_vazoes_dat.is_open())
					arquivo_vazoes_dat = a_diretorio + "//DadosAdicionais//VAZOES.DAT";
				else {
					leituraArquivo_vazoes_dat.clear();
					leituraArquivo_vazoes_dat.close();
				}//else {

				leitura_TENDENCIA_VAZOES_MENSAIS_GEVAZP(a_dados, arquivo_vazoes_dat);

				ler_historico_afluencia_from_VAZOES_201906_DC29(a_dados, arquivo_vazoes_dat);

				const bool imprimeArquivoVazoesDAT = false;

				if (imprimeArquivoVazoesDAT)//Somente para teste
					imprime_VAZOES_DAT();

				if (revisao != "rv0") {

					std::string arquivo_prevs = a_diretorio + "//prevs";

					std::ifstream leituraArquivo_prevs(arquivo_prevs);

					if (!leituraArquivo_prevs.is_open())
						arquivo_prevs = a_diretorio + "//DadosAdicionais//prevs";
					else {
						leituraArquivo_prevs.clear();
						leituraArquivo_prevs.close();
					}//else {

					leitura_TENDENCIA_VAZOES_SEMANAIS_GEVAZP(a_dados, arquivo_prevs, revisao);

				}

			}//if (criar_tendencia_temporal_com_vazoes_observadas) {
		}

		////////////////////////////////////////////////////////////////////////////////

		validacoes_DC(a_dados, a_diretorio, revisao);

	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_DECOMP: \n" + std::string(erro.what())); }

}

std::string LeituraCEPEL::leitura_CASO_201906_DC29(std::string nomeArquivo)
{

	try {

		std::ifstream leituraArquivo(nomeArquivo);
		std::string line;

		std::string atributo;
		std::string revisao;

		////////////////////////////////////////////////////////

		if (leituraArquivo.is_open()) {

			std::getline(leituraArquivo, line);

			strNormalizada(line);

			atributo = line.substr(0, 80);
			atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

			revisao = atributo;

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

		return revisao;

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_CASO_201906_DC29: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_POLIJUS(Dados& a_dados, std::string a_nomeArquivo) {

	try {
		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		std::vector<int>lista_codigo_usina;
		std::vector<int>lista_indice_polinomio;
		std::vector<int>lista_numero_polinomios;
		std::vector<double>lista_h_jus_ref;


		std::ifstream myfile(a_nomeArquivo);
		std::string line;
		std::string atributo;
		if (myfile.is_open()) {

			while (std::getline(myfile, line)) {
				strNormalizada(line);

				if (line.substr(0, 8) == "CURVAJUS") {

					atributo = line.substr(11, 4);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					lista_codigo_usina.push_back(std::stoi(atributo));

					atributo = line.substr(20, 3);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					lista_indice_polinomio.push_back(std::stoi(atributo));

					atributo = line.substr(27, 10);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					lista_h_jus_ref.push_back(std::stod(atributo));

					atributo = line.substr(39, 3);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					lista_numero_polinomios.push_back(std::stoi(atributo));
				}

				if (line.substr(0, 6) == "PPPJUS") {

					atributo = line.substr(11, 4);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					const int codigo_usina = std::stoi(atributo);

					atributo = line.substr(20, 3);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					const int indici_poli = std::stoi(atributo);
					const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

					if (idHidreletrica != IdHidreletrica_Nenhum) {
						for (int i = 0; i < int(lista_indice_polinomio.size()); i++) {
							if ((lista_codigo_usina.at(i) == codigo_usina) && (lista_indice_polinomio.at(i) == indici_poli)) {
								IdPolinomioJusante idPolinomio = IdPolinomioJusante(a_dados.getMaiorId(idHidreletrica, IdPolinomioJusante()) + 1);
								PolinomioJusante polinomioJusante;
								polinomioJusante.setAtributo(AttComumPolinomioJusante_idPolinomioJusante, idPolinomio);
								polinomioJusante.setAtributo(AttComumPolinomioJusante_altura_jusante_ref, lista_h_jus_ref.at(i));
								polinomioJusante.setAtributo(AttComumPolinomioJusante_altura_ref, 0.0);
								polinomioJusante.setAtributo(AttComumPolinomioJusante_defluencia_minima, std::stod(line.substr(28, 20)));

								double defluencia_maxima = std::stod(line.substr(49, 20));

								if (defluencia_maxima >= 1e10)
									defluencia_maxima = getdoubleFromChar("max");

								polinomioJusante.setAtributo(AttComumPolinomioJusante_defluencia_maxima, defluencia_maxima);
								polinomioJusante.setVetor(AttVetorPolinomioJusante_altura_ref, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));
								polinomioJusante.setVetor(AttVetorPolinomioJusante_altura_jusante_ref, SmartEnupla<Periodo, double>(horizonte_estudo, lista_h_jus_ref.at(i)));

								//////////////////////////////////////

								atributo = line.substr(70, 20);
								polinomioJusante.setVetor(AttVetorPolinomioJusante_coeficiente_0, SmartEnupla<Periodo, double>(horizonte_estudo, std::stod(atributo.substr(0, int(atributo.find("D")))) * std::pow(10, std::stod(atributo.substr(int(atributo.find("D")) + 1, 19 - int(atributo.find("D")))))));

								//////////////////////////////////////

								atributo = line.substr(91, 20);
								polinomioJusante.setVetor(AttVetorPolinomioJusante_coeficiente_1, SmartEnupla<Periodo, double>(horizonte_estudo, std::stod(atributo.substr(0, int(atributo.find("D")))) * std::pow(10, std::stod(atributo.substr(int(atributo.find("D")) + 1, 19 - int(atributo.find("D")))))));

								//////////////////////////////////////

								atributo = line.substr(112, 20);
								polinomioJusante.setVetor(AttVetorPolinomioJusante_coeficiente_2, SmartEnupla<Periodo, double>(horizonte_estudo, std::stod(atributo.substr(0, int(atributo.find("D")))) * std::pow(10, std::stod(atributo.substr(int(atributo.find("D")) + 1, 19 - int(atributo.find("D")))))));

								//////////////////////////////////////

								atributo = line.substr(133, 20);
								polinomioJusante.setVetor(AttVetorPolinomioJusante_coeficiente_3, SmartEnupla<Periodo, double>(horizonte_estudo, std::stod(atributo.substr(0, int(atributo.find("D")))) * std::pow(10, std::stod(atributo.substr(int(atributo.find("D")) + 1, 19 - int(atributo.find("D")))))));

								//////////////////////////////////////

								atributo = line.substr(154, 20);
								polinomioJusante.setVetor(AttVetorPolinomioJusante_coeficiente_4, SmartEnupla<Periodo, double>(horizonte_estudo, std::stod(atributo.substr(0, int(atributo.find("D")))) * std::pow(10, std::stod(atributo.substr(int(atributo.find("D")) + 1, 19 - int(atributo.find("D")))))));

								//////////////////////////////////////
								a_dados.vetorHidreletrica.at(idHidreletrica).vetorPolinomioJusante.add(polinomioJusante);
								break;
							}

						}//for (int i = 0; i <= size(lista_indice_polinomio); i++) {	
					}//if (idHidreletrica != IdHidreletrica_Nenhum) {
				}//if (line.substr(0, 8) == "PPPJUS") {

			}//while (std::getline(myfile, line)) {
			myfile.close();
		}//if (myfile.is_open()) {
	}
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_POLIJUS: \n" + std::string(erro.what())); }
}

void LeituraCEPEL::leitura_setPercentualVolumeCalculoFPH(Dados& a_dados) {

	try {
		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			double percentual = 0.2;
			Periodo periodoFinalDC = horizonte_otimizacao_DC.at(horizonte_otimizacao_DC.getIteradorFinal());
			if (periodo.sobreposicao(periodoFinalDC) > 0)
				percentual = 0.5;

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {
				if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.isInstanciado(IdFuncaoProducaoHidreletrica_1) == false) {
					FuncaoProducaoHidreletrica Fph;
					Fph.setAtributo(AttComumFuncaoProducaoHidreletrica_idFuncaoProducaoHidreletrica, IdFuncaoProducaoHidreletrica_1);
					a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.add(Fph);
					a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setVetor(AttVetorFuncaoProducaoHidreletrica_percentual_volume_minimo, SmartEnupla<Periodo, double>(horizonte_estudo, 0.2));
					a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setVetor(AttVetorFuncaoProducaoHidreletrica_percentual_volume_maximo, SmartEnupla<Periodo, double>(horizonte_estudo, 0.2));
				}
				a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setElemento(AttVetorFuncaoProducaoHidreletrica_percentual_volume_minimo, periodo, percentual);
				a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setElemento(AttVetorFuncaoProducaoHidreletrica_percentual_volume_maximo, periodo, percentual);
			}
		}

	}
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_setPercentualVolumeCalculoFPH: \n" + std::string(erro.what())); }
}

void LeituraCEPEL::instanciar_membros_das_hidreletricas_instanciadas(Dados& a_dados) {

	try {

		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			//Set Atributo
			//if (idHidreletrica != IdHidreletrica_168_SOBRADINHO_FICTICIO)
			//a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica_por_usina);

			/////////////////////////////////////////////////
			//inicializa afluência

			if (!a_dados.vetorHidreletrica.at(idHidreletrica).vetorAfluencia.isInstanciado(IdAfluencia_vazao_afluente)) {
				Afluencia afluencia;
				afluencia.setAtributo(AttComumAfluencia_idAfluencia, IdAfluencia_vazao_afluente);
				a_dados.vetorHidreletrica.at(idHidreletrica).vetorAfluencia.add(afluencia);
			}

			/////////////////////////////////////////////////

			//INSTANCIA O RESERVATÓRIO, SE NÃO ESTIVER INSTANCIADO 
			if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.isInstanciado(IdReservatorio_1) == false) {
				Reservatorio reservatorio;
				reservatorio.setAtributo(AttComumReservatorio_idReservatorio, IdReservatorio_1);
				a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.add(reservatorio);

			}//if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.isInstanciado(IdReservatorio_1) == false) {

			/////////////////////////////////////////////////

			if (!processoEstocasticoHidrologicoPreConfig_instanciado)
				instanciar_variavelAleatoria_x_idHidreletrica(a_dados, idHidreletrica);

			/////////////////////////////////////////////////

			if (hidreletricasPreConfig_instanciadas) {

				//Modo carrega hidreletricasPreConfig:
				//Inicializa listas de jusante e jusante_desvio, logo são atualizadas no HIDR.dat + modificações NUMJUS para validar com a configuração do CP

				lista_jusante_hidreletrica.setElemento(idHidreletrica, IdHidreletrica_Nenhum);
				lista_jusante_desvio_hidreletrica.setElemento(idHidreletrica, IdHidreletrica_Nenhum);

			}//if (hidreletricasPreConfig_instanciadas) {

			//////////////////////////////////////////////

			/////////////////////////////////////////////
			//if ((!hidreletricasPreConfig_instanciadas) && (lista_codigo_ONS_REE.at(idHidreletrica) == -1))
				//lista_codigo_ONS_REE.setElemento(idHidreletrica, 0);

		}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::instanciar_membros_das_hidreletricas_instanciadas: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::instanciar_variavelAleatoria_x_idHidreletrica(Dados& a_dados, const IdHidreletrica a_idHidreletrica) {

	try {

		IdVariavelAleatoria idVariavelAleatoria = a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.getMaiorId();

		if (idVariavelAleatoria == IdVariavelAleatoria_Nenhum)
			idVariavelAleatoria = IdVariavelAleatoria_1;
		else
			idVariavelAleatoria++;

		VariavelAleatoria variavelAleatoria;

		variavelAleatoria.setAtributo(AttComumVariavelAleatoria_idVariavelAleatoria, idVariavelAleatoria);
		variavelAleatoria.setAtributo(AttComumVariavelAleatoria_ordem_maxima_coeficiente_auto_correlacao, 0);
		variavelAleatoria.setAtributo(AttComumVariavelAleatoria_tipo_coeficiente_auto_correlacao, TipoValor_positivo_e_negativo);

		a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.add(variavelAleatoria);

		/////////////////////////////////////////////////
		lista_hidreletrica_IdVariavelAleatoria.at(a_idHidreletrica) = idVariavelAleatoria;



	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::instanciar_variavelAleatoria_x_idHidreletricas: \n" + std::string(erro.what())); }

}

bool LeituraCEPEL::criar_tendencia_temporal_com_vazoes_observadas_CP(const std::string a_diretorio, const std::string a_revisao)
{
	try {
		//A tendência temporal para acoplar com o MP, os valores mensais/semanais observados são obtidos dos arquivos do GEVAZP: VAZOES.DAT e prevs.RVX

		const std::string vazoes_dat_raiz = a_diretorio + "//VAZOES.DAT";
		const std::string prevs_raiz = a_diretorio + "//prevs." + a_revisao;

		const std::string vazoes_dat_adicional = a_diretorio + "//DadosAdicionais//VAZOES.DAT";
		const std::string prevs_adicional = a_diretorio + "//DadosAdicionais//prevs." + a_revisao;

		std::ifstream leituraArquivo_vazoes_raiz(vazoes_dat_raiz);
		std::ifstream leituraArquivo_prevs_raiz(prevs_raiz);

		std::ifstream leituraArquivo_vazoes_adicional(vazoes_dat_adicional);
		std::ifstream leituraArquivo_prevs_adicional(prevs_adicional);

		if (!leituraArquivo_vazoes_raiz.is_open() && !leituraArquivo_vazoes_adicional.is_open())
			return false;

		if (a_revisao == "rv0")
			return true;
		else {

			leituraArquivo_vazoes_raiz.clear();
			leituraArquivo_vazoes_raiz.close();

			leituraArquivo_vazoes_adicional.clear();
			leituraArquivo_vazoes_adicional.close();

			if (!leituraArquivo_prevs_raiz.is_open() && !leituraArquivo_prevs_adicional.is_open())
				return false;

		}//else {

		leituraArquivo_prevs_raiz.clear();
		leituraArquivo_prevs_raiz.close();

		leituraArquivo_prevs_adicional.clear();
		leituraArquivo_prevs_adicional.close();

		return true;

	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("criar_tendencia_temporal_com_vazoes_observadas_CP: \n" + std::string(erro.what())); }

}//bool LeituraCEPEL::criar_tendencia_temporal_com_vazoes_observadas_CP(const std::string a_revisao)

void LeituraCEPEL::imprime_VAZOES_201906_DC29(Dados& a_dados, std::string nomeArquivo) {

	try {

		//Nota registro 2 é ignorado porque as usinas hidréletricas neste ponto já foram instanciadas

		std::ofstream     fp_out;

		std::string arquivo = "VAZOES.csv";
		fp_out.open(arquivo.c_str(), std::ios_base::out); //Função para criar um arquivo


		const int tamanho = 320;
		int intLeitura[tamanho];
		float floatLeitura[tamanho];

		int registro = 0;
		int numNos = 0;
		int NPROB = 0;

		int  registroProbabilidade_controle = 0;
		bool registroProbabilidade = true;

		///////////////////////////////////////////////////////////////////
		std::ifstream leituraArquivo;
		leituraArquivo.open(nomeArquivo, std::ios_base::in | std::ios::binary);

		if (leituraArquivo.is_open()) {

			while (!(leituraArquivo.eof())) {

				registro++;

				///////////////////////////////////////
				//Identifica o tipo do registro
				///////////////////////////////////////

				if (registro >= 4 && registroProbabilidade == true)
					leituraArquivo.read((char*)floatLeitura, sizeof(floatLeitura));
				else
					leituraArquivo.read((char*)intLeitura, sizeof(intLeitura));

				if (registro == 1) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registro 1 -  total de postos considerados , número de estágios considerados  e número de aberturas em cada estágio
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					const int numEstagios_DC = intLeitura[1]; // Número de estágios do problema

					//Número de aberturas por estágio do DECOMP

					//numero_realizacoes_DC(numEstagios_DC);//Número de realizações por estágio da árvore de cenários

					//Determina o número de nós do problema
					for (int pos = 2; pos < 2 + numEstagios_DC; pos++)
						numNos += intLeitura[pos]; //Número de nós por estágio


					//Define o número de registros para a probabilidade
					NPROB = numNos / 320;
					NPROB += 1;

				}//if (registro == 1) {

				//Imprime os valores
				for (int pos = 0; pos < tamanho; pos++) {

					if (registro >= 4 && registroProbabilidade == true)
						fp_out << floatLeitura[pos] << ";";
					else
						fp_out << intLeitura[pos] << ";";

				}//for (int pos = 0; pos < 320; pos++) {

				fp_out << std::endl; //Passa de linha

				if (registro >= 4 && registroProbabilidade == true) {

					registroProbabilidade_controle++;

					if (NPROB == registroProbabilidade_controle)
						registroProbabilidade = false;

				}//if (registro >= 4 && registroProbabilidade == true) {

			}//while (!(leituraArquivo.eof())) {

			fp_out.close();

			leituraArquivo.clear();
			leituraArquivo.close();

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::imprime_VAZOES_201906_DC29: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::imprime_VAZOES_DAT() {

	try {

		std::ofstream     fp_out;

		std::string arquivo = "VAZOES_DAT.csv";
		fp_out.open(arquivo.c_str(), std::ios_base::out); //Função para criar um arquivo

		const int numero_postos = int(valor_afluencia_historica.size());

		const Periodo periodo_inicial = valor_afluencia_historica.at(0).getIteradorInicial();
		const Periodo periodo_final = valor_afluencia_historica.at(0).getIteradorFinal();

		for (Periodo periodo = periodo_inicial; periodo <= periodo_final; valor_afluencia_historica.at(0).incrementarIterador(periodo)) {

			for (int posto = 0; posto < numero_postos; posto++)
				fp_out << valor_afluencia_historica.at(posto).getElemento(periodo) << ";";
					
			fp_out << std::endl; //Passa de linha

		}//for (int posto = 0; posto < numero_postos; posto++) {

		fp_out.close();

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::imprime_VAZOES_DAT: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::ler_vazao_probabilidade_estrutura_arvore_cenarios_from_VAZOES_201906_DC29(Dados& a_dados, std::string nomeArquivo) {

	try {

		const SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());

		int mesInicial_PMO;
		int anoInicial_PMO;
		int diasNoSeguinteMes;

		Periodo periodo_semana_PMO; //Começa na primeira semana do PMO

		int revisao; //Dado para controlar a leitura das afluências históricas

		const int tamanho = 320;
		int intLeitura[tamanho];
		float floatLeitura[tamanho];

		int registro = 0;
		int numNos = 0;
		int NPROB; //Número de registros de probabilidade

		int numUHE;
		int numPostos;

		int  registroProbabilidade_controle = 0;
		bool registroProbabilidade = true;

		SmartEnupla <IdRealizacao, double> probabilidade_abertura; //Probabilidade das aberturas do último estágio no DC //Apagar em algum momento

		int conteio_registro_vazoes = 0;

		int conteio_registro_afluencias_passadas = 0;

		int dia_afluencia_historica = 1; //O dia acopla todos os periodos semanais para a leitura das afluências_incremental_tendencia mensais e semanais

		int conteio_realizacoes = 0;

		int conteio_estagio = 0;

		bool registroAfluenciasPassadas = false;

		///////////////////////////////////////////////////////////////////
		std::ifstream leituraArquivo;
		leituraArquivo.open(nomeArquivo, std::ios_base::in | std::ios::binary);

		if (leituraArquivo.is_open()) {

			while (!(leituraArquivo.eof())) {

				registro++;

				///////////////////////////////////////
				//Identifica o tipo do registro
				///////////////////////////////////////

				if (registro >= 4 && registroProbabilidade == true)
					leituraArquivo.read((char*)floatLeitura, sizeof(floatLeitura));
				else
					leituraArquivo.read((char*)intLeitura, sizeof(intLeitura));


				if (registro == 1) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registro 1 -  total de postos considerados , número de estágios considerados  e número de aberturas em cada estágio
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					numUHE = intLeitura[0]; // Total de postos considerados
					const int numEstagios_DC = intLeitura[1]; // Número de estágios do problema

					//Número de aberturas por estágio do DECOMP

					//numero_realizacoes_DC(numEstagios_DC);//Número de realizações por estágio da árvore de cenários

					//Determina o número de nós do problema
					for (int pos = 2; pos < 2 + numEstagios_DC; pos++) {
						numNos += intLeitura[pos]; //Número de nós por estágio

						const IdEstagio idEstagio = getIdEstagioFromChar(getString(pos - 1).c_str());

						numero_realizacoes_por_periodo.addElemento(horizonte_otimizacao_DC.getElemento(idEstagio), intLeitura[pos]);

					}//for (int pos = 2; pos < 2 + numEstagios_DC; pos++) {

					//Inicializa probabilidade_abertura

					const int numero_realizacoes = numero_realizacoes_por_periodo.getElemento(numero_realizacoes_por_periodo.getIteradorFinal());

					for (int realizacao = 1; realizacao <= numero_realizacoes; realizacao++) {

						const IdRealizacao idRealizacao = IdRealizacao(realizacao);
						probabilidade_abertura.addElemento(idRealizacao, 0.0);

					}//for (int realizacao = 1; realizacao <= numero_realizacoes; realizacao++) {

					//Define o número de registros para a probabilidade
					NPROB = int(numNos / 320);
					NPROB += 1;

				}//if (registro == 1) {
				else if (registro == 3) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registro 3 - número de semanas completas, número de dias que devem ser excluídos do estágio seguinte 
					//             ao mês inicial decomposto em semanas, índice do mês inicial do estudo  e ano do mês inicial do estudo
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					const int numSemanasEstudo = intLeitura[0];
					diasNoSeguinteMes = intLeitura[1];
					mesInicial_PMO = intLeitura[2];
					anoInicial_PMO = intLeitura[3];
					numPostos = intLeitura[4];
					revisao = intLeitura[5];

				}//else if (registro == 3) {
				else if (registro >= 4 && registroProbabilidade == true) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registros 4 e subsequentes : probabilidades associadas a cada nó
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					int pos = 0;

					while (true) {

						if (pos == 320 || floatLeitura[pos] == 0)
							break;

						char buffer[100];
						std::snprintf(buffer, sizeof(buffer), "%f", floatLeitura[pos]);

						const double prob = std::atof(buffer);

						conteio_estagio++;

						if (registro == 4) {

							if (pos + 1 >= int(horizonte_otimizacao_DC.size())) {//Somente armazena as probabilidades referentes às aberturas (último mês)

								conteio_realizacoes++;

								const IdRealizacao idRealizacao = IdRealizacao(conteio_realizacoes);
								probabilidade_abertura.setElemento(idRealizacao, prob);

								//a_dados.processoEstocastico_hidrologico.addElemento(AttMatrizProcessoEstocastico_no_probabilidade, horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()), IdNo(conteio_realizacoes + 1), prob);

							}//if (pos + 1 >= int(horizonte_otimizacao_DC.size())) {
							//else
								//a_dados.processoEstocastico_hidrologico.addElemento(AttMatrizProcessoEstocastico_no_probabilidade, horizonte_otimizacao_DC.getElemento(IdEstagio(conteio_estagio)), IdNo_1, prob);

						}//if (registro == 4) {
						else {

							conteio_realizacoes++;

							const IdRealizacao idRealizacao = IdRealizacao(conteio_realizacoes);
							probabilidade_abertura.setElemento(idRealizacao, prob);

							//a_dados.processoEstocastico_hidrologico.addElemento(AttMatrizProcessoEstocastico_no_probabilidade, horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()), IdNo(conteio_realizacoes + 1), prob);

						}//else {

						pos++;

					}//while (true) 

					bool arvoreEquiprovavel = false;

					if (pos == 0) {

						arvoreEquiprovavel = true;

						//Manual: Se estes valores forem nulos as vazões serão consideradas equiprováveis
						//Árvore equiprovável

						//Somente registra as probabilidades associadas às aberturas (último mes)

						const int numero_realizacoes = numero_realizacoes_por_periodo.getElemento(numero_realizacoes_por_periodo.getIteradorFinal());

						for (int realizacao = 0; realizacao < numero_realizacoes; realizacao++)
							probabilidade_abertura.setElemento(IdRealizacao(realizacao + 1), std::pow(numero_realizacoes, -1));

						////////////////////////////////////////

						const IdEstagio idEstagio_inicial = horizonte_otimizacao_DC.getIteradorInicial();
						const IdEstagio idEstagio_final = horizonte_otimizacao_DC.getIteradorFinal();

						int numero_nos = 1;

						for (IdEstagio idEstagio = idEstagio_inicial; idEstagio <= idEstagio_final; idEstagio++) {

							numero_nos *= numero_realizacoes_por_periodo.getElemento(horizonte_otimizacao_DC.getElemento(idEstagio));

							const double prob = 1.0 / numero_realizacoes_por_periodo.getElemento(horizonte_otimizacao_DC.getElemento(idEstagio));

							//for (int no = 0; no < numero_nos; no++)
								//a_dados.processoEstocastico_hidrologico.addElemento(AttMatrizProcessoEstocastico_no_probabilidade, horizonte_otimizacao_DC.getElemento(idEstagio), IdNo(no + 2), prob);

						}//for (IdEstagio idEstagio = idEstagio_inicial; idEstagio <= idEstagio_final; idEstagio++) {

					}//if (pos == 0) {

					/////////////////////////////////////

					//Controle do número de registros referentes às probabilidades dos nós da árvore
					registroProbabilidade_controle++;

					if (NPROB == registroProbabilidade_controle || arvoreEquiprovavel) {

						registroProbabilidade = false;

						//////////////////////////////////////////////////////////////////////////
						//Set probabilidade_abertura no processo estocástico
						//////////////////////////////////////////////////////////////////////////

						SmartEnupla <Periodo, SmartEnupla <IdRealizacao, double>> matriz_probabilidade_abertura;

						bool is_encontrada_sobreposicao = false;

							
						for (IdEstagio idEstagio_otimizacao = horizonte_otimizacao.getIteradorInicial(); idEstagio_otimizacao <= horizonte_otimizacao.getIteradorFinal(); idEstagio_otimizacao++) {

							const Periodo periodo_otimizacao = horizonte_otimizacao.getElemento(idEstagio_otimizacao);
							const Periodo periodo_DC = horizonte_otimizacao_DC.at(horizonte_otimizacao_DC.getIteradorFinal());

							const double sobreposicao = periodo_DC.sobreposicao(periodo_otimizacao);//Identifica o primeiro periodo que tenha sobreposicao com o último periodo do horizonte_otimizacao_DC

							if (sobreposicao > 0.0) {

								is_encontrada_sobreposicao = true;

								///////////////////////////////////////////////////////
								//Determina o periodo do processo estocástico (pega a menor granularidade entre o periodo_DC e o periodo_otimizacao)
								// E identifica se é o primeiro período com sobreposição
								///////////////////////////////////////////////////////

								Periodo periodo_processo_estocastico = periodo_DC;

								if (periodo_DC.getTipoPeriodo() <= periodo_otimizacao.getTipoPeriodo()) //Granularidade do periodo_otimizacao <= periodo_DC
									periodo_processo_estocastico = periodo_otimizacao;

								matriz_probabilidade_abertura.addElemento(periodo_processo_estocastico, probabilidade_abertura);
								a_dados.processoEstocastico_hidrologico.setMatriz_forced(AttMatrizProcessoEstocastico_probabilidade_realizacao, matriz_probabilidade_abertura);
								break;


							}//if (sobreposicao > 0.0) {

						}//for (IdEstagio idEstagio_otimizacao = horizonte_otimizacao.getIteradorInicial(); idEstagio_otimizacao <= horizonte_otimizacao.getIteradorFinal(); idEstagio_otimizacao++) {

						a_dados.processoEstocastico_hidrologico.validar_probabilidade_realizacao();

					}//if (NPROB == registroProbabilidade_controle || arvoreEquiprovavel) {

				}//if (registro >= 4 && registroProbabilidade == true) {
				else if (registro >= 4 && registroProbabilidade == false && conteio_registro_vazoes < numNos) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registros (4 + NPROB) e subsequentes : vazões incrementais
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					std::vector<double> vazao_no_posto_auxiliar(numPostos, 0.0);

					for (int posto = 0; posto < numPostos; posto++)
						vazao_no_posto_auxiliar.at(posto) = intLeitura[posto];

					vazao_no_posto.push_back(vazao_no_posto_auxiliar);

					conteio_registro_vazoes++;

				}//else if (registro >= 4 && registroProbabilidade == false && conteio_registro_vazoes < numNos) {

			}//while (!(leituraArquivo.eof())) {

			leituraArquivo.clear();
			leituraArquivo.close();

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::ler_vazao_probabilidade_estrutura_arvore_cenarios_from_VAZOES_201906_DC29: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::ler_afluencia_passada_from_VAZOES_201906_DC29(Dados& a_dados, std::string nomeArquivo) {

	try {

		int mesInicial_PMO;
		int anoInicial_PMO;
		int diasNoSeguinteMes;

		Periodo periodo_semana_PMO; //Começa na primeira semana do PMO

		int revisao; //Dado para controlar a leitura das afluências históricas

		const int tamanho = 320;
		int intLeitura[tamanho];
		float floatLeitura[tamanho];

		int registro = 0;
		int numNos = 0;
		int NPROB; //Número de registros de probabilidade

		int numUHE;
		int numPostos;

		int  registroProbabilidade_controle = 0;
		bool registroProbabilidade = true;

		int conteio_registro_vazoes = 0;

		int conteio_registro_afluencias_passadas = 0;

		int dia_afluencia_historica = 1; //O dia acopla todos os periodos semanais para a leitura das afluências_incremental_tendencia mensais e semanais

		int conteio_realizacoes = 0;

		bool registroAfluenciasPassadas = false;

		///////////////////////////////////////////////////////////////////
		std::ifstream leituraArquivo;
		leituraArquivo.open(nomeArquivo, std::ios_base::in | std::ios::binary);

		if (leituraArquivo.is_open()) {

			while (!(leituraArquivo.eof())) {

				registro++;

				///////////////////////////////////////
				//Identifica o tipo do registro
				///////////////////////////////////////

				if (registro >= 4 && registroProbabilidade == true)
					leituraArquivo.read((char*)floatLeitura, sizeof(floatLeitura));
				else
					leituraArquivo.read((char*)intLeitura, sizeof(intLeitura));


				if (registro == 1) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registro 1 -  total de postos considerados , número de estágios considerados  e número de aberturas em cada estágio
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					numUHE = intLeitura[0]; // Total de postos considerados
					const int numEstagios_DC = intLeitura[1]; // Número de estágios do problema

					//Número de aberturas por estágio do DECOMP

					//numero_realizacoes_DC(numEstagios_DC);//Número de realizações por estágio da árvore de cenários

					//Determina o número de nós do problema
					for (int pos = 2; pos < 2 + numEstagios_DC; pos++)
						numNos += intLeitura[pos]; //Número de nós por estágio

					//Define o número de registros para a probabilidade
					NPROB = int(numNos / 320);
					NPROB += 1;

				}//if (registro == 1) {
				else if (registro == 3) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registro 3 - número de semanas completas, número de dias que devem ser excluídos do estágio seguinte 
					//             ao mês inicial decomposto em semanas, índice do mês inicial do estudo  e ano do mês inicial do estudo
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					const int numSemanasEstudo = intLeitura[0];
					diasNoSeguinteMes = intLeitura[1];
					mesInicial_PMO = intLeitura[2];
					anoInicial_PMO = intLeitura[3];
					numPostos = intLeitura[4];
					revisao = intLeitura[5];

				}//else if (registro == 3) {
				else if (registro >= 4 && registroProbabilidade == true) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registros 4 e subsequentes : probabilidades associadas a cada nó
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					bool arvoreEquiprovavel = false;

					if (floatLeitura[0] == 0)
						arvoreEquiprovavel = true;

					/////////////////////////////////////

					//Controle do número de registros referentes às probabilidades dos nós da árvore
					registroProbabilidade_controle++;

					if (NPROB == registroProbabilidade_controle || arvoreEquiprovavel) {

						registroProbabilidade = false;

					}//if (NPROB == registroProbabilidade_controle || arvoreEquiprovavel) {

				}//if (registro >= 4 && registroProbabilidade == true) {
				else if (registroAfluenciasPassadas == true && conteio_registro_afluencias_passadas < 11 + revisao) {//11 + revisao : significam 11 valores de afluência mensal e um número de afluências semanais igual a revisao. A última linha é repetida nos arquivos e nesta leitura é desconsiderada

					//Notas:
					//O dia inicial dos periodos semanais criados somente é importante para o acoplamento entre periodos. No nosso caso, o primeiro Periodo semanal começa no dia 1 do primeiro mês da tendência
					//O valor mensal ou semanal médio vai ser obtido por meio de um getElementos(IdMes), por isso, o dia não é relevante para determinar o periodo semanal

					const IdHidreletrica idHidreletrica_MaiorId = a_dados.getMaiorId(IdHidreletrica());

					if (conteio_registro_afluencias_passadas < 11) {//Registros de afluências passadas MENSAIS

						///////////////////////////////////
						//Inicializa valor_afluencia_passadas
						///////////////////////////////////

						if (conteio_registro_afluencias_passadas == 0) {

							for (int posto = 0; posto < numPostos; posto++)
								valor_afluencia_passadas_DECOMP.addElemento(posto, posto);

						}//if (conteio_registro_afluencias_passadas == 0) {

						///////////////////////////////////
						//Identifica mes e ano
						///////////////////////////////////

						int mes_afluencia_historica = mesInicial_PMO;
						int ano_afluencia_historica = anoInicial_PMO;

						const int conteio_meses_anteriores = 11 - conteio_registro_afluencias_passadas;

						for (int conteio = 0; conteio < conteio_meses_anteriores; conteio++) {

							mes_afluencia_historica--;

							if (mes_afluencia_historica == 0) {

								mes_afluencia_historica = 12;
								ano_afluencia_historica--;

							}//if (mes_afluencia_historica < 0) {

						}//for (int conteio = 0; conteio < conteio_meses_anteriores; conteio++) {

						/////////////////////////////////////////////////
						//Guarda a informação mensal em periodos semanais
						/////////////////////////////////////////////////

						if (conteio_meses_anteriores == 1) {

							//No mês anterior ao mês inicial do PMO deve encontrar o Tipo_Periodo dependendo dos dias
							//da primeira semana (RV0) do PMO dentro do mês anterior

							////////////////////////////////////////////////////////////////////////
							//1. Determina o dia da primeira semana operativa do PMO no mês anterior 
							////////////////////////////////////////////////////////////////////////

							IdDia idDia = data_execucao.getDia();
							IdMes idMes = data_execucao.getMes();
							IdAno idAno = data_execucao.getAno();

							IdDia maiordiadomes = data_execucao.getMaiorDiaDoMes(idMes);

							//O periodo começa no dia seguinte da data de execução
							idDia++;

							if (idDia > maiordiadomes) {
								idDia = IdDia_1;
								idMes++;
								if (idMes == IdMes_Excedente) {
									idMes = IdMes_1;
									idAno++;
								}//if (idMes == IdMes_Excedente) {

							}//if(idDia == maiordiadomes) {

							//Cria periodo semanal logo do dia_execução

							const Periodo periodo_diario(idDia, idMes, idAno);

							Periodo periodo_semanal(TipoPeriodo_semanal, periodo_diario);

							const Periodo periodo_diario_limite(1, mesInicial_PMO, anoInicial_PMO); //Corresponde ao primeiro dia do mês do PMO

							while (periodo_semanal > periodo_diario_limite)
								periodo_semanal--;

							periodo_semana_PMO = periodo_semanal;

							///////////////////////////////////////////////////////////////////////////////////////
							//2. Realiza conteio do número de dias do mês anterior até o periodo_semana_PMO do passo 1.
							///////////////////////////////////////////////////////////////////////////////////////

							Periodo periodo_diario_mes_anterior(1, mes_afluencia_historica, ano_afluencia_historica);

							int conteioDias = 0;

							while (periodo_diario_mes_anterior < periodo_semana_PMO) {

								conteioDias++;
								periodo_diario_mes_anterior++;

							}//while (periodo_diario_mes_anterior < periodo_semana_PMO) {

							std::string string_periodo = getString(1) + "/" + getString(mes_afluencia_historica) + "/" + getString(ano_afluencia_historica) + "-" + getString(conteioDias) + "dias";;

							const Periodo periodo_mensal(string_periodo);

							for (int posto = 0; posto < numPostos; posto++) {

								const int afluencia = intLeitura[posto];

								//Adiciona o valor de afluencia na matriz da classe Afluencia
								valor_afluencia_passadas_DECOMP.at(posto).addElemento(periodo_mensal, afluencia);

							}//for (int posto = 0; posto < numPostos; posto++) {

						}//if (conteio_meses_anteriores == 1) {
						else {

							const Periodo periodo_mensal(mes_afluencia_historica, ano_afluencia_historica);

							for (int posto = 0; posto < numPostos; posto++) {

								const int afluencia = intLeitura[posto];

								//Adiciona o valor de afluencia na matriz da classe Afluencia
								valor_afluencia_passadas_DECOMP.at(posto).addElemento(periodo_mensal, afluencia);

							}//for (int posto = 0; posto < numPostos; posto++) {

						}//else {

					}//if (conteio_registro_afluencias_passadas < 11) {
					else {//Registros de afluências passadas SEMANAIS

						//periodo_semana_PMO: A primeira semana PMO é calculada no último mês registrado no registroAfluenciasPassadas

						/////////////////////////////////////////////////
						//Guarda a informação semanal
						/////////////////////////////////////////////////

						for (int posto = 0; posto < numPostos; posto++) {

							const int afluencia = intLeitura[posto];

							//Adiciona o valor de afluencia na matriz da classe Afluencia
							valor_afluencia_passadas_DECOMP.at(posto).addElemento(periodo_semana_PMO, afluencia);

						}//for (int posto = 0; posto < numPostos; posto++) {

						/////////////////////////////////////////////////
						//Aumenta o dia para o próximo periodo semanal
						/////////////////////////////////////////////////

						periodo_semana_PMO++;

					}//else {

					conteio_registro_afluencias_passadas++;

				}//else if (registroAfluenciasPassadas == true && conteio_registro_afluencias_passadas < 11 + revisao) {
				else if (conteio_registro_vazoes >= numNos && registroAfluenciasPassadas == false) {// Descarta a informação das vazões para o acoplamento com o Newave

					conteio_registro_vazoes++;

					if (conteio_registro_vazoes == 2 * numNos)
						registroAfluenciasPassadas = true;

				}//else if (conteio_registro_vazoes >= numNos) {
				else if (registro >= 4 && registroProbabilidade == false && conteio_registro_vazoes < numNos) {

					conteio_registro_vazoes++;

				}//else if (registro >= 4 && registroProbabilidade == false) {


			}//while (!(leituraArquivo.eof())) {

			leituraArquivo.clear();
			leituraArquivo.close();


		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::ler_afluencia_passada_from_VAZOES_201906_DC29: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::ler_historico_afluencia_from_VAZOES_201906_DC29(Dados& a_dados, std::string nomeArquivo){

	try {

		int intLeitura_320[320];
		int intLeitura_600[600];

		///////////////////////////////////////////////////////////////////
		std::ifstream leituraArquivo;
		leituraArquivo.open(nomeArquivo, std::ios_base::in | std::ios::binary);

		if (leituraArquivo.is_open()) {

			const int tamanho_registro_arquivo_vazoes_historicas = 320;

			const int numero_postos = valor_afluencia_passadas_GEVAZP.size();

			valor_afluencia_historica = SmartEnupla<int, SmartEnupla<Periodo, double>>(0, std::vector<SmartEnupla<Periodo, double>>(numero_postos, SmartEnupla<Periodo, double>()));

			int mes = 1;
			int ano = 1931; //Primeiro ano do histórico

			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			while (!(leituraArquivo.eof())) {

				Periodo periodo(mes, ano);

				if (periodo > horizonte_estudo.getIteradorInicial())
					break;

				mes++;

				if (mes > 12) {
					mes = 1;
					ano++;
				}//if (mes > 12) {

				if (tamanho_registro_arquivo_vazoes_historicas == 320)
					leituraArquivo.read((char*)intLeitura_320, sizeof(intLeitura_320));
				else if (tamanho_registro_arquivo_vazoes_historicas == 600)
					leituraArquivo.read((char*)intLeitura_600, sizeof(intLeitura_600));
				else
					throw std::invalid_argument("tamanho do registro de vazoes ivalido " + getFullString(tamanho_registro_arquivo_vazoes_historicas) + ".");

				for (int posto = 0; posto < numero_postos; posto++){

					double afluencia_historico = 0.0;

					if (tamanho_registro_arquivo_vazoes_historicas == 320)
						afluencia_historico = double(intLeitura_320[posto]);
					else if (tamanho_registro_arquivo_vazoes_historicas == 600)
						afluencia_historico = double(intLeitura_600[posto]);

					valor_afluencia_historica.at(posto).addElemento(periodo, afluencia_historico);

				}// for (int posto = 0; posto < numero_postos; posto++){

			}//while (!(leituraArquivo.eof())) {

			//fp_out.close();

			leituraArquivo.clear();
			leituraArquivo.close();

		}//if (leituraArquivo.is_open()) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::ler_historico_afluencia_from_VAZOES_201906_DC29: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::definir_horizonte_otimizacao_DC_from_VAZOES_201906_DC29(Dados& a_dados, std::string nomeArquivo) {

	try {

		const int tamanho = 320;
		int intLeitura[tamanho];

		int registro = 0;

		///////////////////////////////////////////////////////////////////
		std::ifstream leituraArquivo;
		leituraArquivo.open(nomeArquivo, std::ios_base::in | std::ios::binary);

		if (leituraArquivo.is_open()) {

			while (true) {

				registro++;

				leituraArquivo.read((char*)intLeitura, sizeof(intLeitura));

				if (registro == 3) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registro 3 - número de semanas completas, número de dias que devem ser excluídos do estágio seguinte 
					//             ao mês inicial decomposto em semanas, índice do mês inicial do estudo  e ano do mês inicial do estudo
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					const int numSemanasEstudo = intLeitura[0];
					const int diasNoSeguinteMes = intLeitura[1];
					const int mesInicial_PMO = intLeitura[2];
					const int anoInicial_PMO = intLeitura[3];

					int mesAnterior;
					int anoAnterior;

					mesAnterior = mesInicial_PMO - 1;

					if (mesAnterior < 1) {
						mesAnterior = 12;
						anoAnterior = anoInicial_PMO - 1;
					}//if (mesAnterior > 1) {
					else
						anoAnterior = anoInicial_PMO;

					Periodo periodo(mesInicial_PMO, anoInicial_PMO);
					Periodo periodoAnterior(mesAnterior, anoAnterior);

					IdMes idMes = getIdMesFromInt(mesInicial_PMO);
					IdAno idAno = getIdAnoFromChar(std::to_string(anoInicial_PMO).c_str());
					IdDia idDia = periodo.getMaiorDiaDoMes(idMes);

					IdMes idMesAnterior = getIdMesFromInt(mesAnterior);

					int diasDesconto;

					for (int semana = 0; semana < numSemanasEstudo; semana++) {

						if (semana == 0)
							diasDesconto = 7 - diasNoSeguinteMes;
						else
							diasDesconto = 7;

						for (int dia = 0; dia < diasDesconto; dia++) {

							if (idDia == IdDia_1) {

								idDia = periodo.getMaiorDiaDoMes(idMesAnterior);

								if (idMes == IdMes_1) {

									idMes = IdMes_12;
									idAno--;
								}//if (idMes == IdMes_1) {
								else
									idMes--;

							}//if (idDia == IdDia_1) {
							else
								idDia--;

						}//for (int dia = 0; dia < diasDesconto; dia++) {

					}//for (int semana = 0; semana < numSemanasEstudo; semana++) {

					//Set Data execução
					Periodo data_execucao_auxiliar(idDia, idMes, idAno);

					data_execucao = data_execucao_auxiliar;

					IdDiaSemana diaSemana = data_execucao.getDiaSemana();

					//if (diaSemana != IdDiaSemana_SEX)
						//throw std::invalid_argument("Data de execucao diferente a uma sexta-feira");

					//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Determina o vetor horizonte_otimizacao_DC (somente serve para a mapear na leitura de dados a data para o horizonte_estudo do SPT
					//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					std::string string_periodo;
					IdDia maiordiadomes;
					maiordiadomes = data_execucao.getMaiorDiaDoMes(idMes);

					IdEstagio idEstagio = IdEstagio_1;

					//O periodo começa no dia seguinte da data de execução
					idDia++;

					if (idDia > maiordiadomes) {
						idDia = IdDia_1;
						idMes++;
						if (idMes == IdMes_Excedente) {
							idMes = IdMes_1;
							idAno++;
						}//if (idMes == IdMes_Excedente) {

						maiordiadomes = data_execucao.getMaiorDiaDoMes(idMes);
					}//if(idDia == maiordiadomes) {

					//Estabelece todos os periodos do horizonte de planejamento

					//Periodos semanais do DECOMP

					for (int semana = 0; semana < numSemanasEstudo; semana++) {

						string_periodo = getString(idDia) + "/" + getString(idMes) + "/" + getString(idAno) + "-semanal";

						for (int dia = 0; dia < 7; dia++) {
							idDia++;

							if (idDia > maiordiadomes) {
								idDia = IdDia_1;
								idMes++;
								if (idMes == IdMes_Excedente) {
									idMes = IdMes_1;
									idAno++;
								}//if (idMes == IdMes_Excedente) {

								maiordiadomes = Periodo(idMes, idAno).getMaiorDiaDoMes();
							}//if(idDia == maiordiadomes) {
						}//for (int dia = 0; dia < 7; dia++) {

						Periodo periodoSemanal(string_periodo);
						horizonte_otimizacao_DC.addElemento(periodoSemanal);

						idEstagio++;

					}//for (int semana = 0; semana < numSemanasEstudo; semana++) {

					//Periodo "mensal" do DECOMP

					string_periodo = getString(idDia) + "/" + getString(idMes) + "/" + getString(idAno);

					int conteioDias = 1; //O primeiro dia conta na formação do periodo
					while (true) {

						if (idDia == maiordiadomes)
							break;

						idDia++;
						conteioDias++;

					}//while (true) {

					if (conteioDias == int(maiordiadomes))
						string_periodo += "-mensal";
					else if (conteioDias < int(maiordiadomes))
						string_periodo += "-" + getString(conteioDias) + "dias";

					const Periodo periodoMensal(string_periodo);

					horizonte_otimizacao_DC.addElemento(periodoMensal);

					break;

				}//else if (registro == 3) {

			}//while (true) {

			leituraArquivo.clear();
			leituraArquivo.close();

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::definir_horizonte_otimizacao_DC_from_VAZOES_201906_DC29: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::instanciar_hidreletricas_from_VAZOES_201906_DC29(Dados& a_dados, std::string nomeArquivo) {

	try {

		//********************************************************************************************************************************

		const int tamanho = 320;
		int intLeitura[tamanho];

		int registro = 0;

		int numUHE;

		///////////////////////////////////////////////////////////////////
		std::ifstream leituraArquivo;
		leituraArquivo.open(nomeArquivo, std::ios_base::in | std::ios::binary);

		if (leituraArquivo.is_open()) {

			while (true) {

				registro++;

				///////////////////////////////////////
				//Identifica o tipo do registro
				///////////////////////////////////////

				leituraArquivo.read((char*)intLeitura, sizeof(intLeitura));

				if (registro == 1) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registro 1 -  total de postos considerados , número de estágios considerados  e número de aberturas em cada estágio
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					numUHE = intLeitura[0]; // Total de postos considerados

				}//if (registro == 1) {
				else if (registro == 2) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Registro 2 -  código das usinas hidráulicas associadas aos postos de vazões considerados
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					//Inicializa as hidrelétricas desde o decomp

					for (int h = 0; h < numUHE; h++) {

						const int codigo_usina = intLeitura[h];

						//Identifica se alguma hidrelétrica tem sido inicializada com codigo_usina
						const IdHidreletrica idHidreletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

						if (idHidreletrica_inicializado == IdHidreletrica_Nenhum) {

							Hidreletrica   hidreletrica;
							const IdHidreletrica idHidreletrica = IdHidreletrica(codigo_usina);

							//Set idHidreletrica
							hidreletrica.setAtributo(AttComumHidreletrica_idHidreletrica, idHidreletrica);
							hidreletrica.setAtributo(AttComumHidreletrica_codigo_usina, codigo_usina);
							hidreletrica.setAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica_por_usina);
							//Set codigo_usina
							lista_codigo_ONS_hidreletrica.setElemento(idHidreletrica, codigo_usina);

							a_dados.vetorHidreletrica.add(hidreletrica);

						}//if (idHidreletrica_inicializado == IdHidreletrica_Nenhum) {

					}//for (int h = 0; h < numUHE; h++) {

					break;

				}//else if (registro == 2) {

			}//while (true) {

			leituraArquivo.clear();
			leituraArquivo.close();

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::instanciar_hidreletricas_from_VAZOES_201906_DC29: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::instanciar_processo_estocastico_CP(Dados& a_dados) {

	try {

		a_dados.processoEstocastico_hidrologico = ProcessoEstocastico();
		a_dados.processoEstocastico_hidrologico.setAtributo(AttComumProcessoEstocastico_idProcessoEstocastico, IdProcessoEstocastico_hidrologico_hidreletrica);
		a_dados.processoEstocastico_hidrologico.setAtributo(AttComumProcessoEstocastico_tipo_espaco_amostral, TipoEspacoAmostral_arvore_cenarios);
		a_dados.processoEstocastico_hidrologico.setAtributo(AttComumProcessoEstocastico_tipo_correlacao_variaveis_aleatorias, TipoCorrelacaoVariaveisAleatorias_sem_correlacao);
		
		if (!dadosPreConfig_instanciados)
			a_dados.setAtributo(AttComumDados_tipo_espaco_amostral_geracao_cenario_hidrologico, TipoEspacoAmostral_arvore_cenarios);



	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::instanciar_processo_estocastico_CP: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_DADGER_201906_DC29(Dados& a_dados, std::string nomeArquivo)
{

	try {

		std::ifstream leituraArquivo(nomeArquivo);
		std::ifstream leituraArquivo_aux(nomeArquivo);
		std::string line;

		std::string atributo;

		//Horizonte de estudo
		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		//Parâmetros para registros BE (Bacias especiais) e PQ (pequenas usinas)
		SmartEnupla<IdSubmercado, SmartEnupla<IdUsinaNaoSimulada, SmartEnupla <Periodo, int>>> conteio_numero_usina_nao_simulado_por_submercado;

		SmartEnupla<IdHidreletrica, SmartEnupla <Periodo, double>> desvio_registro_DA(a_dados.getMenorId(IdHidreletrica()), std::vector<SmartEnupla<Periodo, double>>(int(a_dados.getMaiorId(IdHidreletrica()) - a_dados.getMenorId(IdHidreletrica())) + 1, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0)));

		//Se todos os registros SB (submercados) e DP (carga subsistemas) são lidos, é ativado um método para a inicialização dos submercados IVAPORÃ e ANDE
		bool leitura_registro_SB = false;
		bool leitura_registro_DP = false;
		bool leitura_registro_CD = false;

		if (leituraArquivo.is_open()) {

			/////////////////////////////////////////////////
			//1.Instancia percentual_duracao_patamar_carga
			/////////////////////////////////////////////////

			if (true) {

				bool is_carregar_percentual_duaracao_patamar_carga = false;

				if (a_dados.getSizeMatriz(AttMatrizDados_percentual_duracao_patamar_carga) == 0) //Pode ter sido instanciada na pre-config e não deve ser recarregada
					is_carregar_percentual_duaracao_patamar_carga = true;


				bool is_registro_DP_encontrado = false;

				while (std::getline(leituraArquivo_aux, line)) {

					strNormalizada(line);

					std::string teste_comentario = line.substr(0, 1);

					if (teste_comentario != "&") {

						std::string menemonico = line.substr(0, 2);

						if (is_registro_DP_encontrado && menemonico != "DP")//Teste para ler só o bloco DP
							break;

						if (menemonico == "DP") {//Carga dos subsistemas					

							try {

								is_registro_DP_encontrado = true;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 2 -  Número de identificação do estágio (em ordem crescente, máximo igual a 24).
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								atributo = line.substr(4, 2);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const IdEstagio idEstagio_demanda = getIdEstagioFromChar(atributo.c_str());

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 3 -  Índice do subsistema .
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								atributo = line.substr(9, 2);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const int codigo_subsistema = atoi(atributo.c_str());

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Filosofia: Verifica o tamanho da linha se existem dados de demanda e duração para determinar um novo patamar de carga
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								int numero_patamares = 0;

								double valor;

								std::vector<double> demanda_patamar;
								std::vector<double> duracao_horas_patamar;

								const int line_size = int(line.length());

								if (line_size >= 39) {

									numero_patamares++;

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 4 - Carga do patamar 1,em MWmed. 
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									atributo = line.substr(19, 10);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									if (atributo == "")
										valor = 0;
									else
										valor = atof(atributo.c_str());

									demanda_patamar.push_back(valor);

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 5 - Duração do patamar 1, em horas.  
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									atributo = line.substr(29, 10);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									duracao_horas_patamar.push_back(atof(atributo.c_str()));

								}//if (line_size >= 39) {

								if (line_size >= 59) {

									numero_patamares++;

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 6 - Carga do patamar 2,em MWmed. 
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									atributo = line.substr(39, 10);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									if (atributo == "")
										valor = 0;
									else
										valor = atof(atributo.c_str());

									demanda_patamar.push_back(valor);

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 7 - Duração do patamar 2, em horas.  
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									atributo = line.substr(49, 10);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									duracao_horas_patamar.push_back(atof(atributo.c_str()));

								}//if (line_size >= 59) {

								if (line_size >= 79) {

									numero_patamares++;

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 8 - Carga do patamar 3,em MWmed. 
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									atributo = line.substr(59, 10);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									if (atributo == "")
										valor = 0;
									else
										valor = atof(atributo.c_str());

									demanda_patamar.push_back(valor);

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 9 - Duração do patamar 3, em horas.  
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									atributo = line.substr(69, 10);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									duracao_horas_patamar.push_back(atof(atributo.c_str()));

								}//if (line_size >= 79) {

								if (line_size >= 99) {

									numero_patamares++;

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 10 - Carga do patamar 4,em MWmed. 
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									atributo = line.substr(79, 10);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									if (atributo == "")
										valor = 0;
									else
										valor = atof(atributo.c_str());

									demanda_patamar.push_back(valor);

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 11 - Duração do patamar 4, em horas.  
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									atributo = line.substr(89, 10);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									duracao_horas_patamar.push_back(atof(atributo.c_str()));

								}//if (line_size >= 99) {

								if (line_size >= 119) {

									numero_patamares++;

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 10 - Carga do patamar 5,em MWmed. 
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									atributo = line.substr(99, 10);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									if (atributo == "")
										valor = 0;
									else
										valor = atof(atributo.c_str());

									demanda_patamar.push_back(valor);

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 11 - Duração do patamar 5, em horas.  
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									atributo = line.substr(109, 10);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									duracao_horas_patamar.push_back(atof(atributo.c_str()));

								}//if (line_size >= 119) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Guarda informação nos Smart Elementos
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								if (is_carregar_percentual_duaracao_patamar_carga && a_dados.getSizeMatriz(AttMatrizDados_percentual_duracao_patamar_carga) == 0)
									a_dados.setMatriz(AttMatrizDados_percentual_duracao_patamar_carga, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(IdPatamarCarga(numero_patamares), 0.0))));

								///////////////////////////////////////////////////////////////////////////
								//Atualiza informação de cada estágio 
								///////////////////////////////////////////////////////////////////////////	

								const int size_duracao_horas_patamar = int(duracao_horas_patamar.size());

								std::vector<double> percentual_duracao_patamar;

								double horasTotais = 0;

								for (int pos = 0; pos < size_duracao_horas_patamar; pos++)
									horasTotais += duracao_horas_patamar.at(pos);

								for (int pos = 0; pos < size_duracao_horas_patamar; pos++)
									percentual_duracao_patamar.push_back(duracao_horas_patamar.at(pos) * std::pow(horasTotais, -1));

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									//Atualiza a informação unicamente para o estágio DC indicado

									if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_demanda) {

										//Se é último estágio DC, o periodo deve ser maior ou igual ao estágio DC

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_demanda)) {

											for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= getIdPatamarCargaFromChar(getString(numero_patamares).c_str()); idPatamarCarga++) {

												if(is_carregar_percentual_duaracao_patamar_carga)
													a_dados.setElemento(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, percentual_duracao_patamar.at(getintFromChar(getString(idPatamarCarga).c_str()) - 1));

												
											}

											if(codigo_subsistema == 1)
												percentual_duracao_patamar_carga_original.addElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, percentual_duracao_patamar));

										}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_demanda)) {

									}//if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_demanda) {
									else {

										//Se não é último estágio DC, o periodo deve ser entre dois estágios DC consecutivos

										const IdEstagio idEstagio_demanda_seguinte = IdEstagio(idEstagio_demanda + 1);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_demanda) && periodo < horizonte_otimizacao_DC.at(idEstagio_demanda_seguinte)) {

											for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= getIdPatamarCargaFromChar(getString(numero_patamares).c_str()); idPatamarCarga++) {
												if (is_carregar_percentual_duaracao_patamar_carga)
													a_dados.setElemento(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, percentual_duracao_patamar.at(getintFromChar(getString(idPatamarCarga).c_str()) - 1));

											}

											if (codigo_subsistema == 1)
												percentual_duracao_patamar_carga_original.addElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, percentual_duracao_patamar));

										}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_demanda) && periodo < horizonte_otimizacao_DC.at(idEstagio_demanda_seguinte)) {

										else if (periodo >= horizonte_otimizacao_DC.at(idEstagio_demanda_seguinte))
											break; //Evita percorrer todo o horizonte_estudo

									}//else {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {					

							}//try {
							catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro DP: \n" + std::string(erro.what())); }

						}//if (menemonico == "DP") {

					}//if (teste_comentario != "&") {

				}//while (std::getline(leituraArquivo, line)) {

				leituraArquivo_aux.clear();
				leituraArquivo_aux.close();

			}//if (true) {

			/////////////////////////////////////////////////
			//2.Leitura completa
			/////////////////////////////////////////////////

			while (std::getline(leituraArquivo, line)) {

				strNormalizada(line);

				std::string teste_comentario = line.substr(0, 1);

				if (teste_comentario != "&") {

					std::string menemonico = line.substr(0, 2);

					if (menemonico == "TE") {

						try {
							//Título do estudo
							atributo = line.substr(4, 80);
							if (!dadosPreConfig_instanciados)
								a_dados.setAtributo(AttComumDados_nome_estudo, atributo);
						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro TE: \n" + std::string(erro.what())); }

					}//if(menemonico == "TE"){
					if (menemonico == "PT") {

						try {

							//Patamares de carga

							atributo = line.substr(5, 3);
							const IdEstagio idEstagio = getIdEstagioFromChar(atributo.c_str());

							atributo = line.substr(11, 2);
							const int valor = std::atoi(atributo.c_str());

							/*
							if (idEstagio == IdEstagio_1) {

								const SmartEnupla<Periodo, int> numero_patamares_por_periodo(horizonte_estudo, valor);

								a_dados.setVetor(AttVetorDados_numero_patamares_por_periodo, numero_patamares_por_periodo);

							}//if (idEstagio_inicial == IdEstagio_1) {
							else {

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									if (periodo >= horizonte_otimizacao_DC.at(idEstagio))
										a_dados.setElemento(AttVetorDados_numero_patamares_por_periodo, periodo, valor);

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//else {
							*/

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro PT: \n" + std::string(erro.what())); }

					}//if(menemonico == "PT"){

					if (menemonico == "FP") {
						const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
						const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());
						if (std::stoi(line.substr(4, 3)) == 999) {
							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {
									if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.isInstanciado(IdFuncaoProducaoHidreletrica_1) == false) {
										FuncaoProducaoHidreletrica Fph;
										Fph.setAtributo(AttComumFuncaoProducaoHidreletrica_idFuncaoProducaoHidreletrica, IdFuncaoProducaoHidreletrica_1);
										a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.add(Fph);
									}
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setVetor(AttVetorFuncaoProducaoHidreletrica_percentual_volume_minimo, SmartEnupla<Periodo, double>(horizonte_estudo, double(std::stod(line.substr(41, 5)))));
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setVetor(AttVetorFuncaoProducaoHidreletrica_percentual_volume_maximo, SmartEnupla<Periodo, double>(horizonte_estudo, double(std::stod(line.substr(47, 5)))));
								}
							}
						}
					}//else if (menemonico == "FP") {

					if (menemonico == "SB") {

						try {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Índice do subsistema  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_submercado = std::atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Mnemônico de identificação para o subsistema.   
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string mnemonico = atributo;

							//*******************************************************************************************************************
							//Set infromação na classe Submercado
							//*******************************************************************************************************************

							//Testa se algum subsistema foi inicializado com o id_Cepel		

							const IdSubmercado idSubmercado_inicializado = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_submercado);

							if (idSubmercado_inicializado == IdSubmercado_Nenhum) {

								const IdSubmercado idSubmercado = getIdSubmercadoFromMnemonico(mnemonico);

								Submercado submercado;

								submercado.setAtributo(AttComumSubmercado_idSubmercado, idSubmercado);
								submercado.setAtributo(AttComumSubmercado_nome, mnemonico);

								lista_codigo_ONS_submercado.setElemento(idSubmercado, codigo_submercado);

								lista_submercado_mnemonico.setElemento(idSubmercado, mnemonico);

								//Adiciona um novo submercado no vetorSubmercado
								a_dados.vetorSubmercado.add(submercado);

							} // if (idSubmercado_inicializado == IdSubmercado_Nenhum) {

							else if (idSubmercado_inicializado != IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado ja instanciado, mnemonico: " + mnemonico);

							leitura_registro_SB = true;

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro SB: \n" + std::string(erro.what())); }

					}//if (menemonico == "SB") {

					if (menemonico == "UH") {

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina hidráulica  conforme registro 303 do arquivo de vazões 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//codigo_usina
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Índice do reservatório equivalente de energia (REE) ao qual pertence a usina
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//codigo_REE_CEPEL
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							int codigo_REE_CEPEL = 0; //default

							if (atributo != "")
								codigo_REE_CEPEL = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Volume armazenado inicial em percentagem do  volume útil (default = 0.0 %). 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							double percentual_volume_inicial = 0.0; //default

							if (atributo != "")
								percentual_volume_inicial = atof(atributo.c_str()) / 100;

							//******************************************************************************************************************
							//Nota: Até o campo 4 é obrigatório no DECK ter um valor assignado, portanto, a partir deste ponto é necessário 
							//      verificar o tamanho do número de caracteres da string line
							//******************************************************************************************************************

							const int line_size = int(line.length());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Vazão defluente mínima , em m3/s. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							double vazao_defluente_minima;

							if (line_size >= 34) {

								//vazao_defluente_minima
								atributo = line.substr(24, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								vazao_defluente_minima = 0.0; //default

								if (atributo != "")
									vazao_defluente_minima = atof(atributo.c_str());


							}//if (line_size >= 34) {
							else {
								//Set valor default
								vazao_defluente_minima = 0.0; //default
							}//else {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 6 -  Chave para considerar  evaporação: = 0 - não considera (default).  = 1 – considera. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							bool considera_evaporacao;

							if (line_size >= 40) {
								atributo = line.substr(39, 1);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								considera_evaporacao = false; //default

								if (atributo != "") {

									if (atoi(atributo.c_str()) == 1)
										considera_evaporacao = true;

								}//if (atributo != "") {

							}//if (line_size >= 40) {
							else {
								//Set valor default
								considera_evaporacao = false; //default
							}//else {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 7 - Identificação do estágio (inclusive) a partir do qual a usina passa a produzir energia elétrica (default = 1)
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							IdEstagio idEstagio_entrada_operacao;

							if (line_size >= 46) {
								atributo = line.substr(44, 2);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								idEstagio_entrada_operacao = IdEstagio_1; //default

								if (atributo != "")
									idEstagio_entrada_operacao = getIdEstagioFromChar(atributo.c_str());

							}//if (line_size >= 40) {
							else {
								//Set valor default
								idEstagio_entrada_operacao = IdEstagio_1; //default
							}//else {

							//////////////////////////////////////
							//Determina o periodo_entrada_operacao
							//////////////////////////////////////

							Periodo periodo_entrada_operacao;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_entrada_operacao)) {

									periodo_entrada_operacao = periodo;
									break;

								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_entrada_operacao)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 8 - Volume morto inicial em hm3, (default = 0.0). Caso este valor seja fornecido o campo 4 será desconsiderado
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							double volume_morto;

							if (line_size >= 59) {
								atributo = line.substr(49, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								volume_morto = 0.0; //default

								if (atributo != "") {

									volume_morto = atof(atributo.c_str());

									//Caso este valor seja fornecido o campo 4 (Volume armazenado inicial) será desconsiderado
									percentual_volume_inicial = 0.0; //default

								}//if (atributo != "") {

							}//if (line_size >= 59) {
							else {
								//Set valor default
								volume_morto = 0.0; //default
							}//else {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 9 - Limite superior para vertimento, em  m3/s (default = 1.0e+21). 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							double vertimento_maximo;

							if (line_size >= 69) {
								atributo = line.substr(59, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								vertimento_maximo = 1e21; //default

								if (atributo != "")
									vertimento_maximo = atof(atributo.c_str());

							}//if (line_size >= 69) {
							else {
								//Set valor default
								vertimento_maximo = 1e21; //default
							}//else {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 10 - Chave para comsiderar o balanço hídrico em cada patamar, para usinas a fio d’água  
							//            = 0 - não considera (default).  = 1 – considera. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							//A informação do campo 10 não é relevante já que o SPT tem sua própia lógica para considerar o balanço hídrico para as usinas fio d'água


							//*******************************************************************************************************************
							//Set infromação na classe Hidreletrica
							//*******************************************************************************************************************

							//Neste ponto as hidrelétricas já estão inicializadas pela preconfiguração ou na leitura do VAZOES.DAT

							//Identifica se alguma hidrelétrica tem sido inicializada com codigo_ONS
							const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							if (idHidreletrica == IdHidreletrica_Nenhum)
								throw std::invalid_argument("Resgistro UH - hidreletrica nao instanciada com codigo_usina_" + getString(codigo_usina));

							//const IdBaciaHidrografica idBaciaHidrografica = a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_bacia, IdBaciaHidrografica());

							if (maior_ONS_REE < codigo_REE_CEPEL)
								maior_ONS_REE = codigo_REE_CEPEL;

							///////////////////////
							a_dados.volume_inicial_carregado_from_premissa = true;
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setAtributo(AttComumReservatorio_percentual_volume_util_inicial, percentual_volume_inicial);
							a_dados.vetorHidreletrica.at(idHidreletrica).setVetor(AttVetorHidreletrica_vazao_defluente_minima, SmartEnupla<Periodo, double>(horizonte_estudo, vazao_defluente_minima)); //Tem que inicializar o vetor porque o registro "DF" (registro taxa de defluencia) informa os valores por periodo
							//a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setAtributo(AttComumReservatorio_considera_evaporacao, considera_evaporacao);
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setAtributo(AttComumReservatorio_volume_morto, volume_morto);
							a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_vertimento_maximo, vertimento_maximo);

							a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_bacia, atribui_bacia_hidrografica(a_dados, codigo_usina));

							//lista_codigo_ONS_REE.setElemento(idHidreletrica, codigo_REE_CEPEL); //Precisa para setar a defluencia_disponivel_minima
							a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_codigo_REE, codigo_REE_CEPEL);


							//Determina se a usina está em operação

							if (idEstagio_entrada_operacao != IdEstagio_1) {

								SmartEnupla<IdHidreletrica, Periodo> lista_hidreletrica_periodo(1);

								lista_hidreletrica_periodo.addElemento(idHidreletrica, periodo_entrada_operacao);

								int iterador = int(matriz_hidreletrica_periodo_entrada_em_operacao.size());
								iterador++;

								matriz_hidreletrica_periodo_entrada_em_operacao.addElemento(iterador, lista_hidreletrica_periodo);

							}//if (idEstagio_entrada_operacao != IdEstagio_1) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro UH: \n" + std::string(erro.what())); }

					}//if (menemonico == "UH") {
					
					if (menemonico == "CT") {//Usinas térmicas

						try {


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina térmica
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//codigo_usina
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -   Índice do subsistema ao qual pertence a usina. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							//Identifica se alguma termelétrica tem sido inicializada com codigo_usina

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, atoi(atributo.c_str()));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -   Nome da usina térmica. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(14, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string nome = atributo;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -   Índice do estágio. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(24, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_termeletrica = getIdEstagioFromChar(atributo.c_str());

							//******************************************************************************************************************
							//Nota: Até o campo 5 estamos considerando obrigatório no DECK ter um valor assignado, portanto, a partir deste ponto é necessário 
							//      verificar o tamanho do número de caracteres da string line
							//******************************************************************************************************************

							const int line_size = int(line.length());

							int numero_patamares = 0;

							//Vetores com informação por patamar
							std::vector<double> potencia_minima;
							std::vector<double> potencia_maxima;
							std::vector<double> custo_operacao;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campos 6 - 7 - 8  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (line_size >= 49) {//Por cada patamar são feito 3 registros: potencia_minima, potencia_maxima, custo_operacao

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 6 - Geração mínima fixa da usina,em MWmed, no patamar 1.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(29, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								potencia_minima.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 7 - Capacidade de geração da usina,em MWmed, no patamar 1. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(34, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								potencia_maxima.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 8 - Custo de geração da usina térmica, em $/MWh, no patamar 1. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(39, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								custo_operacao.push_back(atof(atributo.c_str()));

							}//if (line_size >= 49) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campos 9 - 10 - 11  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (line_size >= 69) {//Por cada patamar são feito 3 registros: potencia_minima, potencia_maxima, custo_operacao

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 9 - Geração mínima fixa da usina,em MWmed, no patamar 2.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(49, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								potencia_minima.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 10 - Capacidade de geração da usina,em MWmed, no patamar 2. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(54, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								potencia_maxima.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 11 - Custo de geração da usina térmica, em $/MWh, no patamar 2. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(59, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								custo_operacao.push_back(atof(atributo.c_str()));

							}//if (line_size >= 69) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campos 12 - 13 - 14  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (line_size >= 89) {//Por cada patamar são feito 3 registros: potencia_minima, potencia_maxima, custo_operacao

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 12 - Geração mínima fixa da usina,em MWmed, no patamar 3.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(69, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								potencia_minima.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 13 - Capacidade de geração da usina,em MWmed, no patamar 3. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(74, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								potencia_maxima.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 14 - Custo de geração da usina térmica, em $/MWh, no patamar 3. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(79, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								custo_operacao.push_back(atof(atributo.c_str()));

							}//if (line_size >= 89) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campos 15 - 16 - 17  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (line_size >= 109) {//Por cada patamar são feito 3 registros: potencia_minima, potencia_maxima, custo_operacao

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 12 - Geração mínima fixa da usina,em MWmed, no patamar 3.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(89, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								potencia_minima.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 13 - Capacidade de geração da usina,em MWmed, no patamar 3. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(94, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								potencia_maxima.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 14 - Custo de geração da usina térmica, em $/MWh, no patamar 3. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(99, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								custo_operacao.push_back(atof(atributo.c_str()));

							}//if (line_size >= 109) {


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campos 18 - 19 - 20 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (line_size >= 129) {//Por cada patamar são feito 3 registros: potencia_minima, potencia_maxima, custo_operacao

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 12 - Geração mínima fixa da usina,em MWmed, no patamar 3.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(109, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								potencia_minima.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 13 - Capacidade de geração da usina,em MWmed, no patamar 3. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(114, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								potencia_maxima.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 14 - Custo de geração da usina térmica, em $/MWh, no patamar 3. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(119, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								custo_operacao.push_back(atof(atributo.c_str()));

							}//if (line_size >= 129) {

							/////////////////////////////////////////
							//Guarda a informação nos SmartElementos
							/////////////////////////////////////////

							//Filosofia: A informação registrada é válida para o idEstagio >= idEstagio_leitura: No primeiro estágio preenche todos 
							//           os valores dos estágios restantes e logo é sobreescrita a informação para idEstágio > 1


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Inicializa termelétrica
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (getIdFromCodigoONS(lista_codigo_ONS_termeletrica, codigo_usina) == IdTermeletrica_Nenhum) {

								Termeletrica termeletrica;

								const IdTermeletrica idTermeletrica = IdTermeletrica(codigo_usina);

								termeletrica.setAtributo(AttComumTermeletrica_idTermeletrica, idTermeletrica);

								a_dados.vetorTermeletrica.add(termeletrica);

								a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_submercado, idSubmercado);
								a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_nome, nome);
								//a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_tipo_termeletrica, TipoTermeletrica_convencional);
								a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_considerar_usina, true);
								a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoTermeletrica_por_usina);
								a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_codigo_usina, codigo_usina);

								lista_codigo_ONS_termeletrica.setElemento(idTermeletrica, codigo_usina);


								/////////////////////////////////////

								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> enupla_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									enupla_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								/////////////////////////////////////

								//Cria vetores potencia_minima, potencia_maxima, custo_de_operacao

								a_dados.vetorTermeletrica.at(idTermeletrica).setMatriz(AttMatrizTermeletrica_custo_de_operacao, enupla_zero);

								//Inicializa uma unidade termelétrica (necessário para a validação das termelétricas)

								UnidadeUTE unidadeUTE;
								unidadeUTE.setAtributo(AttComumUnidadeUTE_idUnidadeUTE, IdUnidadeUTE_1);

								unidadeUTE.setMatriz(AttMatrizUnidadeUTE_potencia_minima, enupla_zero);
								unidadeUTE.setMatriz(AttMatrizUnidadeUTE_potencia_maxima, enupla_zero);
								unidadeUTE.setMatriz(AttMatrizUnidadeUTE_potencia_util, enupla_zero);
								unidadeUTE.setMatriz(AttMatrizUnidadeUTE_custo_de_operacao, enupla_zero);

								a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.add(unidadeUTE);

							}//if (getIdFromCodigoONS(lista_codigo_ONS_termeletrica, codigo_usina) == IdTermeletrica_Nenhum) {


							//Atualiza informaçao

							const IdTermeletrica idTermeletrica = getIdFromCodigoONS(lista_codigo_ONS_termeletrica, codigo_usina);

							if (idTermeletrica == IdTermeletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idTermeletrica com codigo_usina_" + getString(codigo_usina) + " nomeUTE_" + nome);

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_termeletrica)) {

											a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.at(IdUnidadeUTE_1).setElemento(AttMatrizUnidadeUTE_potencia_minima, periodo, idPatamarCarga, potencia_minima.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.at(IdUnidadeUTE_1).setElemento(AttMatrizUnidadeUTE_potencia_maxima, periodo, idPatamarCarga, potencia_maxima.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.at(IdUnidadeUTE_1).setElemento(AttMatrizUnidadeUTE_potencia_util, periodo, idPatamarCarga, potencia_maxima.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1) - potencia_minima.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorTermeletrica.at(idTermeletrica).setElemento(AttMatrizTermeletrica_custo_de_operacao, periodo, idPatamarCarga, custo_operacao.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.at(IdUnidadeUTE_1).setElemento(AttMatrizUnidadeUTE_custo_de_operacao, periodo, idPatamarCarga, custo_operacao.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

										}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_termeletrica)) {

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro CT: \n" + std::string(erro.what())); }

					}//if (menemonico == "CT") {
					
					if (menemonico == "UE") {//Estações de bombeamento 

						try {
							IdUsinaElevatoria idUsinaElevatoria;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da estação de bombeamento. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//codigo_usina
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -   Índice do subsistema da estação de bombeamento, conforme campo 2 do registro SB.  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, atoi(atributo.c_str()));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -   Nome da estação de bombeamento.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(14, 12);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string nome = atributo;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -   Número da usina hidrelétrica a montante, conforme campo 2 do registro UH. (MONTANTE = DESTINO)
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(29, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdHidreletrica idHidreletrica_destino = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, atoi(atributo.c_str()));

							if (idHidreletrica_destino == IdHidreletrica_Nenhum)
								throw std::invalid_argument("Hidreletrica nao instanciada com codigo_usina_" + atributo);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 6 -   Número da usina hidrelétrica a jusante, conforme campo 2 do registro UH. (JUSANTE = ORIGEM)
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(34, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdHidreletrica idHidreletrica_origem = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, atoi(atributo.c_str()));

							if (idHidreletrica_origem == IdHidreletrica_Nenhum)
								throw std::invalid_argument("Hidreletrica nao instanciada com codigo_usina_" + atributo);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 7 -   Vazão mínima bombeável, (m3/s). 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(39, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double bombeamento_minimo = atof(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 8 -   Vazão máxima bombeável, (m3/s).  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(49, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double bombeamento_maximo = atof(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 9 -   Taxa de consumo (MWmed/m3/s) da estação de bombeamento.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(59, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double taxa_de_consumo = atof(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Armazena a informação nos SmartElementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							//Identifica se alguma usina elevatoria tem sido inicializada com codigo_usina

							const IdUsinaElevatoria idUsinaElevatoria_inicializado = getIdFromCodigoONS(lista_codigo_ONS_usina_elevatoria, codigo_usina);

							if (idUsinaElevatoria_inicializado == IdUsinaElevatoria_Nenhum) { //não inicializada

								UsinaElevatoria usinaElevatoria;

								idUsinaElevatoria = a_dados.getMaiorId(IdUsinaElevatoria());

								if (idUsinaElevatoria == IdUsinaElevatoria_Nenhum)
									idUsinaElevatoria = IdUsinaElevatoria_1;
								else
									idUsinaElevatoria++;

								usinaElevatoria.setAtributo(AttComumUsinaElevatoria_idUsinaElevatoria, idUsinaElevatoria);
								usinaElevatoria.setAtributo(AttComumUsinaElevatoria_submercado, idSubmercado);
								usinaElevatoria.setAtributo(AttComumUsinaElevatoria_nome, nome);
								usinaElevatoria.setAtributo(AttComumUsinaElevatoria_usina_origem_bombeamento, idHidreletrica_origem);
								usinaElevatoria.setAtributo(AttComumUsinaElevatoria_usina_destino_bombeamento, idHidreletrica_destino);
								usinaElevatoria.setAtributo(AttComumUsinaElevatoria_vazao_bombeada_minima, bombeamento_minimo);
								usinaElevatoria.setAtributo(AttComumUsinaElevatoria_vazao_bombeada_maxima, bombeamento_maximo);
								usinaElevatoria.setAtributo(AttComumUsinaElevatoria_taxa_de_consumo, taxa_de_consumo);

								lista_codigo_ONS_usina_elevatoria.setElemento(idUsinaElevatoria, codigo_usina);

								//Cria vetor fator_disponibilidade com valores default 1.0 p.u
								const SmartEnupla<Periodo, double> vetor_fator_disponibilidade(horizonte_estudo, 1.0); //Valor default
								usinaElevatoria.setVetor(AttVetorUsinaElevatoria_fator_disponibilidade, vetor_fator_disponibilidade);

								usinaElevatoria.setVetor(AttVetorUsinaElevatoria_vazao_bombeada_minima, SmartEnupla<Periodo, double>(horizonte_estudo, bombeamento_minimo));
								usinaElevatoria.setVetor(AttVetorUsinaElevatoria_vazao_bombeada_maxima, SmartEnupla<Periodo, double>(horizonte_estudo, bombeamento_maximo));


								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Inicializa Smart elemento
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								a_dados.vetorUsinaElevatoria.add(usinaElevatoria);

							}//if (int(idUsinaElevatoria_inicializado.size()) == 0) {
							else { //já inicializada

								idUsinaElevatoria = idUsinaElevatoria_inicializado;

								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setAtributo(AttComumUsinaElevatoria_submercado, idSubmercado);
								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setAtributo(AttComumUsinaElevatoria_nome, nome);
								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setAtributo(AttComumUsinaElevatoria_usina_origem_bombeamento, idHidreletrica_origem);
								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setAtributo(AttComumUsinaElevatoria_usina_destino_bombeamento, idHidreletrica_destino);
								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setAtributo(AttComumUsinaElevatoria_vazao_bombeada_minima, bombeamento_minimo);
								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setAtributo(AttComumUsinaElevatoria_vazao_bombeada_minima, bombeamento_maximo);
								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setAtributo(AttComumUsinaElevatoria_taxa_de_consumo, taxa_de_consumo);

								//Cria vetor fator_disponibilidade com valores default 1.0 p.u
								const SmartEnupla<Periodo, double> vetor_fator_disponibilidade(horizonte_estudo, 1.0); //Valor default
								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setVetor(AttVetorUsinaElevatoria_fator_disponibilidade, vetor_fator_disponibilidade);

								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setVetor(AttVetorUsinaElevatoria_vazao_bombeada_minima, SmartEnupla<Periodo, double>(horizonte_estudo, bombeamento_minimo));
								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setVetor(AttVetorUsinaElevatoria_vazao_bombeada_maxima, SmartEnupla<Periodo, double>(horizonte_estudo, bombeamento_maximo));

							}//else if (int(idTermeletrica_inicializado.size()) == 1) {

							//Nota: Criar o vetor fator_disponibilidade com valores default 1, logo se encontra o menemonico ME atualiza estes valores

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro UE: \n" + std::string(erro.what())); }

					}//if (menemonico == "UE") {
					
					if (menemonico == "ME") {//Dados de manutenção das estações de bombeamento

						try {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da estação de bombeamento. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//codigo_usina
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -   Índice do subsistema ao qual pertence a estação de bombeamento.  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, atoi(atributo.c_str()));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);


							//Identifica se alguma usina elevatoria tem sido inicializada com codigo_usina

							const IdUsinaElevatoria idUsinaElevatoria_inicializado = getIdFromCodigoONS(lista_codigo_ONS_usina_elevatoria, codigo_usina);

							if (idUsinaElevatoria_inicializado != IdUsinaElevatoria_Nenhum) {

								const IdUsinaElevatoria  idUsinaElevatoria = idUsinaElevatoria_inicializado;

								if (a_dados.getAtributo(idUsinaElevatoria, AttComumUsinaElevatoria_submercado, IdSubmercado()) != idSubmercado)
									throw std::invalid_argument("IdSubmercado do registro ME diferente do registro UE para a usina elevatoria com codigo_usina_" + codigo_usina);

								IdEstagio idEstagio_usinaElevatoria = IdEstagio_Nenhum;

								//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Nota: Campo não encontrado nos Decks pesquisados, geralmente, esta informação vem como default no campo UE
								//      Segundo o manual do usuário, são 17 campos com 85 colunas, portanto, a lógica de leitura considera 5 colunas/campo
								//      Cada campo corresponderia a um estágio
								//      Verifica o tamanho da linha a ser lida
								//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								const int line_size = int(line.length());

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4 a 20 -   Fatores de disponibilidade para os N estágios em p.u..  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								int conteio = 0;

								while (line_size >= 19 + conteio * 5) {

									atributo = line.substr(14 + conteio * 5, 5);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									const double fator_disponibilidade = atof(atributo.c_str());

									idEstagio_usinaElevatoria++;

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										//Atualiza a informação unicamente para o estágio DC indicado

										if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_usinaElevatoria) {

											//Se é último estágio DC, o periodo deve ser maior ou igual ao estágio DC

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_usinaElevatoria))
												a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setElemento(AttVetorUsinaElevatoria_fator_disponibilidade, periodo, fator_disponibilidade);

										}//if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_usinaElevatoria) {
										else {

											//Se não é último estágio DC, o periodo deve ser entre dois estágios DC consecutivos

											const IdEstagio idEstagio_usinaElevatoria_seguinte = IdEstagio(idEstagio_usinaElevatoria + 1);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_usinaElevatoria) && periodo < horizonte_otimizacao_DC.at(idEstagio_usinaElevatoria_seguinte))
												a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setElemento(AttVetorUsinaElevatoria_fator_disponibilidade, periodo, fator_disponibilidade);

										}//else {

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									conteio++;

								}//while (line_size >= 19) {

							}//if (idUsinaElevatoria_inicializado != IdUsinaElevatoria_Nenhum) {
							else
								throw std::invalid_argument("Leitura do registro ME com usina elevatoria nao instanciada com codigo_usina_" + codigo_usina);

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro ME: \n" + std::string(erro.what())); }

					}//if (menemonico == "ME") {

					if (menemonico == "DP") {//Carga dos subsistemas					

						try {

							if(int(demanda_media_deck.size()) == 0)//Inicializa vetor auxiliar para utilizar na conversão com modulação PD da demanda
								demanda_media_deck = SmartEnupla<IdSubmercado, SmartEnupla<Periodo, double>>(IdSubmercado(1), std::vector<SmartEnupla<Periodo, double>>(IdSubmercado(int(IdSubmercado_Excedente) - 1), SmartEnupla<Periodo, double>(horizonte_estudo_DECK, 0.0)));

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número de identificação do estágio (em ordem crescente, máximo igual a 24).
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(4, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_demanda = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Índice do subsistema .
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_usina);

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + codigo_usina);


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Filosofia: Verifica o tamanho da linha se existem dados de demanda e duração para determinar um novo patamar de carga
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							int numero_patamares = 0;

							double valor;

							std::vector<double> demanda_patamar;
							std::vector<double> duracao_horas_patamar;

							const int line_size = int(line.length());

							if (line_size >= 39) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4 - Carga do patamar 1,em MWmed. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(19, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (atributo == "")
									valor = 0;
								else
									valor = atof(atributo.c_str());

								demanda_patamar.push_back(valor);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 5 - Duração do patamar 1, em horas.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(29, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								duracao_horas_patamar.push_back(atof(atributo.c_str()));

							}//if (line_size >= 39) {

							if (line_size >= 59) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 6 - Carga do patamar 2,em MWmed. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(39, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (atributo == "")
									valor = 0;
								else
									valor = atof(atributo.c_str());

								demanda_patamar.push_back(valor);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 7 - Duração do patamar 2, em horas.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(49, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								duracao_horas_patamar.push_back(atof(atributo.c_str()));

							}//if (line_size >= 59) {

							if (line_size >= 79) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 8 - Carga do patamar 3,em MWmed. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(59, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (atributo == "")
									valor = 0;
								else
									valor = atof(atributo.c_str());

								demanda_patamar.push_back(valor);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 9 - Duração do patamar 3, em horas.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(69, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								duracao_horas_patamar.push_back(atof(atributo.c_str()));

							}//if (line_size >= 79) {

							if (line_size >= 99) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 10 - Carga do patamar 4,em MWmed. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(79, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (atributo == "")
									valor = 0;
								else
									valor = atof(atributo.c_str());

								demanda_patamar.push_back(valor);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 11 - Duração do patamar 4, em horas.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(89, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								duracao_horas_patamar.push_back(atof(atributo.c_str()));

							}//if (line_size >= 99) {

							if (line_size >= 119) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 10 - Carga do patamar 5,em MWmed. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(99, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (atributo == "")
									valor = 0;
								else
									valor = atof(atributo.c_str());

								demanda_patamar.push_back(valor);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 11 - Duração do patamar 5, em horas.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(109, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								duracao_horas_patamar.push_back(atof(atributo.c_str()));

							}//if (line_size >= 119) {


							if (true) {
								//Necessário para a conversão com a modulação da demanda informada na preConfig PD

								const Periodo periodo_deck = horizonte_otimizacao_DC.at(idEstagio_demanda);

								if (idSubmercado == IdSubmercado(1)) {

									const int size_duracao_horas_patamar = int(duracao_horas_patamar.size());

									std::vector<double> percentual_duracao_patamar;

									double horasTotais = 0;

									for (int pos = 0; pos < size_duracao_horas_patamar; pos++)
										horasTotais += duracao_horas_patamar.at(pos);

									for (int pos = 0; pos < size_duracao_horas_patamar; pos++)
										percentual_duracao_patamar.push_back(duracao_horas_patamar.at(pos) * std::pow(horasTotais, -1));

									percentual_duracao_patamar_carga_deck.addElemento(periodo_deck, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, percentual_duracao_patamar));
								}//if (idSubmercado == IdSubmercado(1)) {
								//////////////
								
								double demanda_media = 0.0;

								for (int pos = 0; pos < int(demanda_patamar.size()); pos++)
									demanda_media += demanda_patamar.at(pos) * percentual_duracao_patamar_carga_deck.at(periodo_deck).at(IdPatamarCarga(pos + 1));

								demanda_media_deck.at(idSubmercado).at(periodo_deck) = demanda_media;

							}//if (true) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							///////////////////////////////////////////////////////////////////////////
							//Para o estágio 1 - Inicializa matrizes com valor 0 para todos os estágios
							///////////////////////////////////////////////////////////////////////////

							if (idEstagio_demanda == IdEstagio_1)
								a_dados.vetorSubmercado.at(idSubmercado).setMatriz(AttMatrizSubmercado_demanda, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> (horizonte_estudo, SmartEnupla<IdPatamarCarga, double>()));

							///////////////////////////////////////////////////////////////////////////
							//Atualiza informação de cada estágio 
							///////////////////////////////////////////////////////////////////////////	

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								//////////////////////////////////////////////////////////////////////////////
								//Inicializa o numero de patamares com percentual_duracao_patamar_carga > 0
								//////////////////////////////////////////////////////////////////////////////

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

								if (a_dados.vetorSubmercado.at(idSubmercado).getElementosMatriz(AttMatrizSubmercado_demanda, periodo, IdPatamarCarga(), double()).size() == 0)
									a_dados.vetorSubmercado.at(idSubmercado).setElementos(AttMatrizSubmercado_demanda, periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								//////////////////////////////////////////////////////////////////////////////

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										//Atualiza a informação unicamente para o estágio DC indicado
										if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_demanda) {

											//Se é último estágio DC, o periodo deve ser maior ou igual ao estágio DC

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_demanda))
												a_dados.vetorSubmercado.at(idSubmercado).setElemento(AttMatrizSubmercado_demanda, periodo, idPatamarCarga, demanda_patamar.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

										}//if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_demanda) {
										else {

											//Se não é último estágio DC, o periodo deve ser entre dois estágios DC consecutivos

											const IdEstagio idEstagio_demanda_seguinte = IdEstagio(idEstagio_demanda + 1);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_demanda) && periodo < horizonte_otimizacao_DC.at(idEstagio_demanda_seguinte))
												a_dados.vetorSubmercado.at(idSubmercado).setElemento(AttMatrizSubmercado_demanda, periodo, idPatamarCarga, demanda_patamar.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));												
											else if (periodo >= horizonte_otimizacao_DC.at(idEstagio_demanda_seguinte))
												break; //Evita percorrer todo o horizonte_estudo

										}//else {

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {					

							leitura_registro_DP = true;

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro DP: \n" + std::string(erro.what())); }

					}//if (menemonico == "DP") {

					if (menemonico == "CD") {//Custo de déficit

						try {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da curva de deficit 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Índice do subsistema ao qual pertence a curva. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////					
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, atoi(atributo.c_str()));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Nome da curva de deficit. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string nome = atributo;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Índice do estágio.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(24, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_patamar_deficit = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////

							std::vector<double> patamarDeficit_percentual_da_demanda;
							std::vector<double> patamarDeficit_custo;

							int numero_patamares = 0;
							const int line_size = int(line.length());

							if (line_size >= 44) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 6 - Intervalo da curva de custo de deficit em percentual da carga, associado ao 1 o patamar de carga. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(29, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								patamarDeficit_percentual_da_demanda.push_back(atof(atributo.c_str()) / 100);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 7 - Custo de deficit associado ao 1o patamar de carga em $/MWh.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(34, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								patamarDeficit_custo.push_back(atof(atributo.c_str()));

							}//if (line_size >= 44) {

							if (line_size >= 59) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 8 - Intervalo da curva de custo de deficit em percentual da carga, associado ao 2 o patamar de carga
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(44, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								patamarDeficit_percentual_da_demanda.push_back(atof(atributo.c_str()) / 100);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 9 - Custo de deficit associado ao 2o patamar de carga em $/MWh.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(49, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								patamarDeficit_custo.push_back(atof(atributo.c_str()));

							}//if (line_size >= 59) {

							if (line_size >= 74) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 10 - Intervalo da curva de custo de deficit em percentual da carga, associado ao 3 o patamar de carga
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(59, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								patamarDeficit_percentual_da_demanda.push_back(atof(atributo.c_str()) / 100);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 11 - Custo de deficit associado ao 3o patamar de carga em $/MWh.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(64, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								patamarDeficit_custo.push_back(atof(atributo.c_str()));

							}//if (line_size >= 74) {

							if (line_size >= 89) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 12 - Intervalo da curva de custo de deficit em percentual da carga, associado ao 4 o patamar de carga
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(74, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								patamarDeficit_percentual_da_demanda.push_back(atof(atributo.c_str()) / 100);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 13 - Custo de deficit associado ao 4o patamar de carga em $/MWh.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(79, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								patamarDeficit_custo.push_back(atof(atributo.c_str()));

							}//if (line_size >= 89) {

							if (line_size >= 104) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 14 - Intervalo da curva de custo de deficit em percentual da carga, associado ao 5 o patamar de carga
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(89, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								patamarDeficit_percentual_da_demanda.push_back(atof(atributo.c_str()) / 100);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 15 - Custo de deficit associado ao 5o patamar de carga em $/MWh.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(94, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								patamarDeficit_custo.push_back(atof(atributo.c_str()));

							}//if (line_size >= 104) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Filosofia, sobreescreve a informação para t >= idEstagio
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (idEstagio_patamar_deficit == IdEstagio_1) { //Inicializa PatamarDeficit

								PatamarDeficit patamarDeficit;

								//IdPatamarDeficit idPatamarDeficit = a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.getMaiorId();

								IdPatamarDeficit idPatamarDeficit = a_dados.getMaiorId(idSubmercado, IdPatamarDeficit());

								if (idPatamarDeficit == IdPatamarDeficit_Nenhum)
									idPatamarDeficit = IdPatamarDeficit_1;
								else
									idPatamarDeficit++;

								patamarDeficit.setAtributo(AttComumPatamarDeficit_idPatamarDeficit, idPatamarDeficit);
								patamarDeficit.setAtributo(AttComumPatamarDeficit_nome, nome);

								if (idPatamarDeficit == IdPatamarDeficit_1) {

									SmartEnupla<IdPatamarDeficit, int> lista_codigo_usina_patamar_deficit(1);

									lista_codigo_usina_patamar_deficit.addElemento(idPatamarDeficit, codigo_usina);

									matriz_codigo_ONS_patamar_deficit.setElemento(idSubmercado, lista_codigo_usina_patamar_deficit);

								}//if (idPatamarDeficit == IdPatamarDeficit_1) {
								else
									matriz_codigo_ONS_patamar_deficit.at(idSubmercado).addElemento(idPatamarDeficit, codigo_usina);


								/////////////////////////////////////

								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_patamarDeficit_percentual_da_demanda(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_patamarDeficit_custo(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									matriz_patamarDeficit_percentual_da_demanda.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));
									matriz_patamarDeficit_custo.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								/////////////////////////////////////

								patamarDeficit.setMatriz(AttMatrizPatamarDeficit_percentual, matriz_patamarDeficit_percentual_da_demanda);
								patamarDeficit.setMatriz(AttMatrizPatamarDeficit_custo, matriz_patamarDeficit_custo);

								a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.add(patamarDeficit);

							}//if (idEstagio_patamar_deficit == IdEstagio_1) {


							//Identifica o PatamarDeficit inicializado com codigo_usina
							const IdPatamarDeficit idPatamarDeficit_inicializado = getIdFromCodigoONS(matriz_codigo_ONS_patamar_deficit, idSubmercado, codigo_usina);

							if (idPatamarDeficit_inicializado == IdPatamarDeficit_Nenhum)
								throw std::invalid_argument("Nao inicializada idContrato com codigo_usina_" + getString(codigo_usina));

							const IdPatamarDeficit  idPatamarDeficit = idPatamarDeficit_inicializado;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_patamar_deficit)) {

											a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setElemento(AttMatrizPatamarDeficit_percentual, periodo, idPatamarCarga, patamarDeficit_percentual_da_demanda.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setElemento(AttMatrizPatamarDeficit_custo, periodo, idPatamarCarga, patamarDeficit_custo.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

										}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_patamar_deficit)) {

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


							leitura_registro_CD = true;

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro CD: \n" + std::string(erro.what())); }

					}//if (menemonico == "CD") {

					//Se a leitura dos submercados/ cargas dos submercados /custo déficit é finalizada (Registro SB/DP/CD) então inicializa submercados IV e ANDE
					if (leitura_registro_SB == true && menemonico != "SB" && leitura_registro_DP == true && menemonico != "DP" && leitura_registro_CD == true && menemonico != "CD") {

						inicializa_Submercados_Intercambios_Nao_Registrados(a_dados, horizonte_estudo);

						leitura_registro_SB = false;
						leitura_registro_DP = false;
						leitura_registro_CD = false;

					}//if (leitura_registro_SB == true && menemonico != "SB") {

					if (menemonico == "BE") {//Geração em bacias especiais/pequenas bacias

						try {

							if (int(conteio_numero_usina_nao_simulado_por_submercado.size()) == 0)//Necessário para a alocação de várias uninaNaoSimuladas não identificadas em uma única uninaNaoSimulada
								conteio_numero_usina_nao_simulado_por_submercado = SmartEnupla <IdSubmercado, SmartEnupla<IdUsinaNaoSimulada, SmartEnupla<Periodo, int>>>(IdSubmercado(1), std::vector<SmartEnupla<IdUsinaNaoSimulada, SmartEnupla<Periodo, int>>>(IdSubmercado(int(IdSubmercado_Excedente) - 1), SmartEnupla<IdUsinaNaoSimulada, SmartEnupla<Periodo, int>>(IdUsinaNaoSimulada(1), std::vector<SmartEnupla<Periodo, int>>(IdUsinaNaoSimulada(int(IdUsinaNaoSimulada_Excedente) - 1), SmartEnupla<Periodo, int>(horizonte_estudo, 0)))));

							const int numero_submercados = getintFromChar(getString(a_dados.getMaiorId(IdSubmercado())).c_str());

							//Esta geração vai ser considerada dentro das UsinaNaoSimulada

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Nome da bacia. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string nome = atributo;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Índice do submercado ao qual pertence a bacia.  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////					
							atributo = line.substr(14, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, atoi(atributo.c_str()));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Identificação do estágio correspondente às gerações.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(19, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_bacia_especial = getIdEstagioFromChar(atributo.c_str());

							////////////////////////////////////////////////////////////////////////////////////////////
							// Campos 5-9 - Geração no patamar 1 em MWmed e Fator de perdas para o centro de gravidade da carga (%) 
							// Manual: O campo “fator de perdas” é o campo seguinte ao campo de geração do último patamar. 
							////////////////////////////////////////////////////////////////////////////////////////////

							const int line_size = int(line.length());

							int numero_patamares;

							if (line_size >= 49 && line.substr(48, 1) != " ")
								numero_patamares = 5;
							else if (line_size >= 44 && line.substr(43, 1) != " ")
								numero_patamares = 4;
							else if (line_size >= 39 && line.substr(38, 1) != " ")
								numero_patamares = 3;
							else if (line_size >= 34 && line.substr(33, 1) != " ")
								numero_patamares = 2;
							else if (line_size >= 29 && line.substr(28, 1) != " ")
								numero_patamares = 1;


							std::vector<double> usinaNaoSimulada_potencia_gerada;

							for (int pat = 0; pat < numero_patamares; pat++) {

								atributo = line.substr(24 + 5 * pat, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								usinaNaoSimulada_potencia_gerada.push_back(atof(atributo.c_str()));

							}//for (int pat = 0; pat < numero_patamares; pat++) {


							//No Deck não aparece esta informação apesar das diretrizes do manual de referência
							double fator_de_perdas;

							if (line_size >= 29 + 5 * numero_patamares) {

								atributo = line.substr(24 + 5 * numero_patamares, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());
								fator_de_perdas = atof(atributo.c_str());

							}//if (line_size >= 29 + 5 * numero_patamares) {
							else
								fator_de_perdas = 1; //Default: nos Decks não especificam este valor

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Filosofia, sobreescreve a informação para t >= idEstagio e soma todas as bacias especias guardando um valor total
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							//Identifica o PatamarDeficit inicializado com codigo_usina
							const IdUsinaNaoSimulada idUsinaNaoSimulada = IdUsinaNaoSimulada_1; //No DC o padrao é IdUsinaNaoSimulada agregada

							if (idEstagio_bacia_especial == IdEstagio_1 && !a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.isInstanciado(idUsinaNaoSimulada)) { //UsinaNaoSimulada não instanciada

								UsinaNaoSimulada usinaNaoSimulada;

								usinaNaoSimulada.setAtributo(AttComumUsinaNaoSimulada_idUsinaNaoSimulada, idUsinaNaoSimulada);


								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_usinaNaoSimulada_potencia_gerada(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									matriz_usinaNaoSimulada_potencia_gerada.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								/////////////////////////////////////

								usinaNaoSimulada.setMatriz(AttMatrizUsinaNaoSimulada_potencia_minima, matriz_usinaNaoSimulada_potencia_gerada);
								usinaNaoSimulada.setMatriz(AttMatrizUsinaNaoSimulada_potencia_maxima, matriz_usinaNaoSimulada_potencia_gerada);

								a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.add(usinaNaoSimulada);

							}//if (int(idPatamarDeficit_inicializado.size()) == 1) {
								
							//UsinaNaoSimulada instanciada e idEstagio > 1 -> Substrai o valor do estágio anterior (somado previamente) e soma a nova bacia com os valores já registrados

							double valor = 0;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_bacia_especial)) {

											if (conteio_numero_usina_nao_simulado_por_submercado.at(idSubmercado).at(idUsinaNaoSimulada).getElemento(periodo) == 0 && periodo.sobreposicao(horizonte_otimizacao_DC.at(idEstagio_bacia_especial)) > 0) {
												valor = usinaNaoSimulada_potencia_gerada.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1);
											}//if (conteio == 0) {
											else {
												valor = a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).getElementoMatriz(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, idPatamarCarga, double());
												valor += usinaNaoSimulada_potencia_gerada.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1);
											}//else {

											a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_minima, periodo, idPatamarCarga, valor);
											a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, idPatamarCarga, valor);

										}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_bacia_especial)) {

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							bool sobreposicao_encontrada = false;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.at(idEstagio_bacia_especial));

								if (sobreposicao > 0) {
									conteio_numero_usina_nao_simulado_por_submercado.at(idSubmercado).at(idUsinaNaoSimulada).setElemento(periodo, conteio_numero_usina_nao_simulado_por_submercado.at(idSubmercado).at(idUsinaNaoSimulada).getElemento(periodo) + 1);
									sobreposicao_encontrada = true;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_bacia_especial)) {

								if (sobreposicao_encontrada && sobreposicao == 0)
									break;

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro BE: \n" + std::string(erro.what())); }

					}//if (menemonico == "BE") {

					if (menemonico == "PQ") {//Geração em pequenas usinas

						try {

							if (int(conteio_numero_usina_nao_simulado_por_submercado.size()) == 0)//Necessário para a alocação de várias uninaNaoSimuladas não identificadas em uma única uninaNaoSimulada
								conteio_numero_usina_nao_simulado_por_submercado = SmartEnupla <IdSubmercado, SmartEnupla<IdUsinaNaoSimulada, SmartEnupla<Periodo, int>>>(IdSubmercado(1), std::vector<SmartEnupla<IdUsinaNaoSimulada, SmartEnupla<Periodo, int>>>(IdSubmercado(int(IdSubmercado_Excedente) - 1), SmartEnupla<IdUsinaNaoSimulada, SmartEnupla<Periodo, int>>(IdUsinaNaoSimulada(1), std::vector<SmartEnupla<Periodo, int>>(IdUsinaNaoSimulada(int(IdUsinaNaoSimulada_Excedente) - 1), SmartEnupla<Periodo, int>(horizonte_estudo, 0)))));


							if (int(geracao_usina_nao_simulada_media_deck.size()) == 0)//Inicializa vetor auxiliar para utilizar na conversão com modulação PD
								geracao_usina_nao_simulada_media_deck = SmartEnupla <IdSubmercado, SmartEnupla<IdUsinaNaoSimulada, SmartEnupla<Periodo, double>>>(IdSubmercado(1), std::vector<SmartEnupla<IdUsinaNaoSimulada, SmartEnupla<Periodo, double>>>(IdSubmercado(int(IdSubmercado_Excedente) - 1), SmartEnupla<IdUsinaNaoSimulada, SmartEnupla<Periodo, double>>(IdUsinaNaoSimulada(1), std::vector<SmartEnupla<Periodo, double>>(IdUsinaNaoSimulada(int(IdUsinaNaoSimulada_Excedente) - 1), SmartEnupla<Periodo, double>(horizonte_estudo_DECK, 0.0)))));
								
							const int numero_submercados = getintFromChar(getString(a_dados.getMaiorId(IdSubmercado())).c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Nome
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string nome = atributo;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Índice do submercado ao qual pertence a bacia.  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////					
							atributo = line.substr(14, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, atoi(atributo.c_str()));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Identificação do estágio correspondente às gerações.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(19, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_registro = getIdEstagioFromChar(atributo.c_str());

							////////////////////////////////////////////////////////////////////////////////////////////
							// Campos 5-10 - Geração no patamar 1 em MWmed e Fator de perdas para o centro de gravidade da carga (%) 
							// Manual: O campo “fator de perdas” é o campo seguinte ao campo de geração do último patamar. 
							////////////////////////////////////////////////////////////////////////////////////////////

							const int line_size = int(line.length());

							int numero_patamares;


							if (line_size >= 49 && line.substr(48, 1) != " ")
								numero_patamares = 5;
							else if (line_size >= 44 && line.substr(43, 1) != " ")
								numero_patamares = 4;
							else if (line_size >= 39 && line.substr(38, 1) != " ")
								numero_patamares = 3;
							else if (line_size >= 34 && line.substr(33, 1) != " ")
								numero_patamares = 2;
							else if (line_size >= 29 && line.substr(28, 1) != " ")
								numero_patamares = 1;

							std::vector<double> usinaNaoSimulada_potencia_gerada;

							for (int pat = 0; pat < numero_patamares; pat++) {

								atributo = line.substr(24 + 5 * pat, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								usinaNaoSimulada_potencia_gerada.push_back(atof(atributo.c_str()));

							}//for (int pat = 0; pat < numero_patamares; pat++) {


							//No Deck não aparece esta informação apesar das diretrizes do manual de referência
							double fator_de_perdas;

							if (line_size >= 29 + 5 * numero_patamares) {

								atributo = line.substr(24 + 5 * numero_patamares, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());
								fator_de_perdas = atof(atributo.c_str());

							}//if (line_size >= 29 + 5 * numero_patamares) {
							else
								fator_de_perdas = 1; //Default: nos Decks não especificam este valor


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Filosofia, sobreescreve a informação para t >= idEstagio e soma todas as bacias especias guardando um valor total
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


							////////////////////////////////////////////////////////////
							//Identifica o idUsinaNaoSimulada

							const IdUsinaNaoSimulada idUsinaNaoSimulada = getIdUsinaNaoSimulada_from_nome_or_bloco(nome, "");

							if (true) {
								//Necessário para a conversão com a modulação da demanda informada na preConfig PD 								
								for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {
									if (periodo_deck >= horizonte_otimizacao_DC.at(idEstagio_registro)) {

										double geracao_media = 0.0;
										for (int pos = 0; pos < int(usinaNaoSimulada_potencia_gerada.size()); pos++)
											geracao_media += usinaNaoSimulada_potencia_gerada.at(pos) * percentual_duracao_patamar_carga_deck.at(periodo_deck).at(IdPatamarCarga(pos + 1));

										geracao_usina_nao_simulada_media_deck.at(idSubmercado).at(idUsinaNaoSimulada).at(periodo_deck) = geracao_media;
									}//if (periodo_deck >= horizonte_otimizacao_DC.at(idEstagio_registro)) {
								}//for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

							}//if (true) {

							if (idEstagio_registro == IdEstagio_1 && !a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.isInstanciado(idUsinaNaoSimulada)) { //UsinaNaoSimulada não instanciada

								UsinaNaoSimulada usinaNaoSimulada;

								usinaNaoSimulada.setAtributo(AttComumUsinaNaoSimulada_idUsinaNaoSimulada, idUsinaNaoSimulada);

								/////////////////////////////////////

								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_usinaNaoSimulada_potencia_gerada(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									matriz_usinaNaoSimulada_potencia_gerada.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								/////////////////////////////////////

								usinaNaoSimulada.setMatriz(AttMatrizUsinaNaoSimulada_potencia_minima, matriz_usinaNaoSimulada_potencia_gerada);
								usinaNaoSimulada.setMatriz(AttMatrizUsinaNaoSimulada_potencia_maxima, matriz_usinaNaoSimulada_potencia_gerada);

								a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.add(usinaNaoSimulada);

							}//if (idEstagio_registro == IdEstagio_1 && !a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.isInstanciado(idUsinaNaoSimulada)) { 

							//Identifica o PatamarDeficit inicializado com codigo_usina
							double valor = 0;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_registro)) {


											if (conteio_numero_usina_nao_simulado_por_submercado.at(idSubmercado).at(idUsinaNaoSimulada).getElemento(periodo) == 0 && periodo.sobreposicao(horizonte_otimizacao_DC.at(idEstagio_registro))) {
												valor = usinaNaoSimulada_potencia_gerada.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1);
											}//if (conteio == 0) {
											else {
												valor = a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).getElementoMatriz(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, idPatamarCarga, double());
												valor += usinaNaoSimulada_potencia_gerada.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1);
											}//else {

											a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_minima, periodo, idPatamarCarga, valor);
											a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, idPatamarCarga, valor);


										}//if (horizonte_estudo.at(periodo) >= idEstagio_bacia_especial) {

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							bool sobreposicao_encontrada = false;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.at(idEstagio_registro));

								if (sobreposicao > 0) {
									conteio_numero_usina_nao_simulado_por_submercado.at(idSubmercado).at(idUsinaNaoSimulada).setElemento(periodo, conteio_numero_usina_nao_simulado_por_submercado.at(idSubmercado).at(idUsinaNaoSimulada).getElemento(periodo) + 1);
									sobreposicao_encontrada = true;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_bacia_especial)) {

								if (sobreposicao_encontrada && sobreposicao == 0)
									break;

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro PQ: \n" + std::string(erro.what())); }

					}//if (menemonico == "PQ") {

					// RESTRIÇÃO DE GERAÇÃO ITAIPU (50/60 HZ)
					if (menemonico == "RI") {

						try {

							const int codigo_usina = std::stoi(line.substr(4, 3));

							const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							if (idHidreletrica == IdHidreletrica_Nenhum)
								throw std::invalid_argument("Registro RI - hidreletrica nao instanciada com codigo_usina_" + getString(codigo_usina));


							const IdEstagio idEstagio_inicial = IdEstagio(std::stoi(line.substr(8, 3)));

							int num_patamar_carga = 0;

							if (line.size() >= 190) { num_patamar_carga = 5; }
							else if (line.size() >= 155) { num_patamar_carga = 4; }
							else if (line.size() >= 120) { num_patamar_carga = 3; }
							else if (line.size() >= 85) { num_patamar_carga = 2; }
							else if (line.size() >= 50) { num_patamar_carga = 1; }

							/////////////////////////////////////
							SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
								matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {
							/////////////////////////////////////

							if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_conjunto) {

								const IdSubmercado idSubmercado_ande = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_ANDE);

								// VERIFICA SE O CONJUNTO HIDRAULICO JÁ FOI INSTANCIADO
								if (!a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.isInstanciado(IdConjuntoHidraulico_1)) {
									ConjuntoHidraulico conjuntohidraulico;
									conjuntohidraulico.setAtributo(AttComumConjuntoHidraulico_idConjuntoHidraulico, IdConjuntoHidraulico_1);
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.add(conjuntohidraulico);
								}
								if (!a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.isInstanciado(IdConjuntoHidraulico_2)) {
									ConjuntoHidraulico conjuntohidraulico;
									conjuntohidraulico.setAtributo(AttComumConjuntoHidraulico_idConjuntoHidraulico, IdConjuntoHidraulico_2);
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.add(conjuntohidraulico);
								}


								if (a_dados.getSize1Matriz(idHidreletrica, IdConjuntoHidraulico_1, AttMatrizConjuntoHidraulico_potencia_minima) == 0)
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_1).setMatriz(AttMatrizConjuntoHidraulico_potencia_minima, matriz_zero);

								if (a_dados.getSize1Matriz(idHidreletrica, IdConjuntoHidraulico_2, AttMatrizConjuntoHidraulico_potencia_minima) == 0)
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_2).setMatriz(AttMatrizConjuntoHidraulico_potencia_minima, matriz_zero);

								if (a_dados.getSize1Matriz(idHidreletrica, IdConjuntoHidraulico_1, AttMatrizConjuntoHidraulico_potencia_maxima) == 0)
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_1).setMatriz(AttMatrizConjuntoHidraulico_potencia_maxima, matriz_zero);

								if (a_dados.getSize1Matriz(idHidreletrica, IdConjuntoHidraulico_2, AttMatrizConjuntoHidraulico_potencia_maxima) == 0)
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_2).setMatriz(AttMatrizConjuntoHidraulico_potencia_maxima, matriz_zero);

								if (a_dados.getSize1Matriz(idSubmercado_ande, AttMatrizSubmercado_demanda) == 0)
									a_dados.vetorSubmercado.at(idSubmercado_ande).setMatriz(AttMatrizSubmercado_demanda, matriz_zero);

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.getElemento(idEstagio_inicial)) {

												int passo = (int(idPatamarCarga_DECK) - 1) * 35;
												// GERAÇÃO ITAIPU 60 HZ
												a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_2).setElemento(AttMatrizConjuntoHidraulico_potencia_minima, periodo, idPatamarCarga, std::stod(line.substr(passo + 16, 7)));
												a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_2).setElemento(AttMatrizConjuntoHidraulico_potencia_maxima, periodo, idPatamarCarga, std::stod(line.substr(passo + 24, 7)));

												// GERAÇÃO ITAIPU 50 HZ
												a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_1).setElemento(AttMatrizConjuntoHidraulico_potencia_minima, periodo, idPatamarCarga, std::stod(line.substr(passo + 30, 7)));
												a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_1).setElemento(AttMatrizConjuntoHidraulico_potencia_maxima, periodo, idPatamarCarga, std::stod(line.substr(passo + 37, 7)));

												// CARGA ANDE
												a_dados.vetorSubmercado.at(idSubmercado_ande).setElemento(AttMatrizSubmercado_demanda, periodo, idPatamarCarga, std::stod(line.substr(passo + 44, 7)));

												
											}//if (periodo >= horizonte_otimizacao_DC.getElemento(idEstagio_inicial)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_conjunto) {

							else if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina) {

								//Na representaçao por usina de Itaipú os limites do intercambio Itaipú->Ande e Itaipú->IV sao atualizados

								const IdSubmercado idSubmercado_itaipu = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_submercado_ITAIPU);
								const IdSubmercado idSubmercado_ande = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_ANDE);
								const IdSubmercado idSubmercado_iv = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_IV);

								std::vector<IdIntercambio> idIntercambio_inicializado = a_dados.vetorIntercambio.getIdObjetos(AttComumIntercambio_submercado_origem, idSubmercado_itaipu);

								int idIntercambio_inicializado_size = int(idIntercambio_inicializado.size());

								IdIntercambio idIntercambio_itaipu_ande = IdIntercambio_Nenhum;

								for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

									if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_ande) {
										idIntercambio_itaipu_ande = idIntercambio_inicializado.at(intercambio_inicializado);
										break;
									}//if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {

								}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

								if (idIntercambio_itaipu_ande == IdIntercambio_Nenhum)
									throw std::invalid_argument("Registro RI - Intercambio nao encontrado");

								////////////////

								IdIntercambio idIntercambio_itaipu_iv = IdIntercambio_Nenhum;

								for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

									if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_iv) {
										idIntercambio_itaipu_iv = idIntercambio_inicializado.at(intercambio_inicializado);
										break;
									}//if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {

								}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

								if (idIntercambio_itaipu_iv == IdIntercambio_Nenhum)
									throw std::invalid_argument("Registro RI - Intercambio nao encontrado");


								/////////////////////////////

								if (a_dados.getSize1Matriz(idIntercambio_itaipu_ande, AttMatrizIntercambio_potencia_minima) == 0)
									a_dados.vetorIntercambio.at(idIntercambio_itaipu_ande).setMatriz(AttMatrizIntercambio_potencia_minima, matriz_zero);

								if (a_dados.getSize1Matriz(idIntercambio_itaipu_ande, AttMatrizIntercambio_potencia_maxima) == 0)
									a_dados.vetorIntercambio.at(idIntercambio_itaipu_ande).setMatriz(AttMatrizIntercambio_potencia_maxima, matriz_zero);

								if (a_dados.getSize1Matriz(idIntercambio_itaipu_iv, AttMatrizIntercambio_potencia_minima) == 0)
									a_dados.vetorIntercambio.at(idIntercambio_itaipu_iv).setMatriz(AttMatrizIntercambio_potencia_minima, matriz_zero);

								if (a_dados.getSize1Matriz(idIntercambio_itaipu_iv, AttMatrizIntercambio_potencia_maxima) == 0)
									a_dados.vetorIntercambio.at(idIntercambio_itaipu_iv).setMatriz(AttMatrizIntercambio_potencia_maxima, matriz_zero);

								if (a_dados.getSize1Matriz(idSubmercado_ande, AttMatrizSubmercado_demanda) == 0)
									a_dados.vetorSubmercado.at(idSubmercado_ande).setMatriz(AttMatrizSubmercado_demanda, matriz_zero);

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.getElemento(idEstagio_inicial)) {

												int passo = (int(idPatamarCarga_DECK) - 1) * 35;
												// GERAÇÃO ITAIPU 60 HZ
												a_dados.vetorIntercambio.at(idIntercambio_itaipu_iv).setElemento(AttMatrizIntercambio_potencia_minima, periodo, idPatamarCarga, std::stod(line.substr(passo + 16, 7)));
												a_dados.vetorIntercambio.at(idIntercambio_itaipu_iv).setElemento(AttMatrizIntercambio_potencia_maxima, periodo, idPatamarCarga, std::stod(line.substr(passo + 24, 7)));

												// GERAÇÃO ITAIPU 50 HZ
												a_dados.vetorIntercambio.at(idIntercambio_itaipu_ande).setElemento(AttMatrizIntercambio_potencia_minima, periodo, idPatamarCarga, std::stod(line.substr(passo + 30, 7)));
												a_dados.vetorIntercambio.at(idIntercambio_itaipu_ande).setElemento(AttMatrizIntercambio_potencia_maxima, periodo, idPatamarCarga, std::stod(line.substr(passo + 37, 7)));

												// CARGA ANDE
												a_dados.vetorSubmercado.at(idSubmercado_ande).setElemento(AttMatrizSubmercado_demanda, periodo, idPatamarCarga, std::stod(line.substr(passo + 44, 7)));
												
											}//if (periodo >= horizonte_otimizacao_DC.getElemento(idEstagio_inicial)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//else if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro RI: \n" + std::string(erro.what())); }

					}//if (menemonico == "RI") 

					if (menemonico == "IT") {// Restrição de geração de Itaipu_50 Hz e carga da ANDE

						try {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Identificação do estágio. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_Itaipu = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Índice da usina de Itaipu ( conforme campo 2 dos registros UH).
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int hidreletrica_codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, hidreletrica_codigo_usina);

							IdHidreletrica idHidreletrica = idHidreletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Índice do subsistema que representa o Sudeste.   
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina_conexo_ANDE = atoi(atributo.c_str()); //codigo_usina_conexo_ANDE -> Sudeste

							////////////////////////////////////////

							int numero_patamares = 0;

							//Vetores com informação por patamar
							std::vector<double> itaipu_50Hz_potencia;
							std::vector<double> itaipu_carga_ANDE;

							const int line_size = int(line.length());

							if (line_size >= 29) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 5 - Geração de Itaipu_50 Hz, em MWmed, no patamar 1.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(19, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								itaipu_50Hz_potencia.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 6 - Carga da Ande, em MWmed, no patamar 1.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(24, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								itaipu_carga_ANDE.push_back(atof(atributo.c_str()));

							}//if (line_size >= 29) {

							if (line_size >= 39) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 6 - Geração de Itaipu_50 Hz, em MWmed, no patamar 2.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(29, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								itaipu_50Hz_potencia.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 7 - Carga da Ande, em MWmed, no patamar 2.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(34, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								itaipu_carga_ANDE.push_back(atof(atributo.c_str()));

							}//if (line_size >= 39) {

							if (line_size >= 49) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 8 - Geração de Itaipu_50 Hz, em MWmed, no patamar 3.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(39, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								itaipu_50Hz_potencia.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 9 - Carga da Ande, em MWmed, no patamar 3.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(44, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								itaipu_carga_ANDE.push_back(atof(atributo.c_str()));

							}//if (line_size >= 49) {

							if (line_size >= 59) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 10 - Geração de Itaipu_50 Hz, em MWmed, no patamar 4.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(49, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								itaipu_50Hz_potencia.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 11 - Carga da Ande, em MWmed, no patamar 4.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(54, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								itaipu_carga_ANDE.push_back(atof(atributo.c_str()));

							}//if (line_size >= 59) {

							if (line_size >= 69) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 12 - Geração de Itaipu_50 Hz, em MWmed, no patamar 5.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(59, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								itaipu_50Hz_potencia.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 13 - Carga da Ande, em MWmed, no patamar 5.
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(64, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								itaipu_carga_ANDE.push_back(atof(atributo.c_str()));

							}//if (line_size >= 69) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_conjunto) {

								IdConjuntoHidraulico idConjuntoHidraulico;

								//*********************************
								//Submercado ANDE
								//*********************************

								const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_ANDE);

								if (idEstagio_Itaipu == IdEstagio_1) {

									///////////////////////////////////
									//Itaipu_50Hz_potencia
									///////////////////////////////////

									if (!a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.isInstanciado(IdConjuntoHidraulico_1)) {

										ConjuntoHidraulico conjuntoHidraulico;
										conjuntoHidraulico.setAtributo(AttComumConjuntoHidraulico_idConjuntoHidraulico, IdConjuntoHidraulico_1);//Itaipu_50Hz é definido como IdConjuntoHidraulico_1 da usina Itaipu

										a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.add(conjuntoHidraulico);

									}//if (!a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.isInstanciado(IdConjuntoHidraulico_1)) {

									///////////////////////////////////

									const string nome = "itaipu_50";

									a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_1).setAtributo(AttComumConjuntoHidraulico_nome, nome);
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_1).setAtributo(AttComumConjuntoHidraulico_submercado, idSubmercado); //O conjunto hidráulico Itaipú 50 Hz é associado ao submercado ANDE


									/////////////////////////////////////

									SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
										matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									/////////////////////////////////////

									a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_1).setMatriz(AttMatrizConjuntoHidraulico_potencia_minima, matriz_zero);
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(IdConjuntoHidraulico_1).setMatriz(AttMatrizConjuntoHidraulico_potencia_maxima, matriz_zero);

									///////////////////////////////////
									//Carga_ANDE
									//////////////////////////////////
									a_dados.vetorSubmercado.at(idSubmercado).setMatriz(AttMatrizSubmercado_demanda, matriz_zero);

								}//if (idEstagio_Itaipu == IdEstagio_1) { 
								

								idConjuntoHidraulico = IdConjuntoHidraulico_1; //Itaipu_50Hz é definido como IdConjuntoHidraulico_1 da usina Itaipu

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_Itaipu)) {

												//Itaipu_50Hz_potencia

												a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(idConjuntoHidraulico).setElemento(AttMatrizConjuntoHidraulico_potencia_minima, periodo, idPatamarCarga, itaipu_50Hz_potencia.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
												a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.at(idConjuntoHidraulico).setElemento(AttMatrizConjuntoHidraulico_potencia_maxima, periodo, idPatamarCarga, itaipu_50Hz_potencia.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

												//Carga_ANDE

												a_dados.vetorSubmercado.at(idSubmercado).setElemento(AttMatrizSubmercado_demanda, periodo, idPatamarCarga, itaipu_carga_ANDE.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

											}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_Itaipu)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								
							}//if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_conjunto) {
							else if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina) {

								//Na representaçao por usina de Itaipú os limites do intercambio Itaipú->Ande sao atualizados

								const IdSubmercado idSubmercado_origem = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_submercado_ITAIPU);
								const IdSubmercado idSubmercado_destino = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_ANDE);

								std::vector<IdIntercambio> idIntercambio_inicializado = a_dados.vetorIntercambio.getIdObjetos(AttComumIntercambio_submercado_origem, idSubmercado_origem);

								int idIntercambio_inicializado_size = int(idIntercambio_inicializado.size());

								IdIntercambio idIntercambio = IdIntercambio_Nenhum;

								for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

									if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {
										idIntercambio = idIntercambio_inicializado.at(intercambio_inicializado);
										break;
									}//if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {

								}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

								if (idIntercambio == IdIntercambio_Nenhum)
									throw std::invalid_argument("Registro IT - Intercambio nao encontrado");

								if (idEstagio_Itaipu == IdEstagio_1) {

									///////////////////////////////////
									//Itaipu_50Hz_potencia
									///////////////////////////////////

									/////////////////////////////////////

									SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
										matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									/////////////////////////////////////

									a_dados.vetorIntercambio.at(idIntercambio).setMatriz(AttMatrizIntercambio_potencia_minima, matriz_zero);
									a_dados.vetorIntercambio.at(idIntercambio).setMatriz(AttMatrizIntercambio_potencia_maxima, matriz_zero);


									///////////////////////////////////
									//Carga_ANDE
									//////////////////////////////////

									a_dados.vetorSubmercado.at(idSubmercado_destino).setMatriz(AttMatrizSubmercado_demanda, matriz_zero);

								}//if (idEstagio_Itaipu == IdEstagio_1) { 
								

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_Itaipu)) {

												//Itaipu_50Hz_potencia

												a_dados.vetorIntercambio.at(idIntercambio).setElemento(AttMatrizIntercambio_potencia_minima, periodo, idPatamarCarga, itaipu_50Hz_potencia.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
												a_dados.vetorIntercambio.at(idIntercambio).setElemento(AttMatrizIntercambio_potencia_maxima, periodo, idPatamarCarga, itaipu_50Hz_potencia.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

												//Carga_ANDE

												a_dados.vetorSubmercado.at(idSubmercado_destino).setElemento(AttMatrizSubmercado_demanda, periodo, idPatamarCarga, itaipu_carga_ANDE.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

											}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_Itaipu)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							
							}//else if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro UH: \n" + std::string(erro.what())); }

					}//if (menemonico == "IT") {

					if (menemonico == "IA") {//Limite de fluxo entre subsistemas 

						try {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Identificação do estágio.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_intercambio = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Mnemônico de identificação do subsistema I (conforme campo do 3 do registro SB).  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string mnemonico_submercado_origem = atributo;

							//Identifica se algum intercambio tem sido inicializada com submercado_origem
							const IdSubmercado idSubmercado_origem_inicializado = getIdSubmercadoFromMnemonico(mnemonico_submercado_origem);

							IdSubmercado idSubmercado_origem;

							if (idSubmercado_origem_inicializado != IdSubmercado_Nenhum)
								idSubmercado_origem = idSubmercado_origem_inicializado;
							else
								throw std::invalid_argument("Registro IA - Submercado nao encontrado com menemonico_" + mnemonico_submercado_origem);


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Mnemônico de identificação do subsistema J (conforme campo do 3 do registro SB).  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string mnemonico_submercado_destino = atributo;

							//Identifica se algum intercambio tem sido inicializada com submercado_origem
							const IdSubmercado idSubmercado_destino_inicializado = getIdSubmercadoFromMnemonico(mnemonico_submercado_destino);

							IdSubmercado idSubmercado_destino;

							if (idSubmercado_destino_inicializado != IdSubmercado_Nenhum)
								idSubmercado_destino = idSubmercado_destino_inicializado;
							else
								throw std::invalid_argument("Registro IA - Submercado nao encontrado com menemonico_" + mnemonico_submercado_destino);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Flag indicador de penalidade: flag=0 (default) indica uso de penalidade;  (flag=1) indica penalidade nula 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(17, 1);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							int flag_penalidade = 0; //Default - Uso de penalidade

							if (atributo == "1")
								flag_penalidade = 1;

							////////////////////////////////////////

							int numero_patamares = 0;

							//Vetores com informação por patamar
							std::vector<double> intercambio_capacidade_maxima_submercado_origem;
							std::vector<double> intercambio_capacidade_maxima_submercado_destino;

							const int line_size = int(line.length());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campos 6 - 7
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (line_size >= 39) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 6 - Capacidade máxima de transporte do subsistema  I para o subsistema J em MWmed no patamar 1. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(19, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								intercambio_capacidade_maxima_submercado_origem.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 7 - Capacidade máxima de transporte do subsistema  J para o subsistema I em MWmed no patamar 1.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(29, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								intercambio_capacidade_maxima_submercado_destino.push_back(atof(atributo.c_str()));

							}//if (line_size >= 49) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campos 8 - 9
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (line_size >= 59) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 8 - Capacidade máxima de transporte do subsistema  I para o subsistema J em MWmed no patamar 2. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(39, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								intercambio_capacidade_maxima_submercado_origem.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 9 - Capacidade máxima de transporte do subsistema  J para o subsistema I em MWmed no patamar 2.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(49, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								intercambio_capacidade_maxima_submercado_destino.push_back(atof(atributo.c_str()));

							}//if (line_size >= 59) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campos 10 - 11
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (line_size >= 79) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 10 - Capacidade máxima de transporte do subsistema  I para o subsistema J em MWmed no patamar 3. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(59, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								intercambio_capacidade_maxima_submercado_origem.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 11 - Capacidade máxima de transporte do subsistema  J para o subsistema I em MWmed no patamar 3.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(69, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								intercambio_capacidade_maxima_submercado_destino.push_back(atof(atributo.c_str()));

							}//if (line_size >= 79) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campos 12 - 13
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (line_size >= 99) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 12 - Capacidade máxima de transporte do subsistema  I para o subsistema J em MWmed no patamar 4. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(79, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								intercambio_capacidade_maxima_submercado_origem.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 13 - Capacidade máxima de transporte do subsistema  J para o subsistema I em MWmed no patamar 4.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(89, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								intercambio_capacidade_maxima_submercado_destino.push_back(atof(atributo.c_str()));

							}//if (line_size >= 99) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campos 14 - 15
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (line_size >= 119) {

								numero_patamares++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 14 - Capacidade máxima de transporte do subsistema  I para o subsistema J em MWmed no patamar 5. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(99, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								intercambio_capacidade_maxima_submercado_origem.push_back(atof(atributo.c_str()));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 15 - Capacidade máxima de transporte do subsistema  J para o subsistema I em MWmed no patamar 5.  
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(109, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								intercambio_capacidade_maxima_submercado_destino.push_back(atof(atributo.c_str()));

							}//if (line_size >= 119) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							//Nota: //Cada linha lida tem dois intercâmbios: (i) DE->PARA (ii) PARA->DE
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							IdIntercambio idIntercambio;

							if (idEstagio_intercambio == IdEstagio_1) {

								//////////////////////////////////////////////////////////////////////////
								//Identifica se o Intercambio está inicializado
								//////////////////////////////////////////////////////////////////////////

								std::vector<IdIntercambio> idIntercambio_inicializado = a_dados.vetorIntercambio.getIdObjetos(AttComumIntercambio_submercado_origem, idSubmercado_origem);

								int idIntercambio_inicializado_size = int(idIntercambio_inicializado.size());

								idIntercambio = IdIntercambio_Nenhum;

								for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

									if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {
										idIntercambio = idIntercambio_inicializado.at(intercambio_inicializado);
										break;
									}//if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {

								}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

								//////////////////////////////////////////////////////////////////////////

								/////////////////////////////////////

								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								/////////////////////////////////////


								if (idIntercambio == IdIntercambio_Nenhum) {//Inicializa um novo intercambio

									Intercambio intercambio;

									//////////////////////////////
									//Intercâmbio 1
									//////////////////////////////

									idIntercambio = a_dados.getMaiorId(IdIntercambio());

									if (idIntercambio == IdIntercambio_Nenhum)
										idIntercambio = IdIntercambio_1;
									else
										idIntercambio++;

									intercambio.setAtributo(AttComumIntercambio_idIntercambio, idIntercambio);
									intercambio.setAtributo(AttComumIntercambio_submercado_origem, idSubmercado_origem);
									intercambio.setAtributo(AttComumIntercambio_submercado_destino, idSubmercado_destino);
									intercambio.setAtributo(AttComumIntercambio_nome, mnemonico_submercado_origem + "->" + mnemonico_submercado_destino);

									intercambio.setMatriz(AttMatrizIntercambio_potencia_maxima, matriz_zero);
									intercambio.setMatriz(AttMatrizIntercambio_potencia_minima, matriz_zero);

									a_dados.vetorIntercambio.add(intercambio);

									//////////////////////////////
									//Intercâmbio 2
									//////////////////////////////

									idIntercambio++;
									intercambio.setAtributo(AttComumIntercambio_idIntercambio, idIntercambio);
									intercambio.setAtributo(AttComumIntercambio_submercado_origem, idSubmercado_destino); //No intercâmbio 2, o destino é o origen
									intercambio.setAtributo(AttComumIntercambio_submercado_destino, idSubmercado_origem); //No intercâmbio 2, o origem é o destino
									intercambio.setAtributo(AttComumIntercambio_nome, mnemonico_submercado_destino + "->" + mnemonico_submercado_origem);

									intercambio.setMatriz(AttMatrizIntercambio_potencia_maxima, matriz_zero);
									intercambio.setMatriz(AttMatrizIntercambio_potencia_minima, matriz_zero);

									a_dados.vetorIntercambio.add(intercambio);

								}//if (idIntercambio == IdIntercambio_Nenhum) {
								else {//Alguns intercambios referentes a IVAPORÃ e ANDE são inicializados de antemão

									if(a_dados.vetorIntercambio.at(idIntercambio).getSizeMatriz(AttMatrizIntercambio_potencia_maxima) == 0)
										a_dados.vetorIntercambio.at(idIntercambio).setMatriz(AttMatrizIntercambio_potencia_maxima, matriz_zero);

									if (a_dados.vetorIntercambio.at(idIntercambio).getSizeMatriz(AttMatrizIntercambio_potencia_minima) == 0)
										a_dados.vetorIntercambio.at(idIntercambio).setMatriz(AttMatrizIntercambio_potencia_minima, matriz_zero);

									////////////////////////////////////////////////
									//Determina o idIntercambio do Intercâmbio 2
									////////////////////////////////////////////////

									std::vector<IdIntercambio> idIntercambio_inicializado = a_dados.vetorIntercambio.getIdObjetos(AttComumIntercambio_submercado_origem, idSubmercado_destino);

									int idIntercambio_inicializado_size = int(idIntercambio_inicializado.size());

									idIntercambio = IdIntercambio_Nenhum;

									for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

										if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_origem) {
											idIntercambio = idIntercambio_inicializado.at(intercambio_inicializado);
											break;
										}//if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {

									}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

									if (idIntercambio == IdIntercambio_Nenhum)
										throw std::invalid_argument("Registro IA - Intercambio nao encontrado com idSubmercado_origem_" + getString(idSubmercado_destino) + " e idSubmercado_destino_" + getString(idSubmercado_origem));


									if (a_dados.vetorIntercambio.at(idIntercambio).getSizeMatriz(AttMatrizIntercambio_potencia_maxima) == 0)
										a_dados.vetorIntercambio.at(idIntercambio).setMatriz(AttMatrizIntercambio_potencia_maxima, matriz_zero);

									if (a_dados.vetorIntercambio.at(idIntercambio).getSizeMatriz(AttMatrizIntercambio_potencia_minima) == 0)
										a_dados.vetorIntercambio.at(idIntercambio).setMatriz(AttMatrizIntercambio_potencia_minima, matriz_zero);

								}//else {

							}//if (idEstagio_intercambio == IdEstagio_1) {

							//////////////////////////////
							//Intercâmbio 1
							//////////////////////////////

							std::vector<IdIntercambio> idIntercambio_inicializado = a_dados.vetorIntercambio.getIdObjetos(AttComumIntercambio_submercado_origem, idSubmercado_origem);

							int idIntercambio_inicializado_size = int(idIntercambio_inicializado.size());

							for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

								idIntercambio = idIntercambio_inicializado.at(intercambio_inicializado);

								if (a_dados.getAtributo(idIntercambio, AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino)
									break;

							}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_intercambio)) {

											a_dados.vetorIntercambio.at(idIntercambio).setElemento(AttMatrizIntercambio_potencia_maxima, periodo, idPatamarCarga, intercambio_capacidade_maxima_submercado_origem.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

										}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_intercambio)) {

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							//////////////////////////////
							//Intercâmbio 2
							//////////////////////////////

							idIntercambio_inicializado = a_dados.vetorIntercambio.getIdObjetos(AttComumIntercambio_submercado_origem, idSubmercado_destino); //No intercâmbio 2, o destino é o origen

							idIntercambio_inicializado_size = int(idIntercambio_inicializado.size());

							for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

								idIntercambio = idIntercambio_inicializado.at(intercambio_inicializado);

								if (a_dados.vetorIntercambio.at(idIntercambio).getAtributo(AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_origem)
									break;

							}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_intercambio)) {

											a_dados.vetorIntercambio.at(idIntercambio).setElemento(AttMatrizIntercambio_potencia_maxima, periodo, idPatamarCarga, intercambio_capacidade_maxima_submercado_destino.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

										}//if (horizonte_estudo.at(periodo) >= idEstagio_termeletrica) {

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro IA: \n" + std::string(erro.what())); }

					}//if (menemonico == "IA") {

					if (menemonico == "TX") {

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Taxa nominal de desconto anual em percentagem (default = 10.0) 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 5);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							double taxa_desconto_anual;

							if (atributo == "")
								taxa_desconto_anual = 10; //Default
							else
								taxa_desconto_anual = atof(atributo.c_str()) / 100;

							if (!dadosPreConfig_instanciados)
								a_dados.setAtributo(AttComumDados_taxa_desconto_anual, taxa_desconto_anual);

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro TX: \n" + std::string(erro.what())); }

					}//if (menemonico == "TX") {

					if (menemonico == "PE") {//Penalidades

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Campo 2 -  Índice de identificação do subsistema.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdSubmercado idSubmercado = getIdSubmercadoFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(8, 1);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							if (atributo == "1") {//Se o valor informado for igual a 0, a penalidade informada no campo 4 será para vertimento. 
								//Vertimento

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(9, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const double valor = atof(atributo.c_str());

								const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
								const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

								for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {
									if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.numObjetos() > 0) {
										if (a_dados.getAtributo(idHidreletrica, IdConjuntoHidraulico_1, AttComumConjuntoHidraulico_submercado, IdSubmercado()) == idSubmercado)
											a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_penalidade_vertimento, valor);
									}
								}

							}//if (atributo == "1") {
							else if (atributo == "2") {//Se o valor informado for igual a 1, a penalidade informada no campo 4 será o valor base para todos os intercâmbios e a informação descrita do campo 2 não será considerada
								//Intercambios

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(9, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const double valor = atof(atributo.c_str());

								for (IdIntercambio idIntercambio = IdIntercambio_1; idIntercambio <= a_dados.getMaiorId(IdIntercambio()); idIntercambio++)
									a_dados.vetorIntercambio.at(idIntercambio).setAtributo(AttComumIntercambio_penalidade_intercambio, valor);

							}//else if (atributo == "2") {
							else if (atributo == "3") {//Se o valor informado for igual a 2, a penalidade informada no campo 4 será o valor base para todos os desvios de água e a informação descrita do campo 2 não será considerada. 
								//Desvio água

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(9, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const double valor = atof(atributo.c_str());

								const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
								const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

								for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {
									if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorConjuntoHidraulico.numObjetos() > 0) {
										if (a_dados.getAtributo(idHidreletrica, IdConjuntoHidraulico_1, AttComumConjuntoHidraulico_submercado, IdSubmercado()) == idSubmercado)
											a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_penalidade_desvio_agua, valor);
									}
								}

							}//else if (atributo == "3") {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro PE: \n" + std::string(erro.what())); }

					}//if (menemonico == "PE") {

					if (menemonico == "GP") {//TOLERANCIA PARA CONVERGENCIA

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Taxa nominal de desconto anual em percentagem (default = 10.0) 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							double tolerancia_convergencia;
												if (atributo == "")
								tolerancia_convergencia = 0.00001; //Default
							else
								tolerancia_convergencia = atof(atributo.c_str()) / 100;

							if (!dadosPreConfig_instanciados) {
								a_dados.setAtributo(AttComumDados_tolerancia_convergencia, tolerancia_convergencia * 0.01);
								a_dados.setAtributo(AttComumDados_tipo_convergencia, TipoConvergencia_gap);
							}

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro GP: \n" + std::string(erro.what())); }

					}//if (menemonico == "GP") {

					if (menemonico == "NI") {//TOTAL DE ITERACOES

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Campo 2 -  Número de iterações.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							int numero_iteracoes;

							if (atributo == "")
								numero_iteracoes = 500; //Default
							else
								numero_iteracoes = atoi(atributo.c_str());

							const int line_size = int(line.length());

							bool numero_iteracoes_maxima = true;

							if (line_size >= 9) {

								atributo = line.substr(9, 1);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (atoi(atributo.c_str()) == 1)
									numero_iteracoes_maxima = false;

							}//if (line_size >= 9) {

							if (!dadosPreConfig_instanciados) {

								if (numero_iteracoes_maxima == true)
									a_dados.setAtributo(AttComumDados_numero_maximo_iteracoes, numero_iteracoes);
								else if (numero_iteracoes_maxima == false) {
									a_dados.setAtributo(AttComumDados_numero_maximo_iteracoes, 500); //Default
								}//else if (numero_iteracoes_maxima == false) {

							}//if (!dadosPreConfig_instanciados) {


						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro NI: \n" + std::string(erro.what())); }

					}//if (menemonico == "NI") {

					if (menemonico == "DT") {//DATA DE REFERENCIA Do ESTUDO

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Dia (default: dia do sistema). 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int dia = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Mês (default: mês do sistema). 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int mes = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Ano (default: ano do sistema).
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 4);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int ano = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Verifica respeito à data encontrada no arquivo VAZOES
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							Periodo data_reportada_DADGER(dia, mes, ano);

							//if (data_reportada_DADGER != Periodo(TipoPeriodo_diario, horizonte_estudo.getIteradorInicial()))
								//throw std::invalid_argument("Registro DT - Data nao coincidente com os estagios gerados a partir do arquivo VAZOES.RVX");

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro DT: \n" + std::string(erro.what())); }

					}//if (menemonico == "DT") {

					if (menemonico == "MP") {//MANUTENCOES PROGRAMADAS HIDRAULICAS

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina conforme campo 2 dos registros UH. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							const IdHidreletrica idHidreletrica = idHidreletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3-19 -  Fatores de manutenção para os N estágios em p.u. //i.e., 5 colunas/campo
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							//Nota: O deck registra os valores de disponiblidade associados à manutenção. No SPT é ingressado como uma 
							//indisponibilidade (1- disponibilidadeManutenção) e logo nas validações é calculada a disponiblidade em conjunto com a indisponibilidade forçada

							std::vector<double> indisponibilidade_programada;

							const int line_size = int(line.length());

							const int numeroEstagios = horizonte_otimizacao_DC.size();

							for (int estagio = 0; estagio < numeroEstagios; estagio++) {

								if (line_size >= 14 + 5 * estagio) {

									atributo = line.substr(9 + 5 * estagio, 5);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									if (atributo == "")
										indisponibilidade_programada.push_back(0);//Default
									else
										indisponibilidade_programada.push_back(1 - atof(atributo.c_str()));
								}//if (line_size >= 14 + 5 * estagio) {
								else //Condição que prevee se o último estágio é deixado vazio no DECK
									indisponibilidade_programada.push_back(0);//Default

							}//for (int estagio = 0; estagio < numeroEstagios; estagio++) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elemtentos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							SmartEnupla<Periodo, double> vetor_indisponibilidade_programada(horizonte_estudo, 1.0); //Valor default

							for (int estagio = 0; estagio < numeroEstagios; estagio++) {

								const IdEstagio idEstagio_manutencao = IdEstagio(estagio + 1);

								const double valor = indisponibilidade_programada.at(estagio);

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									//Atualiza a informação unicamente para o estágio DC indicado

									if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_manutencao) {

										//Se é último estágio DC, o periodo deve ser maior ou igual ao estágio DC

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_manutencao))
											vetor_indisponibilidade_programada.setElemento(periodo, valor);

									}//if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_manutencao) {
									else {

										//Se não é último estágio DC, o periodo deve ser entre dois estágios DC consecutivos

										const IdEstagio idEstagio_manutencao_seguinte = IdEstagio(idEstagio_manutencao + 1);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_manutencao) && periodo < horizonte_otimizacao_DC.at(idEstagio_manutencao_seguinte))
											vetor_indisponibilidade_programada.setElemento(periodo, valor);

										else if (periodo >= horizonte_otimizacao_DC.at(idEstagio_manutencao_seguinte))
											break; //Evita percorrer todo o horizonte_estudo

									}//else {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//for (int estagio = 0; estagio < numeroEstagios; estagio++) {

							/////////////////////////////////////////////////////////////////////////////
							//Procura se é um registro de um conjunto hidráulico de IT, codigo_usina = 66

							atributo = line.substr(7, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							if (codigo_usina == 66 && atributo != "" && a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(AttVetorHidreletrica_indisponibilidade_programada) > 0) {

								const SmartEnupla<Periodo, double> vetor_indisponibilidade_programada_anterior = a_dados.vetorHidreletrica.at(idHidreletrica).getVetor(AttVetorHidreletrica_indisponibilidade_programada, Periodo(), double());

								const Periodo periodo_inicial = vetor_indisponibilidade_programada_anterior.getIteradorInicial();
								const Periodo periodo_final = vetor_indisponibilidade_programada_anterior.getIteradorFinal();

								for (Periodo periodo = periodo_inicial; periodo <= periodo_final; vetor_indisponibilidade_programada_anterior.incrementarIterador(periodo)) {

									const double indisponibilidade_programada_nova = 0.5 * (vetor_indisponibilidade_programada_anterior.getElemento(periodo) + vetor_indisponibilidade_programada.getElemento(periodo));

									a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_indisponibilidade_programada, periodo, indisponibilidade_programada_nova);

								}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; vetor_indisponibilidade_programada_anterior.incrementarIterador(periodo)) {

							}//if (codigo_usina == 66 && atributo != "" && a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(AttVetorHidreletrica_indisponibilidade_programada) > 0) {
							else
								a_dados.vetorHidreletrica.at(idHidreletrica).setVetor(AttVetorHidreletrica_indisponibilidade_programada, vetor_indisponibilidade_programada);

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro MP: \n" + std::string(erro.what())); }

					}//if (menemonico == "MP") {

					if (menemonico == "MT") {//MANUTENCAO PROGRAMADA DE USINAS TERMICAS

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina conforme campo 2 dos registros CT. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							const IdTermeletrica idTermeletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_termeletrica, codigo_usina);

							if (idTermeletrica_inicializado == IdTermeletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idTermeletrica com codigo_usina_" + atributo);

							const IdTermeletrica idTermeletrica = idTermeletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Índice do subsistema ao qual pertence a usina térmica.  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int submercado_codigo_usina = atoi(atributo.c_str()); //dado que não se precisa, já foi carregado no reistro CT

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4-20 -  Fatores de manutenção para os N estágios em p.u. //i.e., 5 colunas/campo
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							//Nota: O deck registra os valores de disponiblidade associados à manutenção. No SPT é ingressado como uma 
							//indisponibilidade (1- disponibilidadeManutenção) e logo nas validações é calculada a disponiblidade em conjunto com a indisponibilidade forçada

							std::vector<double> indisponibilidade_programada;

							const int line_size = int(line.length());

							const int numeroEstagios = horizonte_otimizacao_DC.size();

							for (int estagio = 0; estagio < numeroEstagios; estagio++) {

								if (line_size >= 19 + 5 * estagio) {

									atributo = line.substr(14 + 5 * estagio, 5);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									if (atributo == "")
										indisponibilidade_programada.push_back(0);//Default
									else
										indisponibilidade_programada.push_back(1 - atof(atributo.c_str()));
								}//if (line_size >= 19 + 5 * estagio) {
								else //Condição que prevee se o último estágio é deixado vazio no DECK
									indisponibilidade_programada.push_back(0);//Default

							}//for (int estagio = 0; estagio < numeroEstagios; estagio++) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elemtentos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							SmartEnupla<Periodo, double> vetor_indisponibilidade_programada(horizonte_estudo, 1.0); //Valor default

							for (int estagio = 0; estagio < numeroEstagios; estagio++) {

								const IdEstagio idEstagio_manutencao = IdEstagio(estagio + 1);

								const double valor = indisponibilidade_programada.at(estagio);

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									//Atualiza a informação unicamente para o estágio DC indicado

									if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_manutencao) {

										//Se é último estágio DC, o periodo deve ser maior ou igual ao estágio DC

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_manutencao))
											vetor_indisponibilidade_programada.setElemento(periodo, valor);

									}//if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_manutencao) {
									else {

										//Se não é último estágio DC, o periodo deve ser entre dois estágios DC consecutivos

										const IdEstagio idEstagio_manutencao_seguinte = IdEstagio(idEstagio_manutencao + 1);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_manutencao) && periodo < horizonte_otimizacao_DC.at(idEstagio_manutencao_seguinte))
											vetor_indisponibilidade_programada.setElemento(periodo, valor);

										else if (periodo >= horizonte_otimizacao_DC.at(idEstagio_manutencao_seguinte))
											break; //Evita percorrer todo o horizonte_estudo

									}//else {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//for (int estagio = 0; estagio < numeroEstagios; estagio++) {

							a_dados.vetorTermeletrica.at(idTermeletrica).setVetor(AttVetorTermeletrica_indisponibilidade_programada, vetor_indisponibilidade_programada);

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro MT: \n" + std::string(erro.what())); }

					}//if (menemonico == "MT") {

					if (menemonico == "FD") {//FATOR DE DISPONIBILIDADE DE USINAS HIDRAULICAS

						try {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina conforme campo 2 dos registros UH. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							const IdHidreletrica idHidreletrica = idHidreletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3-19 -  Fatores de manutenção para os N estágios em p.u. //i.e., 5 colunas/campo
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							std::vector<double> indisponibilidade_forcada;

							const int line_size = int(line.length());

							const int numeroEstagios = horizonte_otimizacao_DC.size();

							for (int estagio = 0; estagio < numeroEstagios; estagio++) {

								if (line_size >= 14 + 5 * estagio) {

									atributo = line.substr(9 + 5 * estagio, 5);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									if (atributo == "")
										indisponibilidade_forcada.push_back(0);//Default
									else
										indisponibilidade_forcada.push_back(1 - atof(atributo.c_str()));
								}//if (line_size >= 14 + 5 * estagio) {
								else //Condição que prevee se o último estágio é deixado vazio no DECK
									indisponibilidade_forcada.push_back(0);//Default

							}//for (int estagio = 0; estagio < numeroEstagios; estagio++) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elemtentos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							SmartEnupla<Periodo, double> vetor_indisponibilidade_forcada(horizonte_estudo, 1.0); //Valor default

							for (int estagio = 0; estagio < numeroEstagios; estagio++) {

								const IdEstagio idEstagio_manutencao = IdEstagio(estagio + 1);

								const double valor = indisponibilidade_forcada.at(estagio);

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									//Atualiza a informação unicamente para o estágio DC indicado

									if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_manutencao) {

										//Se é último estágio DC, o periodo deve ser maior ou igual ao estágio DC

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_manutencao))
											vetor_indisponibilidade_forcada.setElemento(periodo, valor);

									}//if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_manutencao) {
									else {

										//Se não é último estágio DC, o periodo deve ser entre dois estágios DC consecutivos

										const IdEstagio idEstagio_manutencao_seguinte = IdEstagio(idEstagio_manutencao + 1);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_manutencao) && periodo < horizonte_otimizacao_DC.at(idEstagio_manutencao_seguinte))
											vetor_indisponibilidade_forcada.setElemento(periodo, valor);

										else if (periodo >= horizonte_otimizacao_DC.at(idEstagio_manutencao_seguinte))
											break; //Evita percorrer todo o horizonte_estudo

									}//else {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//for (int estagio = 0; estagio < numeroEstagios; estagio++) {


							/////////////////////////////////////////////////////////////////////////////
							//Procura se é um registro de um conjunto hidráulico de IT, codigo_usina = 66

							atributo = line.substr(7, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							if (codigo_usina == 66 && atributo != "" && a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(AttVetorHidreletrica_indisponibilidade_forcada) > 0) {

								const SmartEnupla<Periodo, double> vetor_indisponibilidade_forcada_anterior = a_dados.vetorHidreletrica.at(idHidreletrica).getVetor(AttVetorHidreletrica_indisponibilidade_forcada, Periodo(), double());

								const Periodo periodo_inicial = vetor_indisponibilidade_forcada_anterior.getIteradorInicial();
								const Periodo periodo_final = vetor_indisponibilidade_forcada_anterior.getIteradorFinal();

								for (Periodo periodo = periodo_inicial; periodo <= periodo_final; vetor_indisponibilidade_forcada_anterior.incrementarIterador(periodo)) {

									const double indisponibilidade_forcada_nova = 0.5 * (vetor_indisponibilidade_forcada_anterior.getElemento(periodo) + vetor_indisponibilidade_forcada.getElemento(periodo));

									a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_indisponibilidade_forcada, periodo, indisponibilidade_forcada_nova);

								}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; vetor_indisponibilidade_forcada_anterior.incrementarIterador(periodo)) {

							}//if (codigo_usina == 66 && atributo != "" && a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(AttVetorHidreletrica_indisponibilidade_forcada) > 0) {
							else
								a_dados.vetorHidreletrica.at(idHidreletrica).setVetor(AttVetorHidreletrica_indisponibilidade_forcada, vetor_indisponibilidade_forcada);

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro FD: \n" + std::string(erro.what())); }

					}//if (menemonico == "FD") {

					if (menemonico == "VE") {//VOLUME DE ESPERA

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina hidráulica com reservatório conforme campo 2 dos registros UH
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							const IdHidreletrica idHidreletrica = idHidreletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3-19 -  Volume de espera em percentagem do volume útil para os N estágios.//i.e., 5 colunas/campo
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							std::vector<double> percentual_volume_util_maximo;

							const int line_size = int(line.length());

							const int numeroEstagios = horizonte_otimizacao_DC.size();

							for (int estagio = 0; estagio < numeroEstagios; estagio++) {

								if (line_size >= 14 + 5 * estagio) {

									atributo = line.substr(9 + 5 * estagio, 5);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									percentual_volume_util_maximo.push_back(atof(atributo.c_str()) / 100);

								}//if (line_size >= 14 + 5 * estagio) {

							}//for (int estagio = 0; estagio < numeroEstagios; estagio++) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elemtentos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							SmartEnupla<Periodo, double> vetor_percentual_volume_util_maximo(horizonte_estudo, 1.0); //Valor default

							for (int estagio = 0; estagio < numeroEstagios; estagio++) {

								const IdEstagio idEstagio_volume_espera = IdEstagio(estagio + 1);

								const double valor = percentual_volume_util_maximo.at(estagio);

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									//Atualiza a informação unicamente para o estágio DC indicado

									if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_volume_espera) {

										//Se é último estágio DC, o periodo deve ser maior ou igual ao estágio DC

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_volume_espera))
											vetor_percentual_volume_util_maximo.setElemento(periodo, valor);

									}//if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_volume_espera) {
									else {

										//Se não é último estágio DC, o periodo deve ser entre dois estágios DC consecutivos

										const IdEstagio idEstagio_volume_espera_seguinte = IdEstagio(idEstagio_volume_espera + 1);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_volume_espera) && periodo < horizonte_otimizacao_DC.at(idEstagio_volume_espera_seguinte))
											vetor_percentual_volume_util_maximo.setElemento(periodo, valor);

										else if (periodo >= horizonte_otimizacao_DC.at(idEstagio_volume_espera_seguinte))
											break; //Evita percorrer todo o horizonte_estudo

									}//else {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//for (int estagio = 0; estagio < numeroEstagios; estagio++) {

							a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setVetor(AttVetorReservatorio_percentual_volume_util_maximo, vetor_percentual_volume_util_maximo);

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro VE: \n" + std::string(erro.what())); }

					}//if (menemonico == "VE") {

					if (menemonico == "VM") {//DADOS DE ENCHIMENTO DE VOLUME MORTO - TAXA DE ENCHIMENTO

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina hidráulica com reservatório conforme campo 2 dos registros UH
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							const IdHidreletrica idHidreletrica = idHidreletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3-19 -  Taxa de enchimento de volume morto em m3/s para cada estágio do estudo até a entrada em operação ou até o estágio final.//i.e., 5 colunas/campo
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////						

							const int line_size = int(line.length());

							const int numeroEstagios_DC = horizonte_otimizacao_DC.size();

							SmartEnupla<IdEstagio, double> enchimento_minimo_volume_morto;

							for (int estagio_DC = 0; estagio_DC < numeroEstagios_DC; estagio_DC++) {

								if (line_size >= 14 + 5 * estagio_DC) {

									atributo = line.substr(9 + 5 * estagio_DC, 5);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									enchimento_minimo_volume_morto.addElemento(IdEstagio(estagio_DC + 1), atof(atributo.c_str()) / 100);

								}//if (line_size >= 14 + 5 * estagio_DC) {

							}//for (int estagio_DC = 0; estagio_DC < numeroEstagios_DC; estagio_DC++) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elemtentos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							SmartEnupla<Periodo, double> vetor_enchimento_minimo_volume_morto(horizonte_estudo, 0);

							for (int estagio_DC = 0; estagio_DC < numeroEstagios_DC; estagio_DC++) {

								const IdEstagio idEstagio_enchimento_minimo_volume_morto = IdEstagio(estagio_DC + 1);

								const double valor = enchimento_minimo_volume_morto.getElemento(idEstagio_enchimento_minimo_volume_morto);

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									//Atualiza a informação unicamente para o estágio DC indicado

									if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_enchimento_minimo_volume_morto) {

										//Se é último estágio DC, o periodo deve ser maior ou igual ao estágio DC

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_enchimento_minimo_volume_morto))
											vetor_enchimento_minimo_volume_morto.setElemento(periodo, valor);

									}//if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_enchimento_minimo_volume_morto) {
									else {

										//Se não é último estágio DC, o periodo deve ser entre dois estágios DC consecutivos

										const IdEstagio idEstagio_enchimento_minimo_volume_morto_seguinte = IdEstagio(idEstagio_enchimento_minimo_volume_morto + 1);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_enchimento_minimo_volume_morto) && periodo < horizonte_otimizacao_DC.at(idEstagio_enchimento_minimo_volume_morto_seguinte))
											vetor_enchimento_minimo_volume_morto.setElemento(periodo, valor);

										else if (periodo >= horizonte_otimizacao_DC.at(idEstagio_enchimento_minimo_volume_morto_seguinte))
											break; //Evita percorrer todo o horizonte_estudo

									}//else {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//for (int estagio_DC = 0; estagio_DC < numeroEstagios_DC; estagio_DC++) {

							a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setVetor(AttVetorReservatorio_taxa_enchimento_volume_morto, vetor_enchimento_minimo_volume_morto);

							lista_hidreletrica_sem_capacidade.setElemento(idHidreletrica, true);

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro VM: \n" + std::string(erro.what())); }

					}//if (menemonico == "VM") {

					if (menemonico == "DF") {// Registro com taxa de defluência 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina hidráulica conforme campo 2 dos registros UH
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							const IdHidreletrica idHidreletrica = idHidreletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3-19 -  Taxa de enchimento de volume morto em m3/s para cada estágio do estudo até a entrada em operação ou até o estágio final.//i.e., 5 colunas/campo
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							const int line_size = int(line.length());

							const int numeroEstagios_DC = horizonte_otimizacao_DC.size();
							SmartEnupla<IdEstagio, double> defluencia_volume_morto;

							for (int estagio_DC = 0; estagio_DC < numeroEstagios_DC; estagio_DC++) {

								if (line_size >= 14 + 5 * estagio_DC) {

									atributo = line.substr(9 + 5 * estagio_DC, 5);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									defluencia_volume_morto.addElemento(IdEstagio(estagio_DC + 1), atof(atributo.c_str()) / 100);

								}//if (line_size >= 14 + 5 * estagio_DC) {

							}//for (int estagio_DC = 0; estagio_DC < numeroEstagios_DC; estagio_DC++) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							//Filosofia: Se o valor de defluência enchendo o volume morto é maior do que a defluência indicada no campo "UH", a defluência mínima é atualizada 

							for (int estagio_DC = 0; estagio_DC < numeroEstagios_DC; estagio_DC++) {

								const IdEstagio idEstagio_defluencia_volume_morto = IdEstagio(estagio_DC + 1);

								const double valor = defluencia_volume_morto.getElemento(idEstagio_defluencia_volume_morto);

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									//Atualiza a informação unicamente para o estágio DC indicado

									if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_defluencia_volume_morto) {

										//Se é último estágio DC, o periodo deve ser maior ou igual ao estágio DC

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_defluencia_volume_morto)) {

											if (a_dados.vetorHidreletrica.at(idHidreletrica).getElementoVetor(AttVetorHidreletrica_vazao_defluente_minima, periodo, double()) < valor)
												a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_vazao_defluente_minima, periodo, valor);

										}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_defluencia_volume_morto)) {

									}//if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_defluencia_volume_morto) {
									else {

										//Se não é último estágio DC, o periodo deve ser entre dois estágios DC consecutivos

										const IdEstagio idEstagio_defluencia_volume_morto_seguinte = IdEstagio(idEstagio_defluencia_volume_morto + 1);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_defluencia_volume_morto) && periodo < horizonte_otimizacao_DC.at(idEstagio_defluencia_volume_morto_seguinte)) {

											if (a_dados.vetorHidreletrica.at(idHidreletrica).getElementoVetor(AttVetorHidreletrica_vazao_defluente_minima, periodo, double()) < valor)
												a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_vazao_defluente_minima, periodo, valor);

										}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_defluencia_volume_morto) && periodo < horizonte_otimizacao_DC.at(idEstagio_defluencia_volume_morto_seguinte)) {

										else if (periodo >= horizonte_otimizacao_DC.at(idEstagio_defluencia_volume_morto_seguinte))
											break; //Evita percorrer todo o horizonte_estudo

									}//else {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//for (int estagio_DC = 0; estagio_DC < numeroEstagios_DC; estagio_DC++) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro DF: \n" + std::string(erro.what())); }

					}//if (menemonico == "DF") {

					if (menemonico == "RE") {//Identificação da restrição

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número de identificação da restrição elétrica
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 4);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string nome_restricao_eletrica = atributo;
							const int codigo_restricao_eletrica = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Estágio inicial da restrição. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (idEstagio_inicial == horizonte_estudo.at(periodo)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Estágio final da restrição.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_final = getIdEstagioFromChar(atributo.c_str());

							const IdEstagio idEstagio_final_horizonte_otimizacao_DC = horizonte_otimizacao_DC.getIteradorFinal();

							Periodo periodo_final;

							if (idEstagio_final == idEstagio_final_horizonte_otimizacao_DC) {

								periodo_final = horizonte_estudo.getIteradorFinal();

							}//if (idEstagio_final == idEstagio_final_horizonte_otimizacao_DC) {
							else {//Se não é o último estágio, precisa encontrar o último periodo referente ao idEstagio_final

								Periodo periodo = horizonte_estudo.getIteradorInicial();

								const IdEstagio idEstagio_final_seguinte = IdEstagio(idEstagio_final + 1);

								while (horizonte_otimizacao_DC.at(idEstagio_final_seguinte) > periodo) {

									horizonte_estudo.incrementarIterador(periodo);

								}//while (horizonte_otimizacao_DC.at(idEstagio_final) > periodo) {

								horizonte_estudo.decrementarIterador(periodo);

								periodo_final = periodo;

							}//else {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							RestricaoEletrica restricaoEletrica;

							const IdRestricaoEletrica idRestricaoEletrica = IdRestricaoEletrica(a_dados.getMaiorId(IdRestricaoEletrica()) + 1);

							restricaoEletrica.setAtributo(AttComumRestricaoEletrica_idRestricaoEletrica, idRestricaoEletrica);
							restricaoEletrica.setAtributo(AttComumRestricaoEletrica_nome, nome_restricao_eletrica);

							lista_codigo_ONS_restricao_eletrica.setElemento(idRestricaoEletrica, codigo_restricao_eletrica);

							lista_restricao_eletrica_periodo_inicial.setElemento(idRestricaoEletrica, periodo_inicio);
							lista_restricao_eletrica_periodo_final.setElemento(idRestricaoEletrica, periodo_final);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Carrega restrição
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							a_dados.vetorRestricaoEletrica.add(restricaoEletrica);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Inicializa matrizes minimo e maximo
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//O numero_patamares não é informado no registro especificado, porém, da leitura de outros registros é possível obtê-lo

							//std::vector<double> potencia_minima(atoi(getString(maiorIdPatamarCarga).c_str()), 0.0);
							//std::vector<double> potencia_maxima(atoi(getString(maiorIdPatamarCarga).c_str()), 1e21);

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).addElemento(AttMatrizRestricaoEletrica_lim_inf, periodo, idPatamarCarga, 0.0);
										a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).addElemento(AttMatrizRestricaoEletrica_lim_sup, periodo, idPatamarCarga, getdoubleFromChar("max"));

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							} // for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro RE: \n" + std::string(erro.what())); }

					}//if (menemonico == "RE") {

					if (menemonico == "LU") {//Limites da restrição 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da restrição elétrica conforme campo 2 do registro RE.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 4);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							const IdRestricaoEletrica idRestricaoEletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_eletrica, codigo_usina);

							if (idRestricaoEletrica_inicializado == IdRestricaoEletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoEletrica  com codigo_usina_" + atributo);

							const IdRestricaoEletrica  idRestricaoEletrica = idRestricaoEletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Determina o periodo inicial e periodo final
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							lista_restricao_eletrica_periodo_inicial.setElemento(idRestricaoEletrica, periodo_inicio);

							const Periodo periodo_final = lista_restricao_eletrica_periodo_final.getElemento(idRestricaoEletrica);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Filosofia: Atualiza se encontrar um valor 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							int numero_patamar = 0;

							IdPatamarCarga idPatamarCarga_DECK;

							std::string limiteInferior;
							std::string limiteSuperior;

							const int line_size = int(line.length());

							SmartEnupla<Periodo, int> numero_patamares_x_periodo(SmartEnupla<Periodo, int>(horizonte_estudo, 0));

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Patamar 1
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							limiteInferior = "";
							limiteSuperior = "";

							if (line_size >= 24) {

								numero_patamar++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4 - Limite inferior em MWmed para o patamar 1. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteInferior = line.substr(14, 10);
								limiteInferior.erase(std::remove(limiteInferior.begin(), limiteInferior.end(), ' '), limiteInferior.end());

							}//if (line_size >= 24) {

							if (line_size >= 34) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 5 - Limite superior em MWmed para o patamar 1. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteSuperior = line.substr(24, 10);
								limiteSuperior.erase(std::remove(limiteSuperior.begin(), limiteSuperior.end(), ' '), limiteSuperior.end());

							}//if (line_size >= 34) {


							if (limiteInferior != "" || limiteSuperior != "") {

								idPatamarCarga_DECK = getIdPatamarCargaFromChar(std::to_string(numero_patamar).c_str());

								for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										
										numero_patamares_x_periodo.at(periodo)++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo.at(periodo));

										if (limiteInferior != "") { a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_inf, periodo, idPatamarCarga, std::atof(limiteInferior.c_str())); }
										if (limiteSuperior != "") { a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_sup, periodo, idPatamarCarga, std::atof(limiteSuperior.c_str())); }

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.at(periodo)) {

							}//if (limiteInferior != "" || limiteSuperior != "") {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Patamar 2
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							limiteInferior = "";
							limiteSuperior = "";

							if (line_size >= 44) {

								numero_patamar++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 6 - Limite inferior em MWmed para o patamar 2. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteInferior = line.substr(34, 10);
								limiteInferior.erase(std::remove(limiteInferior.begin(), limiteInferior.end(), ' '), limiteInferior.end());

							}//if (line_size >= 44) {

							if (line_size >= 54) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 7 - Limite superior em MWmed para o patamar 2. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteSuperior = line.substr(44, 10);
								limiteSuperior.erase(std::remove(limiteSuperior.begin(), limiteSuperior.end(), ' '), limiteSuperior.end());

							}//if (line_size >= 54) {


							if (limiteInferior != "" || limiteSuperior != "") {

								idPatamarCarga_DECK = getIdPatamarCargaFromChar(std::to_string(numero_patamar).c_str());

								for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										numero_patamares_x_periodo.at(periodo)++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo.at(periodo));

										if (limiteInferior != "") { a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_inf, periodo, idPatamarCarga, std::atof(limiteInferior.c_str())); }
										if (limiteSuperior != "") { a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_sup, periodo, idPatamarCarga, std::atof(limiteSuperior.c_str())); }

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.at(periodo)) {

							}//if (limiteInferior != "" || limiteSuperior != "") {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Patamar 3
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							limiteInferior = "";
							limiteSuperior = "";

							if (line_size >= 64) {

								numero_patamar++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 8 - Limite inferior em MWmed para o patamar 3. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteInferior = line.substr(54, 10);
								limiteInferior.erase(std::remove(limiteInferior.begin(), limiteInferior.end(), ' '), limiteInferior.end());

							}//if (line_size >= 64) {

							if (line_size >= 74) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 9 - Limite superior em MWmed para o patamar 3. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteSuperior = line.substr(64, 10);
								limiteSuperior.erase(std::remove(limiteSuperior.begin(), limiteSuperior.end(), ' '), limiteSuperior.end());

							}//if (line_size >= 74) {


							if (limiteInferior != "" || limiteSuperior != "") {

								idPatamarCarga_DECK = getIdPatamarCargaFromChar(std::to_string(numero_patamar).c_str());

								for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										numero_patamares_x_periodo.at(periodo)++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo.at(periodo));

										if (limiteInferior != "") { a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_inf, periodo, idPatamarCarga, std::atof(limiteInferior.c_str())); }
										if (limiteSuperior != "") { a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_sup, periodo, idPatamarCarga, std::atof(limiteSuperior.c_str())); }

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.at(periodo)) {

							}//if (limiteInferior != "" || limiteSuperior != "") {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Patamar 4
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							limiteInferior = "";
							limiteSuperior = "";

							if (line_size >= 84) {

								numero_patamar++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 10 - Limite inferior em MWmed para o patamar 4. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteInferior = line.substr(74, 10);
								limiteInferior.erase(std::remove(limiteInferior.begin(), limiteInferior.end(), ' '), limiteInferior.end());

							}//if (line_size >= 84) {

							if (line_size >= 94) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 11 - Limite superior em MWmed para o patamar 4. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteSuperior = line.substr(84, 10);
								limiteSuperior.erase(std::remove(limiteSuperior.begin(), limiteSuperior.end(), ' '), limiteSuperior.end());

							}//if (line_size >= 94) {

							if (limiteInferior != "" || limiteSuperior != "") {

								idPatamarCarga_DECK = getIdPatamarCargaFromChar(std::to_string(numero_patamar).c_str());

								for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										numero_patamares_x_periodo.at(periodo)++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo.at(periodo));

										if (limiteInferior != "") { a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_inf, periodo, idPatamarCarga, std::atof(limiteInferior.c_str())); }
										if (limiteSuperior != "") { a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_sup, periodo, idPatamarCarga, std::atof(limiteSuperior.c_str())); }

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.at(periodo)) {

							}//if (limiteInferior != "" || limiteSuperior != "") {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Patamar 5
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							limiteInferior = "";
							limiteSuperior = "";

							if (line_size >= 104) {

								numero_patamar++;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 12 - Limite inferior em MWmed para o patamar 5. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteInferior = line.substr(94, 10);
								limiteInferior.erase(std::remove(limiteInferior.begin(), limiteInferior.end(), ' '), limiteInferior.end());

							}//if (line_size >= 104) {

							if (line_size >= 114) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 13 - Limite superior em MWmed para o patamar 5. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteSuperior = line.substr(104, 10);
								limiteSuperior.erase(std::remove(limiteSuperior.begin(), limiteSuperior.end(), ' '), limiteSuperior.end());

							}//if (line_size >= 114) {

							if (limiteInferior != "" || limiteSuperior != "") {

								idPatamarCarga_DECK = getIdPatamarCargaFromChar(std::to_string(numero_patamar).c_str());

								for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										numero_patamares_x_periodo.at(periodo)++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo.at(periodo));

										if (limiteInferior != "") { a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_inf, periodo, idPatamarCarga, std::atof(limiteInferior.c_str())); }
										if (limiteSuperior != "") { a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_sup, periodo, idPatamarCarga, std::atof(limiteSuperior.c_str())); }

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.at(periodo)) {

							}//if (limiteInferior != "" || limiteSuperior != "") {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro LU: \n" + std::string(erro.what())); }

					}//if (menemonico == "LU") {

					if (menemonico == "FU") {//Coeficientes das usinas hidráulicas na restrição

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da restrição elétrica conforme campo 2 do registro RE.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 4);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int restricao_codigo_usina = atoi(atributo.c_str());

							const IdRestricaoEletrica idRestricaoEletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_eletrica, restricao_codigo_usina);

							if (idRestricaoEletrica_inicializado == IdRestricaoEletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoEletrica  com codigo_usina_" + atributo);

							const IdRestricaoEletrica  idRestricaoEletrica = idRestricaoEletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Número da usina hidráulica conforme campo 2 dos registros UH.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int hidreletrica_codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, hidreletrica_codigo_usina);

							const IdHidreletrica idHidreletrica = idHidreletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Fator de participação da usina.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(19, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double fator_participacao = atof(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo Adicional -  Identificador do conjunto Itaipu (codigo_usina = 66)
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							IdIntercambio idIntercambio = IdIntercambio_Nenhum;

							if (line.size() >= 32 && hidreletrica_codigo_usina == 66) {

								atributo = line.substr(30, 2);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								//Na representaçao por usina de Itaipú os limites do intercambio Itaipú->Ande e Itaipú->IV sao atualizados

								const IdSubmercado idSubmercado_itaipu = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_submercado_ITAIPU);
								const IdSubmercado idSubmercado_ande = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_ANDE);
								const IdSubmercado idSubmercado_iv = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_IV);

								std::vector<IdIntercambio> idIntercambio_inicializado = a_dados.vetorIntercambio.getIdObjetos(AttComumIntercambio_submercado_origem, idSubmercado_itaipu);
								const int idIntercambio_inicializado_size = int(idIntercambio_inicializado.size());

								if (atributo == "50") {//Carrega restriçao para os limites de intercambio ITAIPU->ANDE

									for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

										if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_ande) {
											idIntercambio = idIntercambio_inicializado.at(intercambio_inicializado);
											break;
										}//if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {

									}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

									if (idIntercambio == IdIntercambio_Nenhum)
										throw std::invalid_argument("Registro FU - Intercambio nao encontrado");

								}//if (atributo == "50") {
								else if (atributo == "60") {//Carrega restriçao para os limites de intercambio ITAIPU->IV

									for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

										if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_iv) {
											idIntercambio = idIntercambio_inicializado.at(intercambio_inicializado);
											break;
										}//if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {

									}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

									if (idIntercambio == IdIntercambio_Nenhum)
										throw std::invalid_argument("Registro RI - Intercambio nao encontrado");

								}//else if (atributo == "60") {

							}//if (line.size() >= 32 && hidreletrica_codigo_usina == 66) {


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (idIntercambio == IdIntercambio_Nenhum) {//Significa que a restriçao elétrica é referente à idHidreletrica

								//Verifica se o elemento da restrição já foi inicializado

								const std::vector<IdElementoSistema> idElementoSistema_inicializada = a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.getIdObjetos(AttComumElementoSistema_hidreletrica, idHidreletrica);

								if (int(idElementoSistema_inicializada.size()) == 0) {//Ainda não foi inicializado

									IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoEletrica, IdElementoSistema());

									if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
									else { idElementoSistema++; }

									ElementoSistema elementoSistema;
									elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
									elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_hidreletrica);
									elementoSistema.setAtributo(AttComumElementoSistema_hidreletrica, idHidreletrica);
									elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa_potencia_disponivel);

									////////////////////////
									SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
										matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													matriz_fator_participacao.at(periodo).at(idPatamarCarga) = fator_participacao;

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

									/////////////////////////

									a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.add(elementoSistema);
								}//if (int(idElementoSistema_inicializada.size()) == 0) {
								else {


									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(idElementoSistema_inicializada.at(0)).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, idPatamarCarga, fator_participacao);

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) 

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								}//else {

							}//if (idIntercambio == IdIntercambio_Nenhum) {
							else {

								//As restriçoes elétricas referentes aos conjuntos 50/60 Hz Itaipu sao incluidos nos
								//intercambios ITAIPU->ANDE e ITAIPU->IV respectivamente

								//Verifica se o elemento da restrição já foi inicializado

								const std::vector<IdElementoSistema> idElementoSistema_inicializada = a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.getIdObjetos(AttComumElementoSistema_intercambio, idIntercambio);

								if (int(idElementoSistema_inicializada.size()) == 0) {//Ainda não foi inicializado

									IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoEletrica, IdElementoSistema());

									if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
									else { idElementoSistema++; }

									ElementoSistema elementoSistema;
									elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
									elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_intercambio);
									elementoSistema.setAtributo(AttComumElementoSistema_intercambio, idIntercambio);
									elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa_potencia_disponivel);

									////////////////////////
									SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
										matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													matriz_fator_participacao.at(periodo).at(idPatamarCarga) = fator_participacao;

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

									/////////////////////////

									a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.add(elementoSistema);
								}//if (int(idElementoSistema_inicializada.size()) == 0) {
								else {

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(idElementoSistema_inicializada.at(0)).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, idPatamarCarga, fator_participacao);

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) 

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


								}//else {

							}//else {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro FU: \n" + std::string(erro.what())); }

					}//if (menemonico == "FU") {

					if (menemonico == "FT") {

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número de identificação da restrição elétrica conforme campo 2 do registro RE. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 4);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int restricao_codigo_usina = atoi(atributo.c_str());

							const IdRestricaoEletrica idRestricaoEletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_eletrica, restricao_codigo_usina);

							if (idRestricaoEletrica_inicializado == IdRestricaoEletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoEletrica  com codigo_usina_" + atributo);

							const IdRestricaoEletrica  idRestricaoEletrica = idRestricaoEletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Número da usina térmica conforme campo 2 dos registros CT ou TG do arquivo DADGNL. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int termeletrica_codigo_usina = atoi(atributo.c_str());

							const IdTermeletrica idTermeletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_termeletrica, termeletrica_codigo_usina);

							if (idTermeletrica_inicializado == IdTermeletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idTermeletrica com codigo_usina_" + atributo);

							const IdTermeletrica idTermeletrica = idTermeletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Número do subsistema conforme campo 3 dos registros CT ou TG do arquivo DADGNL.  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(19, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int submercado_codigo_usina = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 6 -  Fator de participação da usina.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(24, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double fator_participacao = atof(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							//Verifica se o elemento da restrição já foi inicializado

							const std::vector<IdElementoSistema> idElementoSistema_inicializada = a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.getIdObjetos(AttComumElementoSistema_termeletrica, idTermeletrica);

							if (int(idElementoSistema_inicializada.size()) == 0) {//Ainda não foi inicializado

								IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoEletrica, IdElementoSistema());

								if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
								else { idElementoSistema++; }

								ElementoSistema elementoSistema;
								elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
								elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_termeletrica);
								elementoSistema.setAtributo(AttComumElementoSistema_termeletrica, idTermeletrica);
								elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa_potencia_disponivel);

								////////////////////////
								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
												matriz_fator_participacao.at(periodo).at(idPatamarCarga) = fator_participacao;

											}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

								/////////////////////////

								a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.add(elementoSistema);
							}//if (int(idElementoSistema_inicializada.size()) == 0) {
							else {

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
												a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(idElementoSistema_inicializada.at(0)).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, idPatamarCarga, fator_participacao);

											}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) 

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


							}//else {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro FT: \n" + std::string(erro.what())); }

					}//if (menemonico == "FT") {

					if (menemonico == "FI") {//Coeficientes das interligações na restrição

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número de identificação da restrição elétrica conforme campo 2 do registro RE. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 4);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int restricao_codigo_usina = atoi(atributo.c_str());

							const IdRestricaoEletrica idRestricaoEletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_eletrica, restricao_codigo_usina);

							if (idRestricaoEletrica_inicializado == IdRestricaoEletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoEletrica  com codigo_usina_" + atributo);

							const IdRestricaoEletrica  idRestricaoEletrica = idRestricaoEletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Mnemônico do subsistema “DE” conforme campo 2 dos registros SB 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string submercado_origem_mnemonico = atributo;

							const IdSubmercado idSubmercado_origem_inicializada = getIdSubmercadoFromMnemonico(submercado_origem_mnemonico);

							const IdSubmercado idSubmercado_origem = idSubmercado_origem_inicializada;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Mnemônico do subsistema “PARA” conforme campo 2 dos registros SB. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(19, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string submercado_destino_mnemonico = atributo;

							const IdSubmercado idSubmercado_destino_inicializada = getIdSubmercadoFromMnemonico(submercado_destino_mnemonico);

							const IdSubmercado idSubmercado_destino = idSubmercado_destino_inicializada;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Identifica o IdIntercambio
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							const std::vector<IdIntercambio> idIntercambio_inicializado = a_dados.vetorIntercambio.getIdObjetos(AttComumIntercambio_submercado_origem, idSubmercado_origem);

							const int idIntercambio_inicializado_size = int(idIntercambio_inicializado.size());

							IdIntercambio idIntercambio;

							for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

								idIntercambio = idIntercambio_inicializado.at(intercambio_inicializado);

								if (a_dados.getAtributo(idIntercambio, AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino)
									break;

								if (intercambio_inicializado + 1 == idIntercambio_inicializado_size)
									throw std::invalid_argument("Intercambio nao inicializado entre subsistema_" + getString(idSubmercado_origem) + "e subsistema_" + getString(idSubmercado_destino));

							}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 6 -  Fator de participação da usina.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(24, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double fator_participacao = atof(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							//Verifica se o elemento da restrição já foi inicializado

							const std::vector<IdElementoSistema> idElementoSistema_inicializada = a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.getIdObjetos(AttComumElementoSistema_intercambio, idIntercambio);

							if (int(idElementoSistema_inicializada.size()) == 0) {//Ainda não foi inicializado

								IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoEletrica, IdElementoSistema());

								if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
								else { idElementoSistema++; }

								ElementoSistema elementoSistema;
								elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
								elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_intercambio);
								elementoSistema.setAtributo(AttComumElementoSistema_intercambio, idIntercambio);
								elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa_potencia_disponivel);

								////////////////////////
								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
												matriz_fator_participacao.at(periodo).at(idPatamarCarga) = fator_participacao;

											}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

								/////////////////////////

								a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.add(elementoSistema);

							}//if (int(idElementoSistema_inicializada.size()) == 0) {
							else {

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
												a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(idElementoSistema_inicializada.at(0)).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, idPatamarCarga, fator_participacao);

											}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) 

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//else {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro FI: \n" + std::string(erro.what())); }

					}//if (menemonico == "FI") {

					if (menemonico == "FE") {//Coeficientes dos contratos de exportação e importação na restrição 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número de identificação da restrição elétrica conforme campo 2 do registro RE. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 4);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int restricao_codigo_usina = atoi(atributo.c_str());

							const IdRestricaoEletrica idRestricaoEletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_eletrica, restricao_codigo_usina);

							if (idRestricaoEletrica_inicializado == IdRestricaoEletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoEletrica  com codigo_usina_" + atributo);

							const IdRestricaoEletrica  idRestricaoEletrica = idRestricaoEletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Número do contrato de importação/exportação conforme o campo 2 do registro CI/CE.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int contrato_codigo_usina = atoi(atributo.c_str());

							const IdContrato idContrato_inicializado = getIdFromCodigoONS(lista_codigo_ONS_contrato, contrato_codigo_usina);

							if (idContrato_inicializado == IdContrato_Nenhum)
								throw std::invalid_argument("Nao inicializada idContrato com codigo_usina_" + atributo);

							const IdContrato  idContrato = idContrato_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Número do submercado conforme o campo 3 do registro SB 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(19, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int submercado_codigo_usina = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 6 -  Fator de participação da usina.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(24, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double fator_participacao = atof(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							//Verifica se o elemento da restrição já foi inicializado

							const std::vector<IdElementoSistema> idElementoSistema_inicializada = a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.getIdObjetos(AttComumElementoSistema_contrato, idContrato);

							if (int(idElementoSistema_inicializada.size()) == 0) {//Ainda não foi inicializado

								IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoEletrica, IdElementoSistema());

								if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
								else { idElementoSistema++; }

								ElementoSistema elementoSistema;
								elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
								elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_contrato);
								elementoSistema.setAtributo(AttComumElementoSistema_contrato, idContrato);
								elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa_potencia_disponivel);

								////////////////////////
								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
												matriz_fator_participacao.at(periodo).at(idPatamarCarga) = fator_participacao;

											}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

								/////////////////////////

								a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.add(elementoSistema);

							}//if (int(idElementoSistema_inicializada.size()) == 0) {
							else {

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
												a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(idElementoSistema_inicializada.at(0)).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, idPatamarCarga, fator_participacao);

											}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) 

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


							}//else {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro FE: \n" + std::string(erro.what())); }

					}//if (menemonico == "FE") {

					if (menemonico == "VI") {//Tempo de viagem

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina hidraúlica (conforme campo 2 dos registros UH) cuja vazão defluente atrase mais que 24 horas para o aproveitamento de jusante 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int hidreletrica_codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, hidreletrica_codigo_usina);

							if (idHidreletrica == IdHidreletrica_Nenhum)
								throw std::invalid_argument("Registro VI - idHidreletrica nao instanciada com codigo_" + getString(hidreletrica_codigo_usina));

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Tempo de viagem, em horas
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int tempo_viagem_agua = atoi(atributo.c_str());

							a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_tempo_viagem_agua, tempo_viagem_agua);

							if (!a_dados.vetorHidreletrica.at(idHidreletrica).vetorDefluencia.isInstanciado(IdDefluencia_passada)) {//As defluências podem ser inicializadas desde a pre-configuração

								//Nota: A defluencia passada vai considerar periodos_diarios de 15 dias anteriores ao horizonte de estudo (15 dias máximo tempo de viagem d'água registrado)
								const SmartEnupla<Periodo, bool> horizonte_defluencia_passada(Periodo(TipoPeriodo_diario, horizonte_estudo.getIteradorInicial()) - 15, std::vector<bool>(15, true));

								Defluencia defluencia;
								defluencia.setAtributo(AttComumDefluencia_idDefluencia, IdDefluencia_passada);
								defluencia.setAtributo(AttComumDefluencia_tipo_elemento_jusante, TipoElementoJusante_usina);

								a_dados.vetorHidreletrica.at(idHidreletrica).vetorDefluencia.add(defluencia);

								a_dados.vetorHidreletrica.at(idHidreletrica).vetorDefluencia.at(IdDefluencia_passada).setVetor(AttVetorDefluencia_vazao_defluencia, SmartEnupla<Periodo, double>(horizonte_defluencia_passada, 0.0));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4-8 -  Vazão defluente nas semanas do mês anterior ao início do estudo, em m3/s. Estes valores devem ser 
								//             ordenados da última para a primeira semana do mês anterior. Para casos onde o primeiro período é mensal, 
								//             o valor informado deve ser a vazão do mês anterior ao inicio do estudo, em m3/s. 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								const int line_size = int(line.length());

								int registro = 0;

								std::vector<double> vazao_defluencia;

								//////////////////////////////////////////////////////

								while (true) {

									if (line_size >= 19 + 5 * registro) {

										atributo = line.substr(14 + 5 * registro, 5);
										atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

										if (atributo == "")
											break;

										vazao_defluencia.push_back(atof(atributo.c_str()));

									}//if (line_size >= 19 + 5 * registro) {
									else
										break;

									registro++;

								}//while (true) {

								//////////////////////////////////////////////////////
								//Identifica o periodo_semanal inicial do mês anterior
								//////////////////////////////////////////////////////

								Periodo periodo_semanal = horizonte_otimizacao_DC.getElemento(IdEstagio_1);

								const int numero_semanas_anteriores = int(vazao_defluencia.size());

								for (int semana_anterior = 0; semana_anterior < numero_semanas_anteriores; semana_anterior++)
									periodo_semanal--;


								const Periodo periodo_defluencia_passada_inicial = a_dados.vetorHidreletrica.at(idHidreletrica).vetorDefluencia.at(IdDefluencia_passada).getIteradorInicial(AttVetorDefluencia_vazao_defluencia, Periodo());

								Periodo periodo_defluencia_passada = periodo_defluencia_passada_inicial;

								for (int semana_anterior = 0; semana_anterior < numero_semanas_anteriores; semana_anterior++) {

									while (periodo_defluencia_passada.sobreposicao(periodo_semanal)) {

										a_dados.vetorHidreletrica.at(idHidreletrica).vetorDefluencia.at(IdDefluencia_passada).setElemento(AttVetorDefluencia_vazao_defluencia, periodo_defluencia_passada, vazao_defluencia.at(numero_semanas_anteriores - semana_anterior - 1));
										periodo_defluencia_passada++;

									}//while (periodo_defluencia_passada.sobreposicao(periodo_semanal)) {

									periodo_semanal++;

								}//for (int semana_anterior = 0; semana_anterior < numero_semanas_anteriores; semana_anterior) {

							}//if (!a_dados.vetorHidreletrica.at(idHidreletrica).vetorDefluencia.isInstanciado(IdDefluencia_passada)) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro VI: \n" + std::string(erro.what())); }

					}//if (menemonico == "VI") {

					if (menemonico == "AC") {//Modificação de cadastro 

						try {
							const int line_size = int(line.length());

							if (line_size > 15) {//Foram detectados registros sem nenhum valor de modificação (Erro do DECK), Até a coluna 15 é o mnemônico da modificação

								//Atributo para tstar que tem algum valor logo do mnemônico
								atributo = line.substr(15, line_size - 15);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (atributo != "") {

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 2 -  Número da usina hidráulica conforme campo 2 dos registros UH
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, std::stoi(line.substr(4, 3)));

									if (idHidreletrica != IdHidreletrica_Nenhum) {

										// Inicializa adicao de modificacao na hidreletrica
										/*
										if (lista_modificacaoUHE.size() - 1 < idHidreletrica) {

											IdHidreletrica menorIdHidreletrica = a_dados.getMenorId(IdHidreletrica());

											if (lista_modificacaoUHE.size() > 2)
												menorIdHidreletrica = IdHidreletrica(lista_modificacaoUHE.size() - 1);

											for (IdHidreletrica idHidreletrica_aux = menorIdHidreletrica; idHidreletrica_aux <= idHidreletrica; a_dados.vetorHidreletrica.incr(idHidreletrica_aux))
												lista_modificacaoUHE.push_back(std::vector< ModificacaoUHE>());

										} // if (lista_modificacaoUHE.size() - 1 < idHidreletrica) {
										*/

										/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										//Campo 3 -  Mnemônico para identificação do parâmetro a ser modificado.
										/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

										atributo = line.substr(9, 6);
										atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

										const string mnemonico = atributo;

										ModificacaoUHE modificacaoUHE;

										if (strCompara(mnemonico, "NOMEUH")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_NOMEUH;
											modificacaoUHE.valor_0 = line.substr(19, 12);
										}

										else if (strCompara(mnemonico, "NUMPOS")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_NUMPOS;
											modificacaoUHE.valor_1 = std::stoi(line.substr(19, 5));
										}

										else if (strCompara(mnemonico, "NUMJUS")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_NUMJUS;
											modificacaoUHE.valor_1 = std::stoi(line.substr(19, 5));
										}

										else if (strCompara(mnemonico, "DESVIO")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_DESVIO;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));

											if (line.substr(33, 1) != " ")
												modificacaoUHE.valor_2 = std::stod(line.substr(24, 10));
											else
												modificacaoUHE.valor_2 = 99999;
										}

										else if (strCompara(mnemonico, "VOLMIN")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_VOLMIN;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 10));
										}

										else if (strCompara(mnemonico, "VOLMAX")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_VOLMAX;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 10));
										}

										else if (strCompara(mnemonico, "COTVOL")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_COTVOL;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5)); //Índice da cota_volume
											modificacaoUHE.valor_2 = std::stod(line.substr(33, 6)); //Valor do parâmetro da polinômio cota_volume

											modificacaoUHE.tipo_de_grandeza = TipoGrandezaModificacao_absoluta;
										}

										else if (strCompara(mnemonico, "COTARE")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_COTARE;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5)); //Índice da cota_area
											modificacaoUHE.valor_2 = std::stod(line.substr(33, 6)); //Valor do parâmetro da polinômio cota_area

											modificacaoUHE.tipo_de_grandeza = TipoGrandezaModificacao_absoluta;
										}

										else if (strCompara(mnemonico, "COFEVA")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_COEFEVAP;
											modificacaoUHE.valor_2 = std::stod(line.substr(19, 5));
											modificacaoUHE.valor_1 = std::stod(line.substr(24, 5));
										}

										else if (strCompara(mnemonico, "NUMCON")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_NUMCNJ;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));

										}//else if (strCompara(mnemonico, "NUMCON")) {

										else if (strCompara(mnemonico, "NUMMAQ")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_NUMMAQ;
											modificacaoUHE.valor_2 = std::stod(line.substr(19, 5));
											modificacaoUHE.valor_1 = std::stoi(line.substr(24, 5));

										}//else if (strCompara(mnemonico, "NUMMAQ")) {

										else if (strCompara(mnemonico, "POTEFE")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_POTEFE;
											modificacaoUHE.valor_2 = std::stod(line.substr(19, 5));//No DC o valor_1 e valor_2 desta modificação é diferente ao NW
											modificacaoUHE.valor_1 = std::stod(line.substr(24, 10));
										}

										else if (strCompara(mnemonico, "ALTEFE")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_ALTEFE;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
											modificacaoUHE.valor_2 = std::stod(line.substr(24, 10));
										}

										else if (strCompara(mnemonico, "VAZEFE")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_VAZEFE;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
											modificacaoUHE.valor_2 = std::stod(line.substr(24, 5));
										}

										else if (strCompara(mnemonico, "PROESP")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_PRODESP;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 10));
										}

										else if (strCompara(mnemonico, "PERHID")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_PERDHIDR;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 10));
										}

										else if (strCompara(mnemonico, "NCHAVE")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_NCHAVE;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
											modificacaoUHE.valor_2 = std::stod(line.substr(24, 10));
										}

										else if (strCompara(mnemonico, "COTVAZ")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_COTVAZ;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
											modificacaoUHE.valor_2 = std::stod(line.substr(24, 5));
											modificacaoUHE.valor_3 = std::stod(line.substr(29, 15));



										}

										else if (strCompara(mnemonico, "JUSMED")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_CFUGA;
											modificacaoUHE.tipo_de_grandeza = TipoGrandezaModificacao_absoluta;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 10));
										}

										else if (strCompara(mnemonico, "VERTJU")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_VERTJU;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
										}

										else if (strCompara(mnemonico, "VAZMIN")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_VAZMINHISTORICA;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
										}

										else if (strCompara(mnemonico, "NUMBAS")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_NUMBAS;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
										}

										else if (strCompara(mnemonico, "TIPTUR")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_TIPTUR;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
										}

										else if (strCompara(mnemonico, "TIPERH")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_TIPERH;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
										}

										else if (strCompara(mnemonico, "VAZCCF")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_VAZCCF;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 10));
											modificacaoUHE.valor_2 = std::stod(line.substr(29, 5));
											modificacaoUHE.valor_3 = std::stod(line.substr(34, 10));
										}

										else if (strCompara(mnemonico, "JUSENA")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_JUSENA;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
										}

										else if (strCompara(mnemonico, "VSVERT")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_VSVERT;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 10));
										}

										else if (strCompara(mnemonico, "VMDESV")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_VMDESV;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 10));
										}

										else if (strCompara(mnemonico, "TIPUSI")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_TIPUSI;
											atributo = line.substr(19, 12);
											atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());
											strNormalizada(atributo);
											modificacaoUHE.valor_0 = atributo;
										}

										else if (strCompara(mnemonico, "NPOSNW")) {
											modificacaoUHE.tipo_de_modificacao = TipoModificacaoUHE_NPOSNW;
											modificacaoUHE.valor_1 = std::stod(line.substr(19, 5));
										}//else if (strCompara(mnemonico, "NPOSNW")) {						

										/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
										//Campo 5-6-7 - Mês/número da semana/ano
										/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

										if (line_size >= 72) {

											IdEstagio idEstagio_DC = IdEstagio_Nenhum;

											if (line.substr(69, 3) == "  ")
												idEstagio_DC = horizonte_otimizacao_DC.getIteradorInicial();
											else {

												IdMes idMes = IdMes_Nenhum;

												if (line.substr(69, 3) == "JAN")
													idMes = IdMes_1;
												else if (line.substr(69, 3) == "FEV")
													idMes = IdMes_2;
												else if (line.substr(69, 3) == "MAR")
													idMes = IdMes_3;
												else if (line.substr(69, 3) == "ABR")
													idMes = IdMes_4;
												else if (line.substr(69, 3) == "MAI")
													idMes = IdMes_5;
												else if (line.substr(69, 3) == "JUN")
													idMes = IdMes_6;
												else if (line.substr(69, 3) == "JUL")
													idMes = IdMes_7;
												else if (line.substr(69, 3) == "AGO")
													idMes = IdMes_8;
												else if (line.substr(69, 3) == "SET")
													idMes = IdMes_9;
												else if (line.substr(69, 3) == "OUT")
													idMes = IdMes_10;
												else if (line.substr(69, 3) == "NOV")
													idMes = IdMes_11;
												else if (line.substr(69, 3) == "DEZ")
													idMes = IdMes_12;
												else
													throw std::invalid_argument("Mes nao identificado no registro AC");

												if (idMes == horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()).getMes())
													idEstagio_DC = horizonte_otimizacao_DC.getIteradorFinal();
												else {

													atributo = line.substr(74, 1);
													atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

													if (atributo == "")
														throw std::invalid_argument("Semana nao identificada no registro AC");

													const IdEstagio idEstagio_DC_lido = IdEstagio(atoi(atributo.c_str()));

													idEstagio_DC = idEstagio_DC_lido;

												}//else {

											}//else {


											const Periodo periodo_DC = horizonte_otimizacao_DC.getElemento(idEstagio_DC);

											
											const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
											const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

											for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

												if (periodo >= periodo_DC) {
													modificacaoUHE.periodo = periodo;
													break;
												}//if (periodo >= periodo_DC) {

											}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {
											

										}//if (line_size >= 72) {
										else
											modificacaoUHE.periodo = horizonte_estudo.getIteradorInicial();//Default

										lista_modificacaoUHE.at(idHidreletrica).push_back(modificacaoUHE);

									} // if (idHidreletrica != IdHidreletrica_Nenhum) {

								} // if (atributo != "") {

							}//if (line_size > 15) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro AC: \n" + std::string(erro.what())); }

					}//if (menemonico == "AC") {

					if (menemonico == "CI" || menemonico == "CE") {// Contratos de importação/exportação de energia 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 1 -  Identificação do registro: CI = importação ou CE = exportação
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							TipoContrato tipo_contrato;

							if (menemonico == "CI")
								tipo_contrato = TipoContrato_importacao;
							else if (menemonico == "CE")
								tipo_contrato = TipoContrato_exportacao;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número do contrato. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Índice do subsistema ao qual pertence o contrato.  
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////					
							atributo = line.substr(8, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, atoi(atributo.c_str()));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Nome do contrato 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////					
							atributo = line.substr(11, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							std::string nome = "not_define";

							if (atributo != "")
								nome = atributo;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Índice do estágio.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(24, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_contrato = getIdEstagioFromChar(atributo.c_str());

							////////////////////////////////////////////////////////////////////////////////////////////
							// Campos 6-15 - Limite Inferior / Limite Superior / Custo / ...Fator Perdas
							////////////////////////////////////////////////////////////////////////////////////////////

							const int line_size = int(line.length());

							int numero_patamares;

							if (line_size >= 129 && line.substr(128, 1) != " ")
								numero_patamares = 5;
							else if (line_size >= 109 && line.substr(108, 1) != " ")
								numero_patamares = 4;
							else if (line_size >= 89 && line.substr(88, 1) != " ")
								numero_patamares = 3;
							else if (line_size >= 69 && line.substr(68, 1) != " ")
								numero_patamares = 2;
							else if (line_size >= 49 && line.substr(48, 1) != " ")
								numero_patamares = 1;


							std::vector<double> limite_inferior;
							std::vector<double> limite_superior;
							std::vector<double> custo;

							for (int pat = 0; pat < numero_patamares; pat++) {

								//Limite inferior de impor./exportação de energia, em MWmed
								atributo = line.substr(29 + 20 * pat, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								limite_inferior.push_back(atof(atributo.c_str()));

								//Limite superior de impor./exportação de energia, em MWmed
								atributo = line.substr(34 + 20 * pat, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								limite_superior.push_back(atof(atributo.c_str()));

								//Custo da energia impor./exportada, em $/MWh
								atributo = line.substr(39 + 20 * pat, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								custo.push_back(atof(atributo.c_str()));

							}//for (int pat = 0; pat < numero_patamares; pat++) {

							//No Deck não aparece esta informação apesar das diretrizes do manual de referência
							double fator_de_perdas;

							if (line_size >= 29 + 20 * numero_patamares) {

								atributo = line.substr(24 + 20 * numero_patamares, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());
								fator_de_perdas = atof(atributo.c_str());

							}//if (line_size >= 29 + 5 * numero_patamares) {
							else
								fator_de_perdas = 1; //Default: nos Decks não especificam este valor

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Filosofia, sobreescreve a informação para t >= idEstagio e soma todas as bacias especias guardando um valor total
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Filosofia, sobreescreve a informação para t >= idEstagio
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							if (idEstagio_contrato == IdEstagio_1) { //Inicializa Contrato

								Contrato contrato;

								IdContrato idContrato = a_dados.getMaiorId(IdContrato());

								if (idContrato == IdContrato_Nenhum)
									idContrato = IdContrato_1;
								else
									idContrato++;

								contrato.setAtributo(AttComumContrato_idContrato, idContrato);
								contrato.setAtributo(AttComumContrato_tipo_contrato, tipo_contrato);
								contrato.setAtributo(AttComumContrato_submercado, idSubmercado);
								contrato.setAtributo(AttComumContrato_nome, nome);
								contrato.setAtributo(AttComumContrato_tipo_restricao, TipoRestricaoContrato_limite);
								contrato.setAtributo(AttComumContrato_tipo_unidade, TipoUnidadeRestricaoContrato_MW);

								lista_codigo_ONS_contrato.setElemento(idContrato, codigo_usina);

								/////////////////////////////////////

								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								/////////////////////////////////////

								contrato.setMatriz(AttMatrizContrato_lim_inf, matriz_zero);
								contrato.setMatriz(AttMatrizContrato_lim_sup, matriz_zero);
								contrato.setMatriz(AttMatrizContrato_custo, matriz_zero);

								a_dados.vetorContrato.add(contrato);

							}//if (int(idPatamarDeficit_inicializado.size()) == 1) {
							

							//Identifica o Contrato inicializado com codigo_usina
							const IdContrato idContrato_inicializado = getIdFromCodigoONS(lista_codigo_ONS_contrato, codigo_usina);

							if (idContrato_inicializado == IdContrato_Nenhum)
								throw std::invalid_argument("Nao inicializada idContrato com codigo_usina_" + atributo);

							const IdContrato  idContrato = idContrato_inicializado;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_contrato)) {

											a_dados.vetorContrato.at(idContrato).setElemento(AttMatrizContrato_lim_inf, periodo, idPatamarCarga, limite_inferior.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorContrato.at(idContrato).setElemento(AttMatrizContrato_lim_sup, periodo, idPatamarCarga, limite_superior.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorContrato.at(idContrato).setElemento(AttMatrizContrato_custo, periodo, idPatamarCarga, custo.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

										}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_contrato)) {

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro CI/CE: \n" + std::string(erro.what())); }

					}//if (menemonico == "CI" || menemonico == "CE") {

					if (menemonico == "TI") {//Taxa de irrigação 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina hidráulica (conforme campo 2 dos registros UH). 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int hidreletrica_codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, hidreletrica_codigo_usina);

							const IdHidreletrica idHidreletrica = idHidreletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3-19 -  Vazão desviada em cada estágio do estudo (m3/s).//i.e., 5 colunas/campo
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							std::vector<double> vazao_desviada;

							const int line_size = int(line.length());

							const int numeroEstagios = horizonte_otimizacao_DC.size();

							for (int estagio = 0; estagio < numeroEstagios; estagio++) {

								if (line_size >= 14 + 5 * estagio) {

									atributo = line.substr(9 + 5 * estagio, 5);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									vazao_desviada.push_back(atof(atributo.c_str()));

								}//if (line_size >= 14 + 5 * estagio) {

							}//for (int estagio = 0; estagio < numeroEstagios; estagio++) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elemtentos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							SmartEnupla<Periodo, double> vetor_vazao_desviada(horizonte_estudo, 0.0);

							for (int estagio = 0; estagio < numeroEstagios; estagio++) {

								const IdEstagio idEstagio_vazao_desviada = IdEstagio(estagio + 1);

								const double valor = vazao_desviada.at(estagio);

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									//Atualiza a informação unicamente para o estágio DC indicado

									if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_vazao_desviada) {

										//Se é último estágio DC, o periodo deve ser maior ou igual ao estágio DC

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_vazao_desviada))
											vetor_vazao_desviada.setElemento(periodo, valor);

									}//if (horizonte_otimizacao_DC.getIteradorFinal() == idEstagio_vazao_desviada) {
									else {

										//Se não é último estágio DC, o periodo deve ser entre dois estágios DC consecutivos

										const IdEstagio idEstagio_vazao_desviada_seguinte = IdEstagio(idEstagio_vazao_desviada + 1);

										if (periodo >= horizonte_otimizacao_DC.at(idEstagio_vazao_desviada) && periodo < horizonte_otimizacao_DC.at(idEstagio_vazao_desviada_seguinte))
											vetor_vazao_desviada.setElemento(periodo, valor);

										else if (periodo >= horizonte_otimizacao_DC.at(idEstagio_vazao_desviada_seguinte))
											break; //Evita percorrer todo o horizonte_estudo

									}//else {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//for (int estagio = 0; estagio < numeroEstagios; estagio++) {

							////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							////////////////////////////////////////////////////

							if (a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(AttVetorHidreletrica_vazao_retirada) == 0)
								a_dados.vetorHidreletrica.at(idHidreletrica).setVetor(AttVetorHidreletrica_vazao_retirada, vetor_vazao_desviada);
							else {

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									double vazao_retirada = a_dados.vetorHidreletrica.at(idHidreletrica).getElementoVetor(AttVetorHidreletrica_vazao_retirada, periodo, double());
									vazao_retirada += vetor_vazao_desviada.getElemento(periodo);

									a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_vazao_retirada, periodo, vazao_retirada);

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//else {

							/*

							const IdIntercambioHidraulico idIntercambioHidraulico = IdIntercambioHidraulico(a_dados.getMaiorId(IdIntercambioHidraulico()) + 1);

							IntercambioHidraulico intercambioHidraulico;
							intercambioHidraulico.setAtributo(AttComumIntercambioHidraulico_idIntercambioHidraulico, idIntercambioHidraulico);

							a_dados.vetorIntercambioHidraulico.add(intercambioHidraulico);

							a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setAtributo(AttComumIntercambioHidraulico_tipo_intercambio_hidraulico, TipoIntercambioHidraulico_retirada);

							a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setAtributo(AttComumIntercambioHidraulico_hidreletrica_origem, idHidreletrica);
							a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setAtributo(AttComumIntercambioHidraulico_hidreletrica_destino, IdHidreletrica_Nenhum); //Manual: irrigação, abastecimento ou retirada de água para outros usos -> Portanto, não se acopla com outras usinas (IdHidreletrica_Nenhum)

							a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setVetor(AttVetorIntercambioHidraulico_desvio_agua_minimo, vetor_vazao_desviada);
							a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setVetor(AttVetorIntercambioHidraulico_desvio_agua_maximo, vetor_vazao_desviada);

							*/

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro TI: \n" + std::string(erro.what())); }

					}//if (menemonico == "TI") {

					if (menemonico == "HA") {//Identificação das restrições RHA					

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número de identificação da restrição de afluência (entre 01 e 120).
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());
							
							const string nome = atributo;

							const int codigo_restricao_operativa_UHE_vazao_afluente = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Estágio inicial da restrição. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Estágio final da restrição.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_final = getIdEstagioFromChar(atributo.c_str());

							const IdEstagio idEstagio_final_horizonte_otimizacao_DC = horizonte_otimizacao_DC.getIteradorFinal();

							Periodo periodo_final;

							if (idEstagio_final == idEstagio_final_horizonte_otimizacao_DC) {

								periodo_final = horizonte_estudo.getIteradorFinal();

							}//if (idEstagio_final == idEstagio_final_horizonte_otimizacao_DC) {
							else {//Se não é o último estágio, precisa encontrar o último periodo referente ao idEstagio_final

								Periodo periodo = horizonte_estudo.getIteradorInicial();

								const IdEstagio idEstagio_final_seguinte = IdEstagio(idEstagio_final + 1);

								while (horizonte_otimizacao_DC.at(idEstagio_final_seguinte) > periodo) {

									horizonte_estudo.incrementarIterador(periodo);

								}//while (horizonte_otimizacao_DC.at(idEstagio_final) > periodo) {

								horizonte_estudo.decrementarIterador(periodo);

								periodo_final = periodo;

							}//else {

							//Nota: Alguns decks repetem por erro o mesmo registro, portanto, é verificado que a restriçao nao tenha sido inicializada.
							//Caso contrário, verifica que o periodo_inicial e periodo_final do registro duplicado seja igual à restriçao instanciada
							const IdRestricaoOperativaUHE idRestricaoOperativaUHE_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_vazao_afluente, codigo_restricao_operativa_UHE_vazao_afluente);

							if (idRestricaoOperativaUHE_inicializado == IdRestricaoOperativaUHE_Nenhum) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Guarda informação nos Smart Elementos
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								RestricaoOperativaUHE restricaoOperativaUHE;

								IdRestricaoOperativaUHE idRestricaoOperativaUHE = a_dados.getMaiorId(IdRestricaoOperativaUHE());

								if (idRestricaoOperativaUHE == IdRestricaoOperativaUHE_Nenhum)
									idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1;
								else
									idRestricaoOperativaUHE++;

								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_idRestricaoOperativaUHE, idRestricaoOperativaUHE);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_nome, nome);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_periodo_inicio, periodo_inicio);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_periodo_final, periodo_final);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_vlr_ini, getdoubleFromChar("max"));
								//restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoOperativaUHE, tipoRestricaoOperativaUHE);

								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoHidraulica, TipoRestricaoHidraulica_vazao_afluente);

								lista_codigo_ONS_restricao_operativa_UHE_vazao_afluente.setElemento(idRestricaoOperativaUHE, codigo_restricao_operativa_UHE_vazao_afluente);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Inicializa vetores minimo e maximo
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								//São instanciados todos os periodos do horizonte_estudo e logo no resgistro LA são atualizados os limites entre periodo_inicio e periodo_final

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									restricaoOperativaUHE.addElemento(AttVetorRestricaoOperativaUHE_lim_inf, periodo, getdoubleFromChar("min"));
									restricaoOperativaUHE.addElemento(AttVetorRestricaoOperativaUHE_lim_sup, periodo, getdoubleFromChar("max"));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Carrega restrição
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								a_dados.vetorRestricaoOperativaUHE.add(restricaoOperativaUHE);

							}
							else {

								if (periodo_inicio != a_dados.getAtributo(idRestricaoOperativaUHE_inicializado, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo()))
									throw std::invalid_argument("Diversos registros com o mesmo codigo de restricao com diferente periodo_inicial");

								if (periodo_final != a_dados.getAtributo(idRestricaoOperativaUHE_inicializado, AttComumRestricaoOperativaUHE_periodo_final, Periodo()))
									throw std::invalid_argument("Diversos registros com o mesmo codigo de restricao com diferente periodo_final");

							}//else {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro HA: \n" + std::string(erro.what())); }

					}//if (menemonico == "HA") {

					if (menemonico == "LA") {//Limites das restrições RH

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da restrição de afluência, conforme campo 2 do registro HA
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Pode ocorrer que diferentes tipos de Restrição operativa das UHE tenham o mesmo código CEPEL; portanto, primeiro é
							// realizada uma seleção do tipo da restrição e logo uma procura pelo código CEPEL  asignado no registro HA

							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_restricao_operativa_UHE_vazao_afluente = atoi(atributo.c_str());

							const IdRestricaoOperativaUHE idRestricaoOperativaUHE_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_vazao_afluente, codigo_restricao_operativa_UHE_vazao_afluente);

							if (idRestricaoOperativaUHE_inicializado == IdRestricaoOperativaUHE_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoOperativaUHE  com codigo_restricao_operativa_UHE_vazao_afluente_" + atributo);

							const IdRestricaoOperativaUHE  idRestricaoOperativaUHE = idRestricaoOperativaUHE_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Determina o periodo inicial e periodo final
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const Periodo periodo_final = a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_final, Periodo());

							if (periodo_inicio < a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo()) || periodo_inicio > periodo_final)
								throw std::invalid_argument("Registro LA - Periodo inicio nao correspondente aos limites da restricao");

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Filosofia: Atualiza se encontrar um valor 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							std::string limiteInferior;
							std::string limiteSuperior;

							const int line_size = int(line.length());

							limiteInferior = "";
							limiteSuperior = "";

							if (line_size >= 24) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4 - Limite inferior, (m3/s). 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteInferior = line.substr(14, 10);
								limiteInferior.erase(std::remove(limiteInferior.begin(), limiteInferior.end(), ' '), limiteInferior.end());

							}//if (line_size >= 24) {

							if (line_size >= 34) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 5 - Limite superior (m3/s).
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteSuperior = line.substr(24, 10);
								limiteSuperior.erase(std::remove(limiteSuperior.begin(), limiteSuperior.end(), ' '), limiteSuperior.end());

							}//if (line_size >= 34) {

							if (limiteInferior != "" || limiteSuperior != "") {

								//Filosofia: Este tipo de restrição é carregada para todos os periodos

								for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {
									if (limiteInferior != "") { a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttVetorRestricaoOperativaUHE_lim_inf, periodo, std::atof(limiteInferior.c_str())); }
									if (limiteSuperior != "") { a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttVetorRestricaoOperativaUHE_lim_sup, periodo, std::atof(limiteSuperior.c_str())); }
								}//for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.at(periodo)) {

							}//if (limiteInferior != "" || limiteSuperior != "") {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro LA: \n" + std::string(erro.what())); }

					}//if (menemonico == "LA") {

					if (menemonico == "CA") {//Usinas hidrelétricas na restrição RHA 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da restrição de afluência, conforme campo 2 do registro HA
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Pode ocorrer que diferentes tipos de Restrição operativa das UHE tenham o mesmo código CEPEL; portanto, primeiro é
							// realizada uma seleção do tipo da restrição e logo uma procura pelo código CEPEL  asignado no registro HA

							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_restricao_operativa_UHE_vazao_afluente = atoi(atributo.c_str());

							const IdRestricaoOperativaUHE idRestricaoOperativaUHE_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_vazao_afluente, codigo_restricao_operativa_UHE_vazao_afluente);

							if (idRestricaoOperativaUHE_inicializado == IdRestricaoOperativaUHE_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoOperativaUHE  com codigo_restricao_operativa_UHE_vazao_afluente_" + atributo);

							const IdRestricaoOperativaUHE  idRestricaoOperativaUHE = idRestricaoOperativaUHE_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Determina o periodo inicial e periodo final
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const Periodo periodo_final = a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_final, Periodo());

							if (periodo_inicio < a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo()) || periodo_inicio > periodo_final)
								throw std::invalid_argument("Registro CA - Periodo inicio nao correspondente aos limites da restricao");

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Número da usina hidráulica conforme campo 2 dos registros UH.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int hidreletrica_codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, hidreletrica_codigo_usina);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							//Manual Referência: 5.2.5.1 Restrição Hidráulica de Vazão Afluente (RHA) A restrição hidráulica de vazão afluente tem por objetivo especificar limites mínimos e máximos para 
							//a quantidade de água afluente a uma dada usina do sistema, para determinados estágios do estudo

							//Manual: Deve ser fornecido um registro para a usina hidrelétrica a que se refere a restrição RHA

							//Filosofia: Cada restrição RHA somente pode ter uma única usina associada

							if (periodo_inicio == a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo())) {//Ainda não foi inicializado

								if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.getMaiorId() > IdElementoSistema_Nenhum)
									throw std::invalid_argument("A restricao hidraulica RHA de afluencia so pode ter 1 usina associada");

								IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoOperativaUHE, IdElementoSistema());

								if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
								else { idElementoSistema++; }

								ElementoSistema elementoSistema;
								elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
								elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_hidreletrica);
								elementoSistema.setAtributo(AttComumElementoSistema_hidreletrica, idHidreletrica);
								elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa_vazao_afluente);

								////////////////////////
								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
												matriz_fator_participacao.at(periodo).at(idPatamarCarga) = 1.0; //O manual não especifica nenhum fator de participação, foi adotado 1

											}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

								/////////////////////////


								a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.add(elementoSistema);

							}//if (periodo_inicio == a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo())) {
							else {

								const std::vector<IdElementoSistema> idElementoSistema_inicializada = a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.getIdObjetos(AttComumElementoSistema_hidreletrica, idHidreletrica);

								if (int(idElementoSistema_inicializada.size()) == 0)
									throw std::invalid_argument("Elemento do sistema na restrição RHA nao instanciado");

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
												a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema_inicializada.at(0)).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, idPatamarCarga, 1.0);

											}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) 

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


							}//else {
						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro CA: \n" + std::string(erro.what())); }

					}//if (menemonico == "CA") {

					if (menemonico == "HV") {//Identificação das restrições RHV: Restrições de volume armazenado/volume defluente

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número de identificação da restrição de afluência (entre 01 e 120).
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string nome = atributo;

							const int codigo_restricao_operativa_UHE_volume = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Estágio inicial da restrição. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Estágio final da restrição.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_final = getIdEstagioFromChar(atributo.c_str());

							const IdEstagio idEstagio_final_horizonte_otimizacao_DC = horizonte_otimizacao_DC.getIteradorFinal();

							Periodo periodo_final;

							if (idEstagio_final == idEstagio_final_horizonte_otimizacao_DC) {

								periodo_final = horizonte_estudo.getIteradorFinal();

							}//if (idEstagio_final == idEstagio_final_horizonte_otimizacao_DC) {
							else {//Se não é o último estágio, precisa encontrar o último periodo referente ao idEstagio_final

								Periodo periodo = horizonte_estudo.getIteradorInicial();

								const IdEstagio idEstagio_final_seguinte = IdEstagio(idEstagio_final + 1);

								while (horizonte_otimizacao_DC.at(idEstagio_final_seguinte) > periodo) {

									horizonte_estudo.incrementarIterador(periodo);

								}//while (horizonte_otimizacao_DC.at(idEstagio_final) > periodo) {

								horizonte_estudo.decrementarIterador(periodo);

								periodo_final = periodo;

							}//else {

							//Nota: Alguns decks repetem por erro o mesmo registro, portanto, é verificado que a restriçao nao tenha sido inicializada.
							//Caso contrário, verifica que o periodo_inicial e periodo_final do registro duplicado seja igual à restriçao instanciada
							const IdRestricaoOperativaUHE idRestricaoOperativaUHE_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_volume, codigo_restricao_operativa_UHE_volume);

							if (idRestricaoOperativaUHE_inicializado == IdRestricaoOperativaUHE_Nenhum) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Guarda informação nos Smart Elementos
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								RestricaoOperativaUHE restricaoOperativaUHE;

								IdRestricaoOperativaUHE idRestricaoOperativaUHE = a_dados.getMaiorId(IdRestricaoOperativaUHE());

								if (idRestricaoOperativaUHE == IdRestricaoOperativaUHE_Nenhum)
									idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1;
								else
									idRestricaoOperativaUHE++;

								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_idRestricaoOperativaUHE, idRestricaoOperativaUHE);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_nome, nome);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_periodo_inicio, periodo_inicio);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_periodo_final, periodo_final);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_vlr_ini, getdoubleFromChar("max"));

								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoHidraulica, TipoRestricaoHidraulica_volume_armazenado);

								lista_codigo_ONS_restricao_operativa_UHE_volume.setElemento(idRestricaoOperativaUHE, codigo_restricao_operativa_UHE_volume);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Inicializa matrizes minimo e maximo
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								//Nota: limite_inferior/limite_superior com valor min/max não é considerado dentro do modelo
								//São instanciados todos os periodos do horizonte_estudo e logo no resgistro LV são atualizados os limites entre periodo_inicio e periodo_final

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											restricaoOperativaUHE.addElemento(AttMatrizRestricaoOperativaUHE_lim_inf, periodo, idPatamarCarga, getdoubleFromChar("min"));
											restricaoOperativaUHE.addElemento(AttMatrizRestricaoOperativaUHE_lim_sup, periodo, idPatamarCarga, getdoubleFromChar("max"));

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Carrega restrição
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								a_dados.vetorRestricaoOperativaUHE.add(restricaoOperativaUHE);

							}//if (idRestricaoOperativaUHE_inicializado == IdRestricaoOperativaUHE_Nenhum)
							else {

								if (periodo_inicio != a_dados.getAtributo(idRestricaoOperativaUHE_inicializado, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo()))
									throw std::invalid_argument("Diversos registros com o mesmo codigo de restricao com diferente periodo_inicial");

								if (periodo_final != a_dados.getAtributo(idRestricaoOperativaUHE_inicializado, AttComumRestricaoOperativaUHE_periodo_final, Periodo()))
									throw std::invalid_argument("Diversos registros com o mesmo codigo de restricao com diferente periodo_inicial");


							}//else {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro HV: \n" + std::string(erro.what())); }

					}//if (menemonico == "HV") {

					if (menemonico == "LV") {//Limites das restrições RHV 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da restrição de afluência, conforme campo 2 do registro HA
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Pode ocorrer que diferentes tipos de Restrição operativa das UHE tenham o mesmo código CEPEL; portanto, primeiro é
							// realizada uma seleção do tipo da restrição e logo uma procura pelo código CEPEL  asignado no registro HA

							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_restricao_operativa_UHE_volume = atoi(atributo.c_str());

							const IdRestricaoOperativaUHE idRestricaoOperativaUHE_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_volume, codigo_restricao_operativa_UHE_volume);

							if (idRestricaoOperativaUHE_inicializado == IdRestricaoOperativaUHE_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoOperativaUHE  com codigo_restricao_operativa_UHE_volume_" + atributo);

							const IdRestricaoOperativaUHE  idRestricaoOperativaUHE = idRestricaoOperativaUHE_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Determina o periodo inicial e periodo final
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const Periodo periodo_final = a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_final, Periodo());

							if (periodo_inicio < a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo()) || periodo_inicio > periodo_final)
								throw std::invalid_argument("Registro LV - Periodo inicio nao correspondente aos limites da restricao");

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Filosofia: Atualiza se encontrar um valor 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							std::string limiteInferior;
							std::string limiteSuperior;

							const int line_size = int(line.length());

							limiteInferior = "";
							limiteSuperior = "";

							if (line_size >= 24) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4 - Limite inferior (hm3). 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteInferior = line.substr(14, 10);
								limiteInferior.erase(std::remove(limiteInferior.begin(), limiteInferior.end(), ' '), limiteInferior.end());

							}//if (line_size >= 24) {

							if (line_size >= 34) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 5 - Limite superior (hm3).
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								limiteSuperior = line.substr(24, 10);
								limiteSuperior.erase(std::remove(limiteSuperior.begin(), limiteSuperior.end(), ' '), limiteSuperior.end());

							}//if (line_size >= 34) {

							if (limiteInferior != "" || limiteSuperior != "") {

								//Filosofia: As restrições são fornecidas para um estágio_DC, portanto, o limite da restrição SOMENTE vai ser atualizado no periodo_SPT onde termina o estágio_DC
								//com o fim da construção da restrição RHV, onde valores "MAX" dos limites são ignorados

								//////////////////////////////////////////////////////////////////////////////
								//Determina o idEstagio_final_DC
								//////////////////////////////////////////////////////////////////////////////

								//const IdEstagio idEstagio_final_DC = horizonte_otimizacao_DC.getIteradorFinal();

								IdEstagio idEstagio_final_DC = IdEstagio_Nenhum;

								if (periodo_final == horizonte_estudo.getIteradorFinal())
									idEstagio_final_DC = horizonte_otimizacao_DC.getIteradorFinal();
								else {

									for (IdEstagio idEstagio_aux = idEstagio_inicial; idEstagio_aux <= horizonte_otimizacao_DC.getIteradorFinal(); idEstagio_aux++) {

										if (horizonte_otimizacao_DC.at(IdEstagio(idEstagio_aux + 1)) > periodo_final) {//Se o estágio seguinte é maior do que o periodo_final

											idEstagio_final_DC = idEstagio_aux;
											break;

										}//if (horizonte_otimizacao_DC.at(idEstagio_aux) >= periodo_final) {

									}//for (IdEstagio idEstagio = IdEstagio_1; idEstagio <= horizonte_otimizacao_DC.getIteradorFinal(); idEstagio++) {

								}//else {

								if (idEstagio_final_DC == IdEstagio_Nenhum)
									throw std::invalid_argument("Registro LV - IdEstagio_DC incompativel com o horizonte de estudo");


								//////////////////////////////////////////////////////////////////////////////

								for (IdEstagio idEstagio_DC = idEstagio_inicial; idEstagio_DC <= idEstagio_final_DC; idEstagio_DC++) {

									Periodo periodo_seguinte = periodo_inicio;
									Periodo periodo_atualizar_limites = periodo_inicio;

									if (idEstagio_DC < horizonte_otimizacao_DC.getIteradorFinal()) {

										IdEstagio idEstagio_DC_seguinte = IdEstagio(idEstagio_DC + 1);
										Periodo periodo_DC_seguinte = horizonte_otimizacao_DC.at(idEstagio_DC_seguinte);

										while (true) {

											//Pega o periodo anterior a quando o tem uma mudança de estágio no DC (o qual correponde ao último periodo paralelo ao DC)

											horizonte_estudo.incrementarIterador(periodo_seguinte);

											if (periodo_seguinte >= periodo_DC_seguinte)
												break;

											horizonte_estudo.incrementarIterador(periodo_atualizar_limites);

										}//while (true) {

									}//if (idEstagio_DC < idEstagio_final_DC) {
									else //Para o último estágio o periodo_atualizar corresponde com último periodo do horizonte_estudo
										periodo_atualizar_limites = horizonte_estudo.getIteradorFinal();


									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo_atualizar_limites, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo_atualizar_limites, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											if (limiteInferior != "")										
												a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_inf, periodo_atualizar_limites, idPatamarCarga, std::atof(limiteInferior.c_str()));

											if (limiteSuperior != "")
												a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_sup, periodo_atualizar_limites, idPatamarCarga, std::atof(limiteSuperior.c_str()));

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo_atualizar_limites, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (IdEstagio idEstagio_DC = idEstagio_inicial; idEstagio_DC <= horizonte_otimizacao_DC.getIteradorFinal(); idEstagio_DC++) {

							}//if (limiteInferior != "" || limiteSuperior != "") {
						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro LV: \n" + std::string(erro.what())); }

					}//if (menemonico == "LV") {

					if (menemonico == "CV") {//Coeficientes das restrições RHV

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da restrição de Volume, conforme campo 2 do registro HV
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Pode ocorrer que diferentes tipos de Restrição operativa das UHE tenham o mesmo código CEPEL; portanto, primeiro é
							// realizada uma seleção do tipo da restrição e logo uma procura pelo código CEPEL  asignado no registro HA

							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_restricao_operativa_UHE_volume = atoi(atributo.c_str());

							const IdRestricaoOperativaUHE idRestricaoOperativaUHE_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_volume, codigo_restricao_operativa_UHE_volume);

							if (idRestricaoOperativaUHE_inicializado == IdRestricaoOperativaUHE_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoOperativaUHE  com codigo_restricao_operativa_UHE_volume_" + atributo);

							const IdRestricaoOperativaUHE  idRestricaoOperativaUHE = idRestricaoOperativaUHE_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Determina o periodo inicial e periodo final
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const Periodo periodo_final = a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_final, Periodo());

							if (periodo_inicio < a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo()) || periodo_inicio > periodo_final)
								throw std::invalid_argument("Registro CV - Periodo inicio nao correspondente aos limites da restricao");

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Coeficiente de cada variável na restrição HV. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(19, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							double fator_participacao = atof(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 6 -  Tipos válidos para a variável na restrição RHV:
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							const int line_size = int(line.length());

							atributo = line.substr(34, 4);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							TipoVariavelRestricaoOperativa tipoVariavelRestricaoOperativa;

							if (line_size >= 38) {

								if (atributo == "VARM")
									tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_volume_final;
								else if (atributo == "VDEF")
									tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_volume_defluente;
								else if (atributo == "VDES")
									tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_volume_desviado;
								else if (atributo == "VBOM")
									tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_volume_bombeado;

							}//if (line_size >= 38) {
							else
								tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_volume_final; //Valor default

							//Se for um dado de vazão convertida em volume então divide pelo conversor_vazao_m3s_em_volume_hm3 para obter o coeficiente de participação na restrição e logo na construção das restrições é multiplicado pelo conversor do periodo SPT
							if (tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_desviado || tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_defluente)
								fator_participacao *= std::pow(conversor_vazao_m3s_em_volume_hm3(horizonte_otimizacao_DC.at(idEstagio_inicial)), -1);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Número da usina hidrelétrica, conforme campo 2 do registro UH 
							//           ou estação de bombeamento, conforme campo 2 do registro UE
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							//Manual: 
							//-Deve ser fornecido um registro para cada variável (volume armazenado no reservatório, vazão defluente de uma usina hidrelétrica ou vazão bombeada de uma estação de bombeamento) com coeficiente não nulo na restrição RHV
							//-Podem ser fornecidos mais de um registro CV para uma mesma restrição de VARM. Neste caso a restrição passa a envolver os volumes armazenados de mais de uma usina

							//Filosofia: Pode ter uma mesma restrição com variáveis VARM, VDEF, VDES, VBOM da mesma usina ou de usinas diferentes, ver Manual Referência seção 5.2.5.3

							if (tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_bombeado) {//Volume bombeada nas estações de bombeamento. 

								const int usina_elevatoria_codigo_usina = atoi(atributo.c_str());

								const IdUsinaElevatoria idUsinaElevatoria = getIdFromCodigoONS(lista_codigo_ONS_usina_elevatoria, usina_elevatoria_codigo_usina);

								if (idUsinaElevatoria == IdUsinaElevatoria_Nenhum)
									throw std::invalid_argument("Nao inicializada idUsinaElevatoria com codigo_usina_" + atributo);

								if (periodo_inicio == a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo())) {//Ainda não foi inicializado

									IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoOperativaUHE, IdElementoSistema());

									if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
									else { idElementoSistema++; }

									ElementoSistema elementoSistema;
									elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
									elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_usina_elevatoria);
									elementoSistema.setAtributo(AttComumElementoSistema_usina_elevatoria, idUsinaElevatoria);
									elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, tipoVariavelRestricaoOperativa);

									//Inicializa o fator_participacao para o horizonte todo, porém no modelo são considerados somentes periodos com limites máximos e mínimos diferentes a "max" e "min"
									////////////////////////
									SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
										matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													matriz_fator_participacao.at(periodo).at(idPatamarCarga) = fator_participacao;

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

									/////////////////////////

									a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.add(elementoSistema);

								}//if (periodo_inicio == a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo())) {
								else {

									const std::vector<IdElementoSistema> idElementoSistema_inicializada = a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.getIdObjetos(AttComumElementoSistema_usina_elevatoria, idUsinaElevatoria);

									if (int(idElementoSistema_inicializada.size()) == 0)
										throw std::invalid_argument("Elemento do sistema na restrição RHV nao instanciado");

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema_inicializada.at(0)).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, idPatamarCarga, fator_participacao);

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) 

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								}//else {				

							}//if (tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_bombeado) {
							else if (tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_final || tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_desviado || tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_defluente) {

								const int hidreletrica_codigo_usina = atoi(atributo.c_str());

								const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, hidreletrica_codigo_usina);

								if (idHidreletrica == IdHidreletrica_Nenhum)
									throw std::invalid_argument("Nao inicializada idHidreletrica com codigo_usina_" + atributo);

								if (periodo_inicio == a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo())) {//Ainda não foi inicializado

									IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoOperativaUHE, IdElementoSistema());

									if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
									else { idElementoSistema++; }

									ElementoSistema elementoSistema;
									elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
									elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_hidreletrica);
									elementoSistema.setAtributo(AttComumElementoSistema_hidreletrica, idHidreletrica);
									elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, tipoVariavelRestricaoOperativa);

									////////////////////////
									SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
										matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													matriz_fator_participacao.at(periodo).at(idPatamarCarga) = fator_participacao;

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

									/////////////////////////

									a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.add(elementoSistema);

								}//if (periodo_inicio == a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo())) {
								else {

									const std::vector<IdElementoSistema> idElementoSistema_inicializada = a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.getIdObjetos(AttComumElementoSistema_hidreletrica, idHidreletrica);

									IdElementoSistema idElementoSistema = IdElementoSistema_Nenhum;

									for (int pos = 0; pos < int(idElementoSistema_inicializada.size()); pos++) {

										if (tipoVariavelRestricaoOperativa == a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema_inicializada.at(pos)).getAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa())) {
											idElementoSistema = idElementoSistema_inicializada.at(pos);
											break;
										}//if (tipoVariavelRestricaoOperativa == a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema_inicializada.at(pos)).getAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa())) {

									}//for (int pos = 0; pos < int(idElementoSistema_inicializada.size()); pos++) {

									if (idElementoSistema == IdElementoSistema_Nenhum)
										throw std::invalid_argument("Elemento do sistema na restrição RHV nao instanciado");


									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, idPatamarCarga, fator_participacao);

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) 

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								}//else {

							}//else if(tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_final || tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_desviado || tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_defluente) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro CV: \n" + std::string(erro.what())); }

					}//if (menemonico == "CV") {

					if (menemonico == "HQ") {//Identificação das restrições RHQ: Restrição Hidráulica de Vazão Defluente 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número de identificação da restrição de afluência (entre 01 e 120).
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string nome = atributo;

							const int codigo_restricao_operativa_UHE_vazao_defluente = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Estágio inicial da restrição. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Estágio final da restrição.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_final = getIdEstagioFromChar(atributo.c_str());

							const IdEstagio idEstagio_final_horizonte_otimizacao_DC = horizonte_otimizacao_DC.getIteradorFinal();

							Periodo periodo_final;

							if (idEstagio_final == idEstagio_final_horizonte_otimizacao_DC) {

								periodo_final = horizonte_estudo.getIteradorFinal();

							}//if (idEstagio_final == idEstagio_final_horizonte_otimizacao_DC) {
							else {//Se não é o último estágio, precisa encontrar o último periodo referente ao idEstagio_final

								Periodo periodo = horizonte_estudo.getIteradorInicial();

								const IdEstagio idEstagio_final_seguinte = IdEstagio(idEstagio_final + 1);

								while (horizonte_otimizacao_DC.at(idEstagio_final_seguinte) > periodo) {

									horizonte_estudo.incrementarIterador(periodo);

								}//while (horizonte_otimizacao_DC.at(idEstagio_final) > periodo) {

								horizonte_estudo.decrementarIterador(periodo);

								periodo_final = periodo;

							}//else {

							//Nota: Alguns decks repetem por erro o mesmo registro, portanto, é verificado que a restriçao nao tenha sido inicializada.
							//Caso contrário, verifica que o periodo_inicial e periodo_final do registro duplicado seja igual à restriçao instanciada
							const IdRestricaoOperativaUHE idRestricaoOperativaUHE_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_vazao_defluente, codigo_restricao_operativa_UHE_vazao_defluente);

							if (idRestricaoOperativaUHE_inicializado == IdRestricaoOperativaUHE_Nenhum) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Guarda informação nos Smart Elementos
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								RestricaoOperativaUHE restricaoOperativaUHE;

								IdRestricaoOperativaUHE idRestricaoOperativaUHE = IdRestricaoOperativaUHE(a_dados.getMaiorId(IdRestricaoOperativaUHE()) + 1);

								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_idRestricaoOperativaUHE, idRestricaoOperativaUHE);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_nome, nome);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_periodo_inicio, periodo_inicio);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_periodo_final, periodo_final);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_vlr_ini, getdoubleFromChar("max"));

								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoHidraulica, TipoRestricaoHidraulica_vazao_defluente);

								lista_codigo_ONS_restricao_operativa_UHE_vazao_defluente.setElemento(idRestricaoOperativaUHE, codigo_restricao_operativa_UHE_vazao_defluente);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Inicializa vetor fator participação
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								//restricaoOperativaUHE.setVetor(AttVetorRestricaoOperativaUHE_fator_participacao, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Carrega Restrição Operativa
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								a_dados.vetorRestricaoOperativaUHE.add(restricaoOperativaUHE);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Inicializa matrizes minimo e maximo
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								//O numero_patamares não é informado no registro especificado, porém, da leitura de outros registros é possível obtê-lo
								//São instanciados todos os periodos do horizonte_estudo e logo no resgistro LQ são atualizados os limites entre periodo_inicio e periodo_final

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									int numero_patamares_x_periodo = 0;

									for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

											a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).addElemento(AttMatrizRestricaoOperativaUHE_lim_inf, periodo, idPatamarCarga, getdoubleFromChar("min"));
											a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).addElemento(AttMatrizRestricaoOperativaUHE_lim_sup, periodo, idPatamarCarga, getdoubleFromChar("max"));

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}
							else {

								if (periodo_inicio != a_dados.getAtributo(idRestricaoOperativaUHE_inicializado, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo()))
									throw std::invalid_argument("Diversos registros com o mesmo codigo de restricao com diferente periodo_inicial");

								if (periodo_final != a_dados.getAtributo(idRestricaoOperativaUHE_inicializado, AttComumRestricaoOperativaUHE_periodo_final, Periodo()))
									throw std::invalid_argument("Diversos registros com o mesmo codigo de restricao com diferente periodo_inicial");

							}//else {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro HQ: \n" + std::string(erro.what())); }

					}//if (menemonico == "HQ") {

					if (menemonico == "LQ") {// Limites das restrições RHQ 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da restrição de afluência, conforme campo 2 do registro HA
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Pode ocorrer que diferentes tipos de Restrição operativa das UHE tenham o mesmo código CEPEL; portanto, primeiro é
							// realizada uma seleção do tipo da restrição e logo uma procura pelo código CEPEL  asignado no registro HA

							const int codigo_restricao_operativa_UHE_vazao_defluente = std::stoi(line.substr(4, 3));

							const IdRestricaoOperativaUHE idRestricaoOperativaUHE_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_vazao_defluente, codigo_restricao_operativa_UHE_vazao_defluente);

							if (idRestricaoOperativaUHE_inicializado == IdRestricaoOperativaUHE_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoOperativaUHE  com codigo_restricao_operativa_UHE_vazao_defluente_" + atributo);

							const IdRestricaoOperativaUHE  idRestricaoOperativaUHE = idRestricaoOperativaUHE_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Determina o periodo inicial e periodo final
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


							const Periodo periodo_final = a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_final, Periodo());

							if (periodo_inicio < a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo()) || periodo_inicio > periodo_final)
								throw std::invalid_argument("Registro LQ - Periodo inicio nao correspondente aos limites da restricao");

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Filosofia: Atualiza se encontrar um valor 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							std::string limiteInferior;
							std::string limiteSuperior;

							const int line_size = int(line.length());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Patamar 1-5
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							SmartEnupla<Periodo, double> numero_patamares_x_periodo(horizonte_estudo, 0);

							int numero_patamar = 0;

							for (int patamar = 0; patamar < 5; patamar++) {

								limiteInferior = "";
								limiteSuperior = "";

								if (line_size >= 24 + 20 * patamar) {

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 4 - Limite inferior (hm3). 
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									limiteInferior = line.substr(14 + 20 * patamar, 10);
									limiteInferior.erase(std::remove(limiteInferior.begin(), limiteInferior.end(), ' '), limiteInferior.end());

								}//if (line_size >= 24 + 20 * patamar) {

								if (line_size >= 34 + 20 * patamar) {

									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									//Campo 5 - Limite superior (hm3).
									/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									limiteSuperior = line.substr(24 + 20 * patamar, 10);
									limiteSuperior.erase(std::remove(limiteSuperior.begin(), limiteSuperior.end(), ' '), limiteSuperior.end());

								}//if (line_size >= 34 + 20 * patamar) {

								if (limiteInferior != "" || limiteSuperior != "") {

									//Filosofia: Este tipo de restrição é carregada para todos os periodos

									IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga(patamar + 1);

									for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

										if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
											numero_patamares_x_periodo.at(periodo)++;

											const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo.at(periodo));

											if (limiteInferior != "") { a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_inf, periodo, idPatamarCarga, std::atof(limiteInferior.c_str())); }
											if (limiteSuperior != "") { a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_sup, periodo, idPatamarCarga, std::atof(limiteSuperior.c_str())); }

										}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

									}//for (Periodo periodo = periodo_inicio; periodo <= periodo_final; horizonte_estudo.at(periodo)) {

								}//if (limiteInferior != "" || limiteSuperior != "") {

							}//for (int patamar = 0; patamar < 5; patamar++) {
						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro LQ: \n" + std::string(erro.what())); }

					}//if (menemonico == "LQ") {

					if (menemonico == "CQ") {// Coeficientes das restrições RHQ 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da restrição de Volume, conforme campo 2 do registro HV
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Pode ocorrer que diferentes tipos de Restrição operativa das UHE tenham o mesmo código CEPEL; portanto, primeiro é
							// realizada uma seleção do tipo da restrição e logo uma procura pelo código CEPEL  asignado no registro HQ

							const int codigo_restricao_operativa_UHE_vazao_defluente = std::stoi(line.substr(4, 3));

							const IdRestricaoOperativaUHE idRestricaoOperativaUHE_inicializado = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_vazao_defluente, codigo_restricao_operativa_UHE_vazao_defluente);

							if (idRestricaoOperativaUHE_inicializado == IdRestricaoOperativaUHE_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoOperativaUHE  com codigo_restricao_operativa_UHE_vazao_defluente_" + atributo);

							const IdRestricaoOperativaUHE  idRestricaoOperativaUHE = idRestricaoOperativaUHE_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número do estágio, em ordem crescente.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							const IdEstagio idEstagio_inicial = IdEstagio(std::stoi(line.substr(9, 2)));

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Determina o periodo inicial e periodo final
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							Periodo periodo_inicio;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
									periodo_inicio = periodo;
									break;
								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const Periodo periodo_final = a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_final, Periodo());

							if (periodo_inicio < a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo()) || periodo_inicio > periodo_final)
								throw std::invalid_argument("Registro CQ - Periodo inicio nao correspondente aos limites da restricao");

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Coeficiente de cada variável na restrição RHQ. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							const double fator_participacao = std::stoi(line.substr(19, 10));

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 6 -  Tipos válidos para a variável na restrição RHQ:
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							string tipo_restricao_RHQ = line.substr(34, 4);
							tipo_restricao_RHQ.erase(std::remove(tipo_restricao_RHQ.begin(), tipo_restricao_RHQ.end(), ' '), tipo_restricao_RHQ.end());

							//Manual Referência: A restrição hidráulica de vazão defluente consiste em uma restrição que possibilita determinar faixas de operação para algumas variáveis do problema, 
							//como vazão defluente, desvios de água e bombeamentos. Além disso, este tipo de restrição permite que o usuário combine faixas de operação para essas variáveis

							if ((tipo_restricao_RHQ == "QDEF") || (tipo_restricao_RHQ == "QDES") || (tipo_restricao_RHQ == "QTUR") || (tipo_restricao_RHQ == "QVER")) { //Vazão defluênte ou vazão desviada de uma hidrelétrica

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4 -  Número da usina hidrelétrica, conforme campo 2 do registro UH
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(14, 3);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const int hidreletrica_codigo_usina = atoi(atributo.c_str());

								const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, hidreletrica_codigo_usina);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 6 -  Tipos válidos para a variável na restrição RHQ:
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								TipoVariavelRestricaoOperativa tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_Nenhum;

								if (tipo_restricao_RHQ == "QDEF")
									tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_vazao_defluente;
								else if (tipo_restricao_RHQ == "QDES")
									tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_vazao_desviada;
								else if (tipo_restricao_RHQ == "QTUR")
									tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_vazao_turbinada;
								else if (tipo_restricao_RHQ == "QVER")
									tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_vazao_vertida;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Guarda informação nos Smart Elementos
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								if (periodo_inicio == a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo())) {//Ainda não foi inicializado

									IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoOperativaUHE, IdElementoSistema());

									if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
									else { idElementoSistema++; }

									ElementoSistema elementoSistema;
									elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
									elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_hidreletrica);
									elementoSistema.setAtributo(AttComumElementoSistema_hidreletrica, idHidreletrica);
									elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, tipoVariavelRestricaoOperativa);

									//Inicializa o fator_participacao para o horizonte todo, porém no modelo são considerados somentes periodos com limites máximos e mínimos diferentes a "max" e "min"
									////////////////////////
									SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
										matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													matriz_fator_participacao.at(periodo).at(idPatamarCarga) = fator_participacao;

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

									/////////////////////////

									a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.add(elementoSistema);

								}//if (periodo_inicio == a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo())) {						
								else {

									const std::vector<IdElementoSistema> idElementoSistema_inicializada = a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.getIdObjetos(AttComumElementoSistema_hidreletrica, idHidreletrica);

									IdElementoSistema idElementoSistema = IdElementoSistema_Nenhum;

									//Uma mesma Restrição pode ter dois elementos associados à mesma hidrelétrica mas uma QDEF e outra QDES 

									for (int pos = 0; pos < int(idElementoSistema_inicializada.size()); pos++)
										if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema_inicializada.at(pos)).getAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa()) == tipoVariavelRestricaoOperativa)
											idElementoSistema = idElementoSistema_inicializada.at(pos);

									if (idElementoSistema == IdElementoSistema_Nenhum)
										throw std::invalid_argument("Restricao RHQ com idElementoSistema nao definido");


									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, idPatamarCarga, fator_participacao);

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) 

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								}//else {		

							}//if (tipo_restricao_RHQ == "QDEF" || tipo_restricao_RHQ == "QDES") {
							else if (tipo_restricao_RHQ == "QBOM") {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 4 -  Número da usina hidrelétrica, conforme campo 2 do registro UH
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(14, 3);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const int usina_elevatoria_codigo_usina = atoi(atributo.c_str());

								const IdUsinaElevatoria idUsinaElevatoria_inicializado = getIdFromCodigoONS(lista_codigo_ONS_usina_elevatoria, usina_elevatoria_codigo_usina);

								if (idUsinaElevatoria_inicializado == IdUsinaElevatoria_Nenhum)
									throw std::invalid_argument("Nao inicializada idUsinaElevatoria  com codigo_usina_" + atributo);

								const IdUsinaElevatoria  idUsinaElevatoria = idUsinaElevatoria_inicializado;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 6 -  Tipos válidos para a variável na restrição RHQ:
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								const TipoVariavelRestricaoOperativa tipoVariavelRestricaoOperativa = TipoVariavelRestricaoOperativa_vazao_bombeada;

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Guarda informação nos Smart Elementos
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////						

								if (periodo_inicio == a_dados.getAtributo(idRestricaoOperativaUHE, AttComumRestricaoOperativaUHE_periodo_inicio, Periodo())) {//Ainda não foi inicializado

									IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoOperativaUHE, IdElementoSistema());

									if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
									else { idElementoSistema++; }

									ElementoSistema elementoSistema;
									elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
									elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_usina_elevatoria);
									elementoSistema.setAtributo(AttComumElementoSistema_usina_elevatoria, idUsinaElevatoria);
									elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, tipoVariavelRestricaoOperativa);

									////////////////////////
									SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
										matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													matriz_fator_participacao.at(periodo).at(idPatamarCarga) = fator_participacao;

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

									/////////////////////////

									a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.add(elementoSistema);

								}//if (idEstagio_inicial == IdEstagio_1) {
								else {

									const std::vector<IdElementoSistema> idElementoSistema_inicializada = a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.getIdObjetos(AttComumElementoSistema_usina_elevatoria, idUsinaElevatoria);

									if (int(idElementoSistema_inicializada.size()) == 0)
										throw std::invalid_argument("Elemento do sistema na restrição RHQ nao instanciado");

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										int numero_patamares_x_periodo = 0;

										for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

												numero_patamares_x_periodo++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

												if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
													a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema_inicializada.at(0)).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, idPatamarCarga, fator_participacao);

												}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

										}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) 

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


								}//else {		

							}//else if (tipo_restricao_RHQ == "QBOM") {
						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro CQ: \n" + std::string(erro.what())); }

					}//if (menemonico == "CQ") {

					if (menemonico == "DA") {//Desvios de água cujo não atendimento é associado a um custo 

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina hidráulica a montante da qual será feita a retirada, conforme campo 2 dos registros UH 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número da usina hidráulica a montante da qual se dará o retorno da água, conforme campo 2 dos registros UH 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							IdHidreletrica idHidreletrica_jusante_desvio = IdHidreletrica_Nenhum;

							if (atributo != "") {

								const int jusante_desvio_codigo_usina = atoi(atributo.c_str());
								idHidreletrica_jusante_desvio = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, jusante_desvio_codigo_usina);

							}//if (atributo != "") {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Número do estágio, em ordem crescente 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(13, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Vazão a ser desviada, em m3/s 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(16, 6);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							double vazao_desviada = atof(atributo.c_str());

							/////////////////////////////
							const int line_size = int(line.length());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 6 -  Retorno em % da vazão desviada
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							double percentual_retorno_do_desvio = 0.0; //default

							if (line_size >= 30) {

								atributo = line.substr(24, 4);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (atributo != "")
									percentual_retorno_do_desvio = atof(atributo.c_str()) / 100;

							}//if (line_size >= 30) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 7 -  Custo de não atendimento ao desvio, em $/( hm3).
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							double penalidade_desvio_agua = 0.1; //Default -Ver 3.3.15 Penalidades Observação 1.

							if (line_size >= 45) {

								atributo = line.substr(34, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (atributo != "")
									penalidade_desvio_agua = atof(atributo.c_str());

							}//if (line_size >= 45) {

							////////////////////////
							if (idHidreletrica == idHidreletrica_jusante_desvio) //O retorno da água é para a própria usina
								vazao_desviada *= (1 - percentual_retorno_do_desvio);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Guarda informação nos Smart Elementos
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							/*
							if (idEstagio_inicial == IdEstagio_1) {


								const IdIntercambioHidraulico idIntercambioHidraulico = IdIntercambioHidraulico(a_dados.getMaiorId(IdIntercambioHidraulico()) + 1);

								IntercambioHidraulico intercambioHidraulico;
								intercambioHidraulico.setAtributo(AttComumIntercambioHidraulico_idIntercambioHidraulico, idIntercambioHidraulico);

								a_dados.vetorIntercambioHidraulico.add(intercambioHidraulico);

								a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setAtributo(AttComumIntercambioHidraulico_tipo_intercambio_hidraulico, TipoIntercambioHidraulico_retirada);

								a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setAtributo(AttComumIntercambioHidraulico_hidreletrica_origem, idHidreletrica);
								a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setAtributo(AttComumIntercambioHidraulico_hidreletrica_destino, idHidreletrica_jusante_desvio);
								//a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setAtributo(AttComumIntercambioHidraulico_penalidade_desvio_agua, penalidade_desvio_agua);
								a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setAtributo(AttComumIntercambioHidraulico_percentual_retorno_do_desvio, percentual_retorno_do_desvio);

								const SmartEnupla<Periodo, double> desvio_agua(horizonte_estudo, vazao_desviada);

								a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setVetor(AttVetorIntercambioHidraulico_desvio_agua_minimo, desvio_agua);
								a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setVetor(AttVetorIntercambioHidraulico_desvio_agua_maximo, desvio_agua);

							}//if (idEstagio_inicial == IdEstagio_1) {
							else {

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {


										//const IdIntercambioHidraulico idIntercambioHidraulico = a_dados.getMaiorId(IdIntercambioHidraulico()); //O último IdIntercambioHidraulico corresponde com o Id do desvio a modificar

										////////////////////////////////////////////////////////////////////
										//Identifica o idIntercambioHidraulico correspondente
										////////////////////////////////////////////////////////////////////

										IdIntercambioHidraulico idIntercambioHidraulico = IdIntercambioHidraulico_Nenhum;

										const std::vector<IdIntercambioHidraulico> idIntercambioHidraulico_inicializado = a_dados.vetorIntercambioHidraulico.getIdObjetos(AttComumIntercambioHidraulico_hidreletrica_origem, idHidreletrica);

										for (int pos = 0; pos < int(idIntercambioHidraulico_inicializado.size()); pos++) {

											if (a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico_inicializado.at(pos)).getAtributo(AttComumIntercambioHidraulico_hidreletrica_destino, IdHidreletrica()) == idHidreletrica_jusante_desvio) {

												idIntercambioHidraulico = idIntercambioHidraulico_inicializado.at(pos);
												break;

											}//if (a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico_inicializado.at(pos)).getAtributo(AttComumIntercambioHidraulico_hidreletrica_destino, IdHidreletrica()) == idHidreletrica_jusante_desvio) {

										}//for (int pos = 0; pos < int(idIntercambioHidraulico_inicializado.size()); pos++) {

										if (idIntercambioHidraulico == IdIntercambioHidraulico_Nenhum)
											throw std::invalid_argument("Registro DA - IntercambioHidraulico nao identificado");

										////////////////////////////////////////////////////////////////////

										a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setElemento(AttVetorIntercambioHidraulico_desvio_agua_minimo, periodo, vazao_desviada);
										a_dados.vetorIntercambioHidraulico.at(idIntercambioHidraulico).setElemento(AttVetorIntercambioHidraulico_desvio_agua_maximo, periodo, vazao_desviada);

									}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//else {
							*/

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial))
									desvio_registro_DA.at(idHidreletrica).setElemento(periodo, vazao_desviada);

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro DA: \n" + std::string(erro.what())); }

					}//if (menemonico == "DA") {

					if (menemonico == "AR") {//Aplicação do Mecanismo de Aversão ao Risco CVaR
						/*
						try {
						//Se este registro existe, significa que o problema considera CVaR

						a_dados.setAtributo(AttComumDados_tipo_aversao_a_risco, TipoAversaoRisco_CVAR);

						/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						//Campo 2 -  Número do estágio, em ordem crescente
						/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						atributo = line.substr(5, 3);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const IdEstagio idEstagio_inicial = getIdEstagioFromChar(atributo.c_str());

						const int line_size = int(line.length());

						double lambda;
						double alpha;

						if (line_size >= 22) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Valor do lambda (caso este campo seja deixado em branco será utilizado o valor empregado pelo Newave)
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(11, 5);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							if (atributo != "") {
								lambda = atof(atributo.c_str())/100;
							}//if (atributo != "") {
							else
								throw std::invalid_argument("Registro AR-Aversao ao Risco- sem valores do alpha - colocar os mesmos valores do NEWAVE do arquivo CVAR.DAT");

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Valor do alpha (caso este campo seja deixado em branco será utilizado o valor empregado pelo Newave)
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(17, 5);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							if (atributo != "") {
								alpha = atof(atributo.c_str()) / 100;
							}//if (atributo != "") {
							else
								throw std::invalid_argument("Registro AR-Aversao ao Risco- sem valores do lambda - colocar os mesmos valores do NEWAVE do arquivo CVAR.DAT");

						}//if (line_size >= 22) {
						else
							throw std::invalid_argument("Registro AR-Aversao ao Risco- sem valores do alpha e lambda - colocar os mesmos valores do NEWAVE do arquivo CVAR.DAT");

						/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
						//Guarda informação nos Smart Elementos
						/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

						const SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());

						if (idEstagio_inicial == IdEstagio_1) {

							const IdEstagio idEstagio_Maior = horizonte_otimizacao.getIteradorFinal();

							std::vector<double> lambda_vetor(int(idEstagio_Maior), lambda);
							std::vector<double> alpha_vetor(int(idEstagio_Maior), alpha);

							const SmartEnupla<IdEstagio, double> lambda_CVAR(IdEstagio_1, lambda_vetor);
							const SmartEnupla<IdEstagio, double> alpha_CVAR (IdEstagio_1, alpha_vetor);

							a_dados.setVetor(AttVetorDados_lambda_CVAR, lambda_CVAR);
							a_dados.setVetor(AttVetorDados_alpha_CVAR, alpha_CVAR);

						}//if (idEstagio_inicial == IdEstagio_1) {
						else {

							for (IdEstagio idEstagio = horizonte_otimizacao.getIteradorInicial(); idEstagio <= horizonte_otimizacao.getIteradorFinal(); idEstagio++) {

								//Inicialmente, identifica o IdEstagio do SPT com base no periodo do horizonte_otimizacao_DC do IdEstagio DECOMP

								IdEstagio IdEstagio_teste;

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {
										IdEstagio_teste = horizonte_estudo.at(periodo);
										break;
									}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								//Atualiza os dados do lambda e alpha

								if (idEstagio >= IdEstagio_teste) {
									a_dados.setElemento(AttVetorDados_lambda_CVAR, idEstagio, lambda);
									a_dados.setElemento(AttVetorDados_alpha_CVAR, idEstagio, alpha);

								}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_inicial)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						}//else {


						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro AR: \n" + std::string(erro.what())); }
						*/
					}//if (menemonico == "AR") {

					if (menemonico == "EV") {//Evaporação

						try {
							TipoModeloEvaporacao tipo_modelo_evaporacao = TipoModeloEvaporacao_tradicional_fora_do_PL;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Modelo para cálculo da vazão evaporada:   0-modelo tradicional por fora do PL;   1-modelo linear. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(5, 1);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int modelo = atoi(atributo.c_str());

							/////////////////////////////////////////

							const int line_size = int(line.length());

							if (modelo == 1 && line_size >= 12) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Campo 3 -  Para o caso do campo 2 ser igual a “1”, deve-se informar o volume de referência a ser utilizado:   INI – Utiliza o volume inicial como volume de referência;  MED – Utiliza o volume útil médio como referência
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								atributo = line.substr(9, 3);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								/*
								if (atributo == "INI")
									tipo_modelo_evaporacao = TipoModeloEvaporacao_lineal_volume_inicial;
								else if (atributo == "MED")
									tipo_modelo_evaporacao = TipoModeloEvaporacao_lineal_volume_medio;

															*/

							}//if (modelo == 1 && line_size >= 12) {

							//a_dados.setAtributo(AttComumDados_tipo_modelo_evaporacao, tipo_modelo_evaporacao);
						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro EV: \n" + std::string(erro.what())); }

					}//if (menemonico == "EV") {

					if (menemonico == "RQ") {//Vazão defluente mínima histórica

						try {

							if (inicializa_vetor_porcentagem_vazao_minima_historica_REE) {

								for (int ree = 1; ree <= maior_ONS_REE; ree++)
									porcentagem_vazao_minima_historica_REE.addElemento(ree, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));

								inicializa_vetor_porcentagem_vazao_minima_historica_REE = false;
							}//if (inicializa_vetor_porcentagem_vazao_minima_historica_REE) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 - Número do Reservatório equivalente. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_ONS_REE = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 - Percentual da vazão mínima histórica para cada estágio, em %. Valor default = 80 %
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							const int line_size = int(line.length());

							const int maiorEstagio_DC = int(horizonte_otimizacao_DC.size());

							for (int estagio_DC = 0; estagio_DC < maiorEstagio_DC; estagio_DC++) {

								double percentual_vazao_defluente_minima_historica = 0.8; //default

								if (line_size >= (14 + 5 * estagio_DC)) {

									atributo = line.substr(9 + 5 * estagio_DC, 5);
									atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

									if (atributo != "")
										percentual_vazao_defluente_minima_historica = atof(atributo.c_str()) / 100;

								}//if (line_size >= (14 + 5 * estagio_DC)) {

								bool sobreposicao_encontrada = false;

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(IdEstagio(estagio_DC + 1)));

									if (sobreposicao == 1) {
										porcentagem_vazao_minima_historica_REE.at(codigo_ONS_REE).setElemento(periodo, percentual_vazao_defluente_minima_historica);
										sobreposicao_encontrada = true;
									}

									if (sobreposicao == 0 && sobreposicao_encontrada)
										break;

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//for (int estagio_DC = 1; estagio_DC <= maiorEstagio_DC; estagio_DC++) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro RQ: \n" + std::string(erro.what())); }

					}//if (menemonico == "RQ") {

					if (menemonico == "HE") {//Identificação das restrições RHE: Restrições de energia armazenada

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número de identificação da restrição RHE
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const string nome = atributo;

							const int codigo_restricao_operativa_RHE_energia = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Flag para identificação do tipo de limite para a restrição:
							//           = 1 – em valor absoluto(MWmes).
							//	         = 2 – em valor percentual da Energia Armazenada Máxima do REE(%).
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 1);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int tipo_limite_restricao = atoi(atributo.c_str());

							TipoUnidadeRestricaoHidraulica tipoUnidadeRestricaoHidraulica = TipoUnidadeRestricaoHidraulica_percentual;

							if (tipo_limite_restricao == 1)
								tipoUnidadeRestricaoHidraulica = TipoUnidadeRestricaoHidraulica_MW;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Limite inferior para a Energia Armazenada pela restrição RHE.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double limite_inferior = atof(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 5 -  Estágio da restrição. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(25, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdEstagio idEstagio = getIdEstagioFromChar(atributo.c_str());

							const Periodo periodo_DECK = horizonte_otimizacao_DC.at(idEstagio);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 6 -  Valor de penalidade para a restrição (R$/MWh) (se for deixado em branco, considera - se a penalidade default utilizada para as demais restrições)
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(28, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							double penalidade = 10000; //default atribuido

							if(atributo != "")
								penalidade = atof(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 9 -  Flag para indicar o tratamento dado ao não atendimento da restrição:
							//= 0 (ou branco) – não atendimento tratado como inviabilidade
							//= 1 – não atendimento tratado como utilização de um recurso e não produzem inviabilidades
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(43, 1);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							double limite_superior_folga_inferior = getdoubleFromChar("max");

							if (atributo == "")							
								limite_superior_folga_inferior = 0.0;						
							else if (atoi(atributo.c_str()) == 0)
								limite_superior_folga_inferior = 0.0;

							//Nota: Alguns decks repetem por erro o mesmo registro, portanto, é verificado que a restriçao nao tenha sido inicializada.
							//Caso contrário, verifica que o periodo_inicial e periodo_final do registro duplicado seja igual à restriçao instanciada
							IdRestricaoOperativaUHE idRestricaoOperativaUHE = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_energia_armazenada, codigo_restricao_operativa_RHE_energia);

							if (idRestricaoOperativaUHE == IdRestricaoOperativaUHE_Nenhum) {

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Guarda informação nos Smart Elementos
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								RestricaoOperativaUHE restricaoOperativaUHE;

								idRestricaoOperativaUHE = a_dados.getMaiorId(IdRestricaoOperativaUHE());

								if (idRestricaoOperativaUHE == IdRestricaoOperativaUHE_Nenhum)
									idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1;
								else
									idRestricaoOperativaUHE++;

								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_idRestricaoOperativaUHE, idRestricaoOperativaUHE);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_nome, nome);

								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoHidraulica, TipoRestricaoHidraulica_energia_armazenada);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_tipoUnidadeRestricaoHidraulica, tipoUnidadeRestricaoHidraulica);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_penalidade, penalidade);
								restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_vlr_ini, getdoubleFromChar("max"));

								lista_codigo_ONS_restricao_operativa_UHE_energia_armazenada.setElemento(idRestricaoOperativaUHE, codigo_restricao_operativa_RHE_energia);

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Inicializa matrizes minimo e maximo
								// Nota: É instanciada as matrizes com min/max e depois atualizado só nos períodos com sobreposição com periodo_DECK 
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								/////////////////////////////////////

								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_limite_inferior(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_limite_superior(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									matriz_limite_inferior.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("min"))));
									matriz_limite_superior.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("max"))));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								/////////////////////////////////////
								//Instancia as matrizes
								restricaoOperativaUHE.setMatriz(AttMatrizRestricaoOperativaUHE_lim_inf, matriz_limite_inferior);
								restricaoOperativaUHE.setMatriz(AttMatrizRestricaoOperativaUHE_lim_sup, matriz_limite_superior);
								/////////////////////////////////////
								//Instancia as vetores
								// 
								restricaoOperativaUHE.setVetor(AttVetorRestricaoOperativaUHE_lim_sup_folga_inf, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));
								
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Carrega restrição
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								a_dados.vetorRestricaoOperativaUHE.add(restricaoOperativaUHE);

							}//if (idRestricaoOperativaUHE == IdRestricaoOperativaUHE_Nenhum)

							//////////////////////////////////////////////////
							//Validação tipoUnidadeRestricaoHidraulica
							//////////////////////////////////////////////////
							if (tipoUnidadeRestricaoHidraulica != a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getAtributo(AttComumRestricaoOperativaUHE_tipoUnidadeRestricaoHidraulica, TipoUnidadeRestricaoHidraulica()))
								throw std::invalid_argument("tipoUnidadeRestricaoHidraulica nao consistente entre registros HE na restricao hidrualica numero: " + nome);

							//////////////////////////////////////////////////
							//Atualiza o limite_inferior no periodo indicado
							//////////////////////////////////////////////////

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										const double sobreposicao = periodo.sobreposicao(periodo_DECK);

										if (sobreposicao > 0.0)
											a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_inf, periodo, idPatamarCarga, limite_inferior);

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							//////////////////////////////////////////////////
							//Atualiza vetor limite_superior_folga_inferior no periodo indicado
							//////////////////////////////////////////////////
							bool is_sobreposicao_encontrado = false;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								const double sobreposicao = periodo.sobreposicao(periodo_DECK);

								if (sobreposicao > 0.0) {
									is_sobreposicao_encontrado = true;
									a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttVetorRestricaoOperativaUHE_lim_sup_folga_inf, periodo, limite_superior_folga_inferior);
								}//if (sobreposicao > 0.0) {

								if (is_sobreposicao_encontrado && sobreposicao == 0.0)
									break;

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro HV: \n" + std::string(erro.what())); }

					}//if (menemonico == "HE") {

					if (menemonico == "CM") {//Coeficientes das restrições RHV

						try {
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número de identificação da restrição RHE
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_restricao_operativa_RHE_energia = atoi(atributo.c_str());

							const IdRestricaoOperativaUHE idRestricaoOperativaUHE = getIdFromCodigoONS(lista_codigo_ONS_restricao_operativa_UHE_energia_armazenada, codigo_restricao_operativa_RHE_energia);

							if (idRestricaoOperativaUHE == IdRestricaoOperativaUHE_Nenhum)
								throw std::invalid_argument("Nao inicializada idRestricaoOperativaUHE  com codigo_restricao_operativa_UHE_energia_armazenada_" + atributo);

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Índice do Reservatório Equivalente de Energia (REE)
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const IdReservatorioEquivalente idReservatorioEquivalente = IdReservatorioEquivalente(atoi(atributo.c_str()));

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 4 -  Coeficiente de participação do REE definido no campo 3 na restrição definida no campo 2
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(14, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double fator_participacao = atof(atributo.c_str());

							if (fator_participacao != 1.0)
								throw std::invalid_argument("fator_participacao != 1.0 para restricao_operativa_UHE_energia_armazenada");

							/////////////////////////////////////////////////////////////////////////////////////////////////////
							//Set o idReservatorioEquivalente da restrição, depois vão ser atualizados os elementos da restrição 
							// quando as probabilidades_aculadas_EAR sejam calculadas
							/////////////////////////////////////////////////////////////////////////////////////////////////////
							
							int aux_pos_codigo_restricao_energia_armazenada = -1;

							for (int pos_codigo_restricao_energia_armazenada = 1; pos_codigo_restricao_energia_armazenada <= int(codigo_restricao_energia_armazenada.size()); pos_codigo_restricao_energia_armazenada++) {

								if (codigo_restricao_energia_armazenada.getElemento(pos_codigo_restricao_energia_armazenada) == codigo_restricao_operativa_RHE_energia) {
									aux_pos_codigo_restricao_energia_armazenada = pos_codigo_restricao_energia_armazenada;
									break;

								}//if (codigo_restricao_energia_armazenada.getElemento(pos_codigo_restricao_energia_armazenada) == codigo_restricao_operativa_RHE_energia) {

							}//for (int pos_codigo_restricao_energia_armazenada = 1; pos_codigo_restricao_energia_armazenada <= int(codigo_restricao_energia_armazenada.size()); pos_codigo_restricao_energia_armazenada++) {


							if (aux_pos_codigo_restricao_energia_armazenada == -1) {
								codigo_restricao_energia_armazenada.addElemento(int(codigo_restricao_energia_armazenada.size()) + 1, codigo_restricao_operativa_RHE_energia);
								idReservatorioEquivalente_restricao_energia_armazenada.addElemento(int(idReservatorioEquivalente_restricao_energia_armazenada.size()) + 1, idReservatorioEquivalente);

							}
							else {

								if (idReservatorioEquivalente_restricao_energia_armazenada.getElemento(aux_pos_codigo_restricao_energia_armazenada) != idReservatorioEquivalente)
									throw std::invalid_argument("idReservatorioEquivalente diferente para restricao_operativa_UHE_energia_armazenada registro: " + line);

							}

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro CM: \n" + std::string(erro.what())); }

					}//if (menemonico == "CM") {

				}//if (teste_comentario != COMENTARIO) {

			}// while (std::getline(leituraArquivo, line))

			leituraArquivo.clear();
			leituraArquivo.close();

			//Faz a soma dos desvios dos registros TI + DA
			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				bool vetor_vazo_retirado_inicializado = false;
				if (a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(AttVetorHidreletrica_vazao_retirada) > 0)
					vetor_vazo_retirado_inicializado = true;

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					if (vetor_vazo_retirado_inicializado) {
						double vazao_retirada = a_dados.vetorHidreletrica.at(idHidreletrica).getElementoVetor(AttVetorHidreletrica_vazao_retirada, periodo, double());
						vazao_retirada += desvio_registro_DA.at(idHidreletrica).getElemento(periodo);

						a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_vazao_retirada, periodo, vazao_retirada);

					}//if (vetor_vazo_retirado_inicializado) {
					else {

						double vazao_retirada = desvio_registro_DA.at(idHidreletrica).getElemento(periodo);
						a_dados.vetorHidreletrica.at(idHidreletrica).addElemento(AttVetorHidreletrica_vazao_retirada, periodo, vazao_retirada);

					}//else {

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

		} // if (leituraArquivo.is_open()) 

		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	} //try 
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_DECOMP_29_DADGER: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_DADGNL_201906_DC29_A(Dados& a_dados, std::string nomeArquivo, std::string nomeArquivo_pastaRaiz_relgnl, std::string nomeArquivo_pastaAdicionais_relgnl) {
	try {

		std::ifstream leituraArquivo(nomeArquivo);

		//Horizonte de estudo
		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		if (leituraArquivo.is_open()) {

			std::string line;
			std::string atributo;

			const IdTermeletrica	idTermeletricaIni = a_dados.getMenorId(IdTermeletrica());
			const IdTermeletrica	idTermeletricaEnd = a_dados.getMaiorId(IdTermeletrica());

			SmartEnupla<IdTermeletrica, SmartEnupla<Periodo, double>> lista_termeletrica_potencia_pre_comandada(idTermeletricaIni, std::vector<SmartEnupla<Periodo, double>>(int(idTermeletricaEnd - idTermeletricaIni) + 1, SmartEnupla<Periodo, double>()));

			//Informaçao necessária para ler arquivo relgnl.rvX (caso seja necessário)
			std::vector<int> codigo_gnl;
			std::vector<std::string> nome_gnl;

			while (std::getline(leituraArquivo, line)) {

				strNormalizada(line);

				if (line.substr(0, 1) != "&") {

					std::string menemonico = line.substr(0, 2);

					if (menemonico == "TG") {//

						try {

							IdTermeletrica idTermeletrica;

							const int codigo_usina = std::stoi(line.substr(4, 3));

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, std::stoi(line.substr(9, 2)));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);

							const string nome = line.substr(14, 10);

							//Campo 5 -   Índice do estágio. 	
							const IdEstagio idEstagio_termeletrica = IdEstagio(std::stoi(line.substr(24, 2)));

							if (idEstagio_termeletrica == IdEstagio_1) { //termelétrica não inicializada

								idTermeletrica = getIdFromCodigoONS(lista_codigo_ONS_termeletrica, codigo_usina);

								if (idTermeletrica == IdTermeletrica_Nenhum) {
									idTermeletrica = IdTermeletrica(codigo_usina);
									Termeletrica termeletrica;
									termeletrica.setAtributo(AttComumTermeletrica_idTermeletrica, idTermeletrica);
									termeletrica.setAtributo(AttComumTermeletrica_codigo_usina, codigo_usina);
									termeletrica.setAtributo(AttComumTermeletrica_nome, nome);
									a_dados.vetorTermeletrica.add(termeletrica);
									lista_codigo_ONS_termeletrica.setElemento(idTermeletrica, codigo_usina);
								}

								a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_submercado, idSubmercado);
								a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_nome, nome);
								a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_considerar_usina, true);
								a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoTermeletrica_por_usina);

								codigo_gnl.push_back(codigo_usina);
								nome_gnl.push_back(nome);

							} // if (idEstagio_termeletrica == IdEstagio_1) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro TG: \n" + std::string(erro.what())); }

					}//if (menemonico == "TG") {

					if (menemonico == "GS") {

						try {

							//Filosofia: Carregar o número de semanas de cada mês do estudo (até um mês na frente) e ao finalizar a leitura de todos os registros criar um SmartEnupla

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Índice do mês. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(4, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							int mes = atoi(atributo.c_str());

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -  Número de intervalos de tempo do referido mês.
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							atributo = line.substr(9, 1);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int numero_semanas_no_mes = atoi(atributo.c_str());

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro GS: \n" + std::string(erro.what())); }

					}//if (menemonico == "GS") {

					if (menemonico == "NL") {//Lag de antecipação de despacho das usinas térmicas GNL

						try {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina térmica
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//codigo_usina
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							//Identifica se alguma termelétrica tem sido inicializada com codigo_usina
							const IdTermeletrica idTermeletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_termeletrica, codigo_usina);

							if (idTermeletrica_inicializado == IdTermeletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idTermeletrica com codigo_usina_" + atributo);

							const IdTermeletrica idTermeletrica = idTermeletrica_inicializado;

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 3 -   Índice do subsistema ao qual pertence a usina. 
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							atributo = line.substr(9, 2);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							//Identifica se alguma termelétrica tem sido inicializada com codigo_usina

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, atoi(atributo.c_str()));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);


							//Campo 4 -  Lag de antecipação de despacho
							a_dados.vetorTermeletrica.at(idTermeletrica).setAtributo(AttComumTermeletrica_lag_mensal_potencia_disponivel_comandada, std::stoi(line.substr(14, 1)));

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro NL: \n" + std::string(erro.what())); }

					}//if (menemonico == "NL") {

					if (menemonico == "GL") {//Gerações já comandadas de usinas térmicas GNL 

						try {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Campo 2 -  Número da usina térmica
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//codigo_usina
							atributo = line.substr(4, 3);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							//Identifica se alguma termelétrica tem sido inicializada com codigo_usina
							const IdTermeletrica idTermeletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_termeletrica, codigo_usina);

							if (idTermeletrica_inicializado == IdTermeletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idTermeletrica com codigo_usina_" + atributo);

							const IdTermeletrica idTermeletrica = idTermeletrica_inicializado;

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, std::stoi(line.substr(9, 2)));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);

							const int semana_comandada = std::stoi(line.substr(14, 2));

							
							////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							// Campos 5-X - Geração comandada, em MWmed, por patamar e Dia de início da semana operativa / Mês de início da semana operativa / Ano de início da semana operativa
							// Manual: Os campos "dia", "mês" e "ano de início da semana operativa" será o campo imediatamente após o campo de duração do último patamar
							////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							const IdPatamarCarga maiorIdPatamarCarga = a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, a_dados.getIterador1Inicial(AttMatrizDados_percentual_duracao_patamar_carga, Periodo()), IdPatamarCarga());

							const int numero_patamares = int(maiorIdPatamarCarga);

							///////////////////////////////////////
							// Campos "dia", "mês" e "ano 
							///////////////////////////////////////		
	

							Periodo periodo_comandado(TipoPeriodo_semanal, std::stoi(line.substr(20 + 15 * numero_patamares, 2)), std::stoi(line.substr(22 + 15 * numero_patamares, 2)), \
								std::stoi(line.substr(24 + 15 * numero_patamares, 4)));


							bool is_periodo_comandado_in_horizonte_estudo = false;

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								const double sobreposicao = periodo.sobreposicao(periodo_comandado);

								if (sobreposicao > 0) {
									is_periodo_comandado_in_horizonte_estudo = true;
									break;

								}//if (sobreposicao > 0) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


							///////////////////////////////////////////////////
							//Inicializa matriz potencia_disponivel_comandada
							///////////////////////////////////////////////////

							if (is_periodo_comandado_in_horizonte_estudo = true) {

								if (a_dados.vetorTermeletrica.at(idTermeletrica).getSizeMatriz(AttMatrizTermeletrica_potencia_disponivel_comandada) == 0) {


									SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
										matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									a_dados.vetorTermeletrica.at(idTermeletrica).setMatriz(AttMatrizTermeletrica_potencia_disponivel_comandada, matriz_zero);

								}//if (a_dados.vetorTermeletrica.at(idTermeletrica).getSizeMatriz(AttMatrizTermeletrica_potencia_disponivel_comandada) == 0) {


							}//if (is_periodo_comandado_in_horizonte_estudo = true) {
							else {

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= maiorIdPatamarCarga; idPatamarCarga_DECK++) {
									a_dados.vetorTermeletrica.at(idTermeletrica).addElemento(AttMatrizTermeletrica_potencia_disponivel_comandada, periodo_comandado, idPatamarCarga_DECK, 0.0);
								}


							}



							/////////////////////////////////////////////////////////////////////////////
							SmartEnupla<Periodo, int> numero_patamares_x_periodo(horizonte_estudo, 0);

							for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= maiorIdPatamarCarga; idPatamarCarga_DECK++) {

								atributo = line.substr(19 + 15 * (int(idPatamarCarga_DECK) - 1), 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const double potencia = atof(atributo.c_str());

								atributo = line.substr(29 + 15 * (int(idPatamarCarga_DECK) - 1), 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								double horas_patamar = atof(atributo.c_str());

								if (horas_patamar == 0.0)
									horas_patamar = 168.0 / double(numero_patamares);


								if (is_periodo_comandado_in_horizonte_estudo) {

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const double sobreposicao = periodo.sobreposicao(periodo_comandado);

										if (sobreposicao > 0) {

											if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
												numero_patamares_x_periodo.at(periodo)++;

												const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo.at(periodo));
												a_dados.vetorTermeletrica.at(idTermeletrica).setElemento(AttMatrizTermeletrica_potencia_disponivel_comandada, periodo, idPatamarCarga, potencia * sobreposicao);

											}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {


										}//if (sobreposicao > 0) {

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorInicial(); horizonte_estudo.incrementarIterador(periodo)) {

								}
								else
									a_dados.vetorTermeletrica.at(idTermeletrica).setElemento(AttMatrizTermeletrica_potencia_disponivel_comandada, periodo_comandado, idPatamarCarga_DECK, potencia);


							}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= maiorIdPatamarCarga; idPatamarCarga_DECK++) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro GL: \n" + std::string(erro.what())); }

					}//if (menemonico == "GL") {

				}//if (teste_comentario != "&") {

			}//while (std::getline(leituraArquivo, line)) {

			leituraArquivo.clear();
			leituraArquivo.close();

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_DADGNL_201906_DC29_A: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_DADGNL_201906_DC29_B(Dados& a_dados, const std::string a_diretorio, const std::string nomeArquivo) {
	try {

		std::ifstream leituraArquivo(a_diretorio + "\\" + nomeArquivo);

		if (leituraArquivo.is_open()) {

			std::string line;
			std::string atributo;

			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			while (std::getline(leituraArquivo, line)) {

				strNormalizada(line);

				if (line.substr(0, 1) != "&") {

					std::string menemonico = line.substr(0, 2);

					if (menemonico == "TG") {//Usinas térmicas

						try {

							IdTermeletrica idTermeletrica;

							const int codigo_usina = std::stoi(line.substr(4, 3));

							const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, std::stoi(line.substr(9, 2)));

							if (idSubmercado == IdSubmercado_Nenhum)
								throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);

							const string nome = line.substr(14, 10);

							//Campo 5 -   Índice do estágio. 	
							const IdEstagio idEstagio_termeletrica = IdEstagio(std::stoi(line.substr(24, 2)));

							const int line_size = int(line.length());
							int numero_patamares = 0;

							//Vetores com informação por patamar
							std::vector<double> potencia_minima;
							std::vector<double> potencia_maxima;
							std::vector<double> custo_operacao;

							//Campos 6 - 7 - 8  
							if (line_size >= 49) {//Por cada patamar são feito 3 registros: potencia_minima, potencia_maxima, custo_operacao
								numero_patamares++;
								potencia_minima.push_back(std::stod(line.substr(29, 5)));
								potencia_maxima.push_back(std::stod(line.substr(34, 5)));
								custo_operacao.push_back(std::stod(line.substr(39, 10)));
							}//if (line_size >= 49) {

							//Campos 9 - 10 - 11 
							if (line_size >= 69) {
								numero_patamares++;
								potencia_minima.push_back(std::stod(line.substr(49, 5)));
								potencia_maxima.push_back(std::stod(line.substr(54, 5)));
								custo_operacao.push_back(std::stod(line.substr(59, 10)));
							}//if (line_size >= 69) {

							//Campos 12 - 13 - 14
							if (line_size >= 89) {
								numero_patamares++;
								potencia_minima.push_back(std::stod(line.substr(69, 5)));
								potencia_maxima.push_back(std::stod(line.substr(74, 5)));
								custo_operacao.push_back(std::stod(line.substr(79, 10)));
							}//if (line_size >= 89) {

							//Campos 15 - 16 - 17 
							if (line_size >= 109) {
								numero_patamares++;
								potencia_minima.push_back(std::stod(line.substr(89, 5)));
								potencia_maxima.push_back(std::stod(line.substr(94, 5)));
								custo_operacao.push_back(std::stod(line.substr(99, 10)));
							}//if (line_size >= 109) {

							//Campos 18 - 19 - 20
							if (line_size >= 129) {
								numero_patamares++;
								potencia_minima.push_back(std::stod(line.substr(109, 5)));
								potencia_maxima.push_back(std::stod(line.substr(114, 5)));
								custo_operacao.push_back(std::stod(line.substr(119, 10)));
							}//if (line_size >= 129) {

							/////////////////////////////////////////
							//Guarda a informação nos SmartElementos
							/////////////////////////////////////////

							//Filosofia: A informação registrada é válida para o idEstagio >= idEstagio_leitura: No primeiro estágio preenche todos 
							//           os valores dos estágios restantes e logo é sobreescrita a informação para idEstágio > 1


							/////////////////////////////////////

							SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
								matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							/////////////////////////////////////



							if (idEstagio_termeletrica == IdEstagio_1) { //termelétrica não inicializada

								idTermeletrica = getIdFromCodigoONS(lista_codigo_ONS_termeletrica, codigo_usina);

								//Cria vetores potencia_minima, potencia_maxima, custo_de_operacao

								a_dados.vetorTermeletrica.at(idTermeletrica).setMatriz(AttMatrizTermeletrica_custo_de_operacao, matriz_zero);

								//Inicializa uma unidade termelétrica (necessário para a validação das termelétricas)
								UnidadeUTE unidadeUTE;
								unidadeUTE.setAtributo(AttComumUnidadeUTE_idUnidadeUTE, IdUnidadeUTE_1);
								unidadeUTE.setMatriz(AttMatrizUnidadeUTE_potencia_util, matriz_zero);
								unidadeUTE.setMatriz(AttMatrizUnidadeUTE_potencia_minima, matriz_zero);
								unidadeUTE.setMatriz(AttMatrizUnidadeUTE_potencia_maxima, matriz_zero);
								unidadeUTE.setMatriz(AttMatrizUnidadeUTE_custo_de_operacao, matriz_zero);
								a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.add(unidadeUTE);

								a_dados.vetorTermeletrica.at(idTermeletrica).setMatriz(AttMatrizTermeletrica_potencia_disponivel_minima, matriz_zero);
								a_dados.vetorTermeletrica.at(idTermeletrica).setMatriz(AttMatrizTermeletrica_potencia_disponivel_maxima, matriz_zero);

							}//if (idEstagio_termeletrica == IdEstagio_1) {

							//Identifica se alguma termelétrica tem sido inicializada com codigo_usina
							const IdTermeletrica idTermeletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_termeletrica, codigo_usina);

							if (idTermeletrica_inicializado == IdTermeletrica_Nenhum)
								throw std::invalid_argument("Nao inicializada idTermeletrica com codigo_usina_" + getString(codigo_usina));

							idTermeletrica = idTermeletrica_inicializado;

							//***********************************************************************************************************************
							//No arquivo DADGNL, estágio refere-se a o número da semana dentro do horizonte de planejamento, por tanto, a atualização 
							//dos dados das termelétricas é realizado por meio da comparação da data correspondente à semana reportada
							//***********************************************************************************************************************

							Periodo periodo_teste = data_execucao + 1;

							for (IdEstagio idEstagio = IdEstagio_1; idEstagio < idEstagio_termeletrica; idEstagio++) {

								//Aumenta a data até contar (idEstagio-1) semanas = data do inicio da semana ao qual corresponde a info
								for (int conteio = 0; conteio < 7; conteio++)
									periodo_teste = periodo_teste + 1; //periodo_teste é um periodo diário e o aumento é por dia

							}//for (IdEstagio idEstagio = IdEstagio_1; idEstagio < idEstagio_termeletrica; idEstagio++) {


							if (a_dados.getSize1Matriz(idTermeletrica, IdUnidadeUTE_1, AttMatrizUnidadeUTE_potencia_minima) == 0) {

								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> potenciaZero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									potenciaZero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, a_dados.getAtributo(idTermeletrica, IdUnidadeUTE_1, AttComumUnidadeUTE_potencia_minima, double()))));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.at(IdUnidadeUTE_1).setMatriz(AttMatrizUnidadeUTE_potencia_minima, potenciaZero);
							}

							if (a_dados.getSize1Matriz(idTermeletrica, IdUnidadeUTE_1, AttMatrizUnidadeUTE_potencia_maxima) == 0) {

								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> potenciaZero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									potenciaZero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, a_dados.getAtributo(idTermeletrica, IdUnidadeUTE_1, AttComumUnidadeUTE_potencia_maxima, double()))));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.at(IdUnidadeUTE_1).setMatriz(AttMatrizUnidadeUTE_potencia_maxima, potenciaZero);
							}

							if (a_dados.getSize1Matriz(idTermeletrica, AttMatrizTermeletrica_potencia_disponivel_minima) == 0) {

								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> potenciaZero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									potenciaZero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, a_dados.getAtributo(idTermeletrica, IdUnidadeUTE_1, AttComumUnidadeUTE_potencia_minima, double()))));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								a_dados.vetorTermeletrica.at(idTermeletrica).setMatriz(AttMatrizTermeletrica_potencia_disponivel_minima, potenciaZero);
							}

							if (a_dados.getSize1Matriz(idTermeletrica, AttMatrizTermeletrica_potencia_disponivel_maxima) == 0) {

								SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> potenciaZero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									potenciaZero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, a_dados.getAtributo(idTermeletrica, IdUnidadeUTE_1, AttComumUnidadeUTE_potencia_maxima, double()))));

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								a_dados.vetorTermeletrica.at(idTermeletrica).setMatriz(AttMatrizTermeletrica_potencia_disponivel_maxima, potenciaZero);
							}

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);

										if (periodo >= periodo_teste) {


											a_dados.vetorTermeletrica.at(idTermeletrica).setElemento(AttMatrizTermeletrica_potencia_disponivel_minima, periodo, idPatamarCarga, potencia_minima.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorTermeletrica.at(idTermeletrica).setElemento(AttMatrizTermeletrica_potencia_disponivel_maxima, periodo, idPatamarCarga, potencia_maxima.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));

											a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.at(IdUnidadeUTE_1).setElemento(AttMatrizUnidadeUTE_potencia_minima, periodo, idPatamarCarga, potencia_minima.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.at(IdUnidadeUTE_1).setElemento(AttMatrizUnidadeUTE_potencia_maxima, periodo, idPatamarCarga, potencia_maxima.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.at(IdUnidadeUTE_1).setElemento(AttMatrizUnidadeUTE_potencia_util, periodo, idPatamarCarga, potencia_maxima.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1) - potencia_minima.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorTermeletrica.at(idTermeletrica).setElemento(AttMatrizTermeletrica_custo_de_operacao, periodo, idPatamarCarga, custo_operacao.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));
											a_dados.vetorTermeletrica.at(idTermeletrica).vetorUnidadeUTE.at(IdUnidadeUTE_1).setElemento(AttMatrizUnidadeUTE_custo_de_operacao, periodo, idPatamarCarga, custo_operacao.at(getintFromChar(getString(idPatamarCarga_DECK).c_str()) - 1));


										}//if (periodo >= horizonte_otimizacao_DC.at(idEstagio_termeletrica)) {

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						}//try {
						catch (const std::exception& erro) { throw std::invalid_argument("Erro Registro TG: \n" + std::string(erro.what())); }

					}//if (menemonico == "TG") {

					if (menemonico == "GS") {

					}//if (menemonico == "GS") {

					if (menemonico == "NL") {//Lag de antecipação de despacho das usinas térmicas GNL

					}//if (menemonico == "NL") {

					if (menemonico == "GL") {//Gerações já comandadas de usinas térmicas GNL 

					}//if (menemonico == "GL") {

				}//if (teste_comentario != "&") {

			}//while (std::getline(leituraArquivo, line)) {

			leituraArquivo.clear();
			leituraArquivo.close();

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_DADGNL_201906_DC29_B: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_PERDAS_201906_DC29(Dados& a_dados, std::string nomeArquivo)
{

	//Filosofia: se todos os campos são 9999 então não carrega nenhum matriz no programa, logo se a matriz tem o iterador_nenhum, significa que tudo é zero

	try {

		std::ifstream leituraArquivo(nomeArquivo);
		std::string line;

		std::string atributo;

		////////////////////////////////////////////////////////

		if (leituraArquivo.is_open()) {

			//******************************
			//Bloco 1 – Usinas hidrelétricas
			//******************************

			///////////////////////////////////////////////////////////////////////////////////////
			//Manual: Cada bloco de dados inicia com dois registros que são ignorados pelo programa
			///////////////////////////////////////////////////////////////////////////////////////
			std::getline(leituraArquivo, line);
			std::getline(leituraArquivo, line);
			///////////////////////////////////////////////////////////////////////////////////////

			while (true) {

				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				//Campo 1 -  Número da usina hidrelétrica (conforme campo 2 do registro UH). 
				//Manual:    9999 no campo 1 indica fim do bloco. Este registro é obrigatório.
				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				std::getline(leituraArquivo, line);

				strNormalizada(line);

				atributo = line.substr(1, 4);
				atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

				if (atributo == "9999")
					break;
				else {
					const int hidreletrica_codigo_usina = atoi(atributo.c_str());

					const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, hidreletrica_codigo_usina);

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Campo 2 -  Número do primeiro patamar de carga
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					atributo = line.substr(8, 1);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					IdPatamarCarga idPatamarCarga = getIdPatamarCargaFromChar(atributo.c_str());

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Campo 3-14 -  Fator de perda (p.u)
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					//Nota: o programa DECOMP considera atualmente somente fatores de perda mensais.No primeiro mês do caso em estudo, 
					//em que os estágios são semanais, o programa atribui para cada semana fatores de perdas constantes e iguais ao do mês em questão.

					const int line_size = int(line.length());

					for (int mes = 0; mes < 12; mes++) {

						if (line_size >= 16 + 6 * mes) {

							atributo = line.substr(11 + 6 * mes, 5);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double fator_de_perda = atof(atributo.c_str());

							//a_dados.vetorHidreletrica.at(idHidreletrica).addElemento(AttMatrizHidreletrica_fator_perda_centro_gravidade_da_carga, getIdMesFromInt(mes + 1), idPatamarCarga, fator_de_perda);

						}//if (line_size >= 16 + 6*mes) {

					}//for (int mes = 0; mes < 12; mes++) {

				}//else {

			}//while(true){

			//******************************
			//Bloco 2 – Usinas  térmicas
			//******************************

			///////////////////////////////////////////////////////////////////////////////////////
			//Manual: Cada bloco de dados inicia com dois registros que são ignorados pelo programa
			///////////////////////////////////////////////////////////////////////////////////////
			std::getline(leituraArquivo, line);
			std::getline(leituraArquivo, line);
			///////////////////////////////////////////////////////////////////////////////////////

			while (true) {

				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				//Campo 1 -  Número da usina hidrelétrica (conforme campo 2 do registro UH). 
				//Manual:    9999 no campo 1 indica fim do bloco. Este registro é obrigatório.
				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				std::getline(leituraArquivo, line);

				strNormalizada(line);

				atributo = line.substr(1, 4);
				atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

				if (atributo == "9999")
					break;
				else {
					const int termeletrica_codigo_usina = atoi(atributo.c_str());

					const IdTermeletrica idTermeletrica_inicializado = getIdFromCodigoONS(lista_codigo_ONS_termeletrica, termeletrica_codigo_usina);

					if (idTermeletrica_inicializado == IdTermeletrica_Nenhum)
						throw std::invalid_argument("Nao inicializada idTermeletrica com codigo_usina_" + atributo);

					const IdTermeletrica idTermeletrica = idTermeletrica_inicializado;

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Campo 2 -  Número do primeiro patamar de carga
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					atributo = line.substr(8, 1);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					IdPatamarCarga idPatamarCarga = getIdPatamarCargaFromChar(atributo.c_str());

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Campo 3-14 -  Fator de perda (p.u)
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					//Nota: o programa DECOMP considera atualmente somente fatores de perda mensais.No primeiro mês do caso em estudo, 
					//em que os estágios são semanais, o programa atribui para cada semana fatores de perdas constantes e iguais ao do mês em questão.

					const int line_size = int(line.length());

					for (int mes = 0; mes < 12; mes++) {

						if (line_size >= 16 + 6 * mes) {

							atributo = line.substr(11 + 6 * mes, 5);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double fator_de_perda = atof(atributo.c_str());

							//a_dados.vetorTermeletrica.at(idTermeletrica).addElemento(AttMatrizTermeletrica_fator_perda_centro_gravidade_da_carga, getIdMesFromInt(mes + 1), idPatamarCarga, fator_de_perda);

						}//if (line_size >= 16 + 6*mes) {

					}//for (int mes = 0; mes < 12; mes++) {

				}//else {

			}//while(true){

			//*********************************
			//Bloco 3 – Demanda dos Subsistemas
			//*********************************

			///////////////////////////////////////////////////////////////////////////////////////
			//Manual: Cada bloco de dados inicia com dois registros que são ignorados pelo programa
			///////////////////////////////////////////////////////////////////////////////////////
			std::getline(leituraArquivo, line);
			std::getline(leituraArquivo, line);
			///////////////////////////////////////////////////////////////////////////////////////

			while (true) {

				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				//Campo 1 -  Número da usina hidrelétrica (conforme campo 2 do registro UH). 
				//Manual:    9999 no campo 1 indica fim do bloco. Este registro é obrigatório.
				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				std::getline(leituraArquivo, line);

				strNormalizada(line);

				atributo = line.substr(1, 4);
				atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

				if (atributo == "9999")
					break;
				else {
					const int submercado_codigo_usina = atoi(atributo.c_str());

					const IdSubmercado idSubmercado = getIdFromCodigoONS(lista_codigo_ONS_submercado, submercado_codigo_usina);

					if (idSubmercado == IdSubmercado_Nenhum)
						throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Campo 2 -  Número do primeiro patamar de carga
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					atributo = line.substr(8, 1);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					IdPatamarCarga idPatamarCarga = getIdPatamarCargaFromChar(atributo.c_str());

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Campo 3-14 -  Fator de perda (p.u)
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					//Nota: o programa DECOMP considera atualmente somente fatores de perda mensais.No primeiro mês do caso em estudo, 
					//em que os estágios são semanais, o programa atribui para cada semana fatores de perdas constantes e iguais ao do mês em questão.

					const int line_size = int(line.length());

					for (int mes = 0; mes < 12; mes++) {

						if (line_size >= 16 + 6 * mes) {

							atributo = line.substr(11 + 6 * mes, 5);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double fator_de_perda = atof(atributo.c_str());

							//a_dados.vetorSubmercado.at(idSubmercado).addElemento(AttMatrizSubmercado_fator_perda_centro_gravidade_da_carga, getIdMesFromInt(mes + 1), idPatamarCarga, fator_de_perda);

						}//if (line_size >= 16 + 6*mes) {

					}//for (int mes = 0; mes < 12; mes++) {

				}//else {

			}//while(true){

			//***************************************
			//Bloco 4 – Intercâmbio entre Subsistemas 
			//***************************************

			///////////////////////////////////////////////////////////////////////////////////////
			//Manual: Cada bloco de dados inicia com dois registros que são ignorados pelo programa
			///////////////////////////////////////////////////////////////////////////////////////
			std::getline(leituraArquivo, line);
			std::getline(leituraArquivo, line);
			///////////////////////////////////////////////////////////////////////////////////////

			while (true) {

				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				//Campo 1 -  Número do subsistema exportador  (conforme campo 1 do registro SB). 
				//Manual:    9999 no campo 1 indica fim do bloco. Este registro é obrigatório.
				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				std::getline(leituraArquivo, line);

				strNormalizada(line);

				atributo = line.substr(1, 4);
				atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

				if (atributo == "9999")
					break;
				else {
					const int submercado_origem_codigo_usina = atoi(atributo.c_str());

					const IdSubmercado idSubmercado_origem = getIdFromCodigoONS(lista_codigo_ONS_submercado, submercado_origem_codigo_usina);

					if (idSubmercado_origem == IdSubmercado_Nenhum)
						throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);


					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Campo 2 -  Número do subsistema importador  (conforme campo 1 do registro SB).
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					atributo = line.substr(5, 4);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					const int submercado_destino_codigo_usina = atoi(atributo.c_str());

					const IdSubmercado idSubmercado_destino = getIdFromCodigoONS(lista_codigo_ONS_submercado, submercado_destino_codigo_usina);

					if (idSubmercado_destino == IdSubmercado_Nenhum)
						throw std::invalid_argument("Submercado nao instanciado com codigo_usina_" + atributo);


					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Determina o Intercambio
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					std::vector<IdIntercambio> idIntercambio_inicializado = a_dados.vetorIntercambio.getIdObjetos(AttComumIntercambio_submercado_origem, idSubmercado_origem);

					int idIntercambio_inicializado_size = int(idIntercambio_inicializado.size());

					IdIntercambio idIntercambio = IdIntercambio_Nenhum;

					for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

						idIntercambio = idIntercambio_inicializado.at(intercambio_inicializado);

						if (a_dados.getAtributo(idIntercambio, AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino)
							break;

						if (intercambio_inicializado + 1 == idIntercambio_inicializado_size)
							throw std::invalid_argument("Intercambio nao inicializado entre subsistema_" + getString(idSubmercado_origem) + "e subsistema_" + getString(idSubmercado_destino));

					}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Campo 2 -  Número do primeiro patamar de carga
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					atributo = line.substr(13, 1);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					IdPatamarCarga idPatamarCarga = getIdPatamarCargaFromChar(atributo.c_str());

					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
					//Campo 3-14 -  Fator de perda (p.u)
					/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

					//Nota: o programa DECOMP considera atualmente somente fatores de perda mensais.No primeiro mês do caso em estudo, 
					//em que os estágios são semanais, o programa atribui para cada semana fatores de perdas constantes e iguais ao do mês em questão.

					const int line_size = int(line.length());

					for (int mes = 0; mes < 12; mes++) {

						if (line_size >= 21 + 6 * mes) {

							atributo = line.substr(16 + 6 * mes, 5);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double fator_de_perda = atof(atributo.c_str());

							a_dados.vetorIntercambio.at(idIntercambio).addElemento(AttMatrizIntercambio_fator_perda_centro_gravidade_da_carga, getIdMesFromInt(mes + 1), idPatamarCarga, fator_de_perda);

						}//if (line_size >= 16 + 6*mes) {

					}//for (int mes = 0; mes < 12; mes++) {

				}//else {

			}//while(true){

			leituraArquivo.clear();
			leituraArquivo.close();

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_DECOMP_29_PERDAS: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_MLT_201906_DC29(Dados& a_dados, std::string nomeArquivo) {

	try {

		//ofstream     fp_out;

		//std::string arquivo = "MLT.csv";
		//fp_out.open(arquivo.c_str(), ios_base::out); //Função para criar um arquivo

		const int tamanho = 320;
		int intLeitura[tamanho];

		///////////////////////////////////////////////////////////////////
		std::ifstream leituraArquivo;
		leituraArquivo.open(nomeArquivo, std::ios_base::in | std::ios::binary);

		int mes = 1;

		if (leituraArquivo.is_open()) {

			while (!(leituraArquivo.eof())) {

				leituraArquivo.read((char*)intLeitura, sizeof(intLeitura));

				if (mes <= 12) {//Os arquivos da MLTdos DECKs tem uma linha a mais, por isso esta verificação

					const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
					const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

					for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

						//Leitura do valor de afluência
						const int codigo_usina = lista_codigo_ONS_hidreletrica.at(idHidreletrica);

						const int mlt = intLeitura[codigo_usina - 1];

						//Adiciona o valor de afluencia na matriz da classe Afluencia
						a_dados.vetorHidreletrica.at(idHidreletrica).vetorAfluencia.at(IdAfluencia_vazao_afluente).addElemento(AttVetorAfluencia_media_mensal_longo_termo, getIdMesFromInt(mes), mlt);

					}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				}//if (mes <= 12) {

				mes++;


				//Imprime os valores
				//for (int pos = 0; pos < tamanho; pos++) {

					//fp_out << intLeitura[pos] << ";";

				//}//for (int pos = 0; pos < 320; pos++) {

				//fp_out << endl; //Passa de linha


			}//while (!(leituraArquivo.eof())) {

			//fp_out.close();

			leituraArquivo.clear();
			leituraArquivo.close();

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_DECOMP_29_MLT: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_TENDENCIA_VAZOES_MENSAIS_GEVAZP(Dados& a_dados, const std::string nomeArquivo)
{

	try {

		const int numPostos = 320;

		int intLeitura_320[numPostos];

		const int numero_meses_passados_considerados = 11;

		///////////////////////////////////////////////////////////////////
		std::ifstream leituraArquivo;
		leituraArquivo.open(nomeArquivo, std::ios_base::in | std::ios::binary);

		IdMes idMes_historico = IdMes_1;
		IdAno idAno_historico = IdAno_1931;

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		/////////////////////////////////////////////////
		//Inicializa valor_afluencia_passadas	
		/////////////////////////////////////////////////

		for (int posto = 0; posto < numPostos; posto++)
			valor_afluencia_passadas_GEVAZP.addElemento(posto, posto);

		/////////////////////////////////////////////////////////////////////////////////
		//Estabelece o mês inicial a apartir do qual a tendência é considerada (11 meses)
		/////////////////////////////////////////////////////////////////////////////////

		//Nota: O mês do PMO corresponde com o mês do último dia da primeria semana

		Periodo periodo_semana_inicial_PMO = horizonte_otimizacao_DC.getElemento(IdEstagio_1);

		IdDia idDia = periodo_semana_inicial_PMO.getDia();
		IdMes idMes = periodo_semana_inicial_PMO.getMes();
		IdAno idAno = periodo_semana_inicial_PMO.getAno();

		const int numero_dias_periodo_semanal = periodo_semana_inicial_PMO.getDias();

		for (int dia = 1; dia < numero_dias_periodo_semanal; dia++) {//O primeiro dia da semana também conta

			idDia++;

			IdDia maiordiadomes = periodo_semana_inicial_PMO.getMaiorDiaDoMes(idMes);

			if (idDia > maiordiadomes) {
				idDia = IdDia_1;
				idMes++;
				if (idMes == IdMes_Excedente) {
					idMes = IdMes_1;
					idAno++;
				}//if (idMes == IdMes_Excedente) {

			}//if(idDia == maiordiadomes) {

		}//for (int dia = 0; dia < numero_dias_periodo_semanal; dia++) {

		const IdMes idMes_Inicial_PMO = idMes;
		const IdAno idAno_Inicial_PMO = idAno;

		/////////////////////////////////////////////////////////////////////////////////////

		for (int conteio = 0; conteio < numero_meses_passados_considerados; conteio++) {

			idMes--;

			if (idMes == IdMes_Nenhum) {

				idMes = IdMes_12;
				idAno--;

			}//if (idMes == IdMes_Nenhum) {

		}//for (int conteio = 0; conteio < conteio_meses_anteriores; conteio++) {

		const Periodo periodo_limite_para_registrar(idMes, idAno);

		/////////////////////////////////////////////////////////////////////////////////

		if (leituraArquivo.is_open()) {

			int meses_registrados = 0;

			while (!(leituraArquivo.eof())) {

				Periodo periodo_mes_historico(idMes_historico, idAno_historico);

				if (meses_registrados == numero_meses_passados_considerados)
					break;

				idMes_historico++;

				if (idMes_historico > IdMes_12) {
					idMes_historico = IdMes_1;
					idAno_historico++;
				}//if (idMes_historico > IdMes_12) {

				leituraArquivo.read((char*)intLeitura_320, sizeof(intLeitura_320));

				if (periodo_mes_historico >= periodo_limite_para_registrar) {//Somente registra o último ano do histórico

					meses_registrados++;

					if (meses_registrados == numero_meses_passados_considerados) {

						//No mês anterior ao mês inicial do PMO deve encontrar o Tipo_Periodo dependendo dos dias
						//da primeira semana (RV0) do PMO dentro do mês anterior

						////////////////////////////////////////////////////////////////////////
						//1. Determina o dia da primeira semana operativa do PMO no mês anterior 
						////////////////////////////////////////////////////////////////////////

						Periodo periodo_semanal = horizonte_otimizacao_DC.getElemento(IdEstagio_1);

						const Periodo periodo_diario_limite(IdDia_1, idMes_Inicial_PMO, idAno_Inicial_PMO); //Corresponde ao primeiro dia do mês do PMO

						while (periodo_semanal > periodo_diario_limite)
							periodo_semanal--;


						///////////////////////////////////////////////////////////////////////////////////////
						//2. Realiza conteio do número de dias do mês anterior até o periodo_semana_PMO do passo 1.
						///////////////////////////////////////////////////////////////////////////////////////

						IdMes idMes_anterior_PMO = periodo_mes_historico.getMes();
						IdAno idAno_anterior_PMO = periodo_mes_historico.getAno();

						Periodo periodo_diario_mes_anterior(IdDia_1, idMes_anterior_PMO, idAno_anterior_PMO);

						int conteioDias = 0;

						while (periodo_diario_mes_anterior < periodo_semanal) {

							conteioDias++;
							periodo_diario_mes_anterior++;

						}//while (periodo_diario_mes_anterior < periodo_semanal) {

						std::string string_periodo = getString(1) + "/" + getString(idMes_anterior_PMO) + "/" + getString(idAno_anterior_PMO) + "-" + getString(conteioDias) + "dias";;

						const Periodo periodo_mensal(string_periodo);

						for (int posto = 0; posto < numPostos; posto++) {

							const int afluencia = intLeitura_320[posto];

							//Adiciona o valor de afluencia na matriz da classe Afluencia
							valor_afluencia_passadas_GEVAZP.at(posto).addElemento(periodo_mensal, afluencia);

						}//for (int posto = 0; posto < numPostos; posto++) {

					}//if (meses_registrados = numero_meses_passados_considerados) {
					else {

						for (int posto = 0; posto < numPostos; posto++) {

							const int afluencia = intLeitura_320[posto];

							//Adiciona o valor de afluencia na matriz da classe Afluencia
							valor_afluencia_passadas_GEVAZP.at(posto).addElemento(periodo_mes_historico, afluencia);

						}//for (int posto = 0; posto < numPostos; posto++) {

					}//else {

				}//if (periodo_historico >= periodo_limite_para_registrar) {

			}//while (!(leituraArquivo.eof())) {

			leituraArquivo.clear();
			leituraArquivo.close();

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_TENDENCIA_VAZOES_MENSAIS_GEVAZP: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_TENDENCIA_VAZOES_SEMANAIS_GEVAZP(Dados& a_dados, const std::string nomeArquivo, const std::string a_revisao)
{

	try {

		const int numPostos = 320;

		///////////////////////////////////////////////////////////////////
		std::ifstream leituraArquivo(nomeArquivo + "." + a_revisao);
		std::string line;
		std::string atributo;

		///////////////////////////////////////////////////////////////////
		//Estabelece o número de semanas observadas de acordo à revisão
		///////////////////////////////////////////////////////////////////

		int numero_semanas_observadas = 0;

		if (a_revisao == "rv1")
			numero_semanas_observadas = 1;
		else if (a_revisao == "rv2")
			numero_semanas_observadas = 2;
		else if (a_revisao == "rv3")
			numero_semanas_observadas = 3;
		else if (a_revisao == "rv4")
			numero_semanas_observadas = 4;
		else if (a_revisao == "rv5")
			numero_semanas_observadas = 5;

		////////////////////////////////////////////////////////////////////////
		//1. Determina a primeira semana operativa do PMO  
		////////////////////////////////////////////////////////////////////////

		//Nota: O mês do PMO corresponde com o mês do último dia da primeria semana

		Periodo periodo_semana_inicial_PMO = horizonte_otimizacao_DC.getElemento(IdEstagio_1);

		IdDia idDia = periodo_semana_inicial_PMO.getDia();
		IdMes idMes = periodo_semana_inicial_PMO.getMes();
		IdAno idAno = periodo_semana_inicial_PMO.getAno();

		const int numero_dias_periodo_semanal = periodo_semana_inicial_PMO.getDias();

		for (int dia = 1; dia < numero_dias_periodo_semanal; dia++) {//o primeiro dia também conta

			idDia++;

			IdDia maiordiadomes = periodo_semana_inicial_PMO.getMaiorDiaDoMes(idMes);

			if (idDia > maiordiadomes) {
				idDia = IdDia_1;
				idMes++;
				if (idMes == IdMes_Excedente) {
					idMes = IdMes_1;
					idAno++;
				}//if (idMes == IdMes_Excedente) {

			}//if(idDia == maiordiadomes) {

		}//for (int dia = 0; dia < numero_dias_periodo_semanal; dia++) {

		const IdMes idMes_Inicial_PMO = idMes;
		const IdAno idAno_Inicial_PMO = idAno;

		//////////////////////////////////////

		Periodo periodo_semanal_Inicial_PMO = horizonte_otimizacao_DC.getElemento(IdEstagio_1);

		const Periodo periodo_diario_limite(IdDia_1, idMes_Inicial_PMO, idAno_Inicial_PMO); //Corresponde ao primeiro dia do mês do PMO

		while (periodo_semanal_Inicial_PMO > periodo_diario_limite)
			periodo_semanal_Inicial_PMO--;


		///////////////////////////////////////////////////////////////////
		//Inicializa os postos com valor 0 já que no prevs não são 
		//informados todos eles
		///////////////////////////////////////////////////////////////////

		Periodo periodo_semanal = periodo_semanal_Inicial_PMO;

		for (int semanas_observadas = 0; semanas_observadas < numero_semanas_observadas; semanas_observadas++) {

			for (int posto = 0; posto < numPostos; posto++)
				valor_afluencia_passadas_GEVAZP.at(posto).addElemento(periodo_semanal, 0.0);

			periodo_semanal++;

		}//for (int semanas_observadas = 0; semanas_observadas < numero_semanas_observadas; semanas_observadas++) {

		///////////////////////////////////////////////////////////////////

		if (leituraArquivo.is_open()) {

			while (std::getline(leituraArquivo, line)) {

				//Código do posto
				atributo = line.substr(8, 3);
				atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

				const int posto = std::atoi(atributo.c_str());

				periodo_semanal = periodo_semanal_Inicial_PMO;

				for (int semanas_observadas = 0; semanas_observadas < numero_semanas_observadas; semanas_observadas++) {

					//Afluência
					atributo = line.substr(12 + 10 * semanas_observadas, 9);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					const double afluencia = std::atof(atributo.c_str());

					valor_afluencia_passadas_GEVAZP.at(posto - 1).setElemento(periodo_semanal, afluencia);

					periodo_semanal++;

				}//for (int semanas_observadas = 0; semanas_observadas < numero_semanas_observadas; semanas_observadas++) {

			}//while (std::getline(leituraArquivo, line)) {

		}//if (leituraArquivo.is_open()) {
		else  throw std::invalid_argument("Nao foi possivel abrir o arquivo " + nomeArquivo + ".");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_TENDENCIA_VAZOES_SEMANAIS_GEVAZP: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::set_termeletrica_potencia_disponivel_meta(Dados& a_dados)
{
	try {

		//Horizonte de estudo
		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		const IdEstagio maiorIdEstagioDC = horizonte_otimizacao_DC.getIteradorFinal();
		const IdCenario maiorIdCenarioDC = IdCenario(numero_realizacoes_por_periodo.getElemento(horizonte_otimizacao_DC.getElemento(maiorIdEstagioDC)));

		//Inicializa todas as termelétricas
		const IdTermeletrica	idTermeletricaIni = a_dados.getMenorId(IdTermeletrica());
		const IdTermeletrica	idTermeletricaOut = a_dados.getIdOut(IdTermeletrica());
		for (IdTermeletrica idTermeletrica = idTermeletricaIni; idTermeletrica < idTermeletricaOut; a_dados.vetorTermeletrica.incr(idTermeletrica))
			a_dados.vetorTermeletrica.at(idTermeletrica).setMatriz(AttMatrizTermeletrica_potencia_disponivel_meta, SmartEnupla<IdCenario, SmartEnupla<Periodo, double>>(IdCenario_1, std::vector<SmartEnupla<Periodo, double>>(maiorIdCenarioDC, SmartEnupla<Periodo, double>(horizonte_estudo, getdoubleFromChar("max")))));

		//Set valor na Termeletrica

		std::vector<int> codigos_usinas_avaliadas;

		codigos_usinas_avaliadas.push_back(140); //UTE Maua 3
		codigos_usinas_avaliadas.push_back(201); //Aparecida

		std::vector<double> potencia_disponivel_meta;

		potencia_disponivel_meta.push_back(408.16); //UTE Maua 3
		potencia_disponivel_meta.push_back(121.71); //UTE Maua 3

		std::vector<IdTermeletrica> vetor_idTermeletricas;

		for (int pos = 0; pos < int(codigos_usinas_avaliadas.size()); pos++)
			vetor_idTermeletricas.push_back(getIdFromCodigoONS(lista_codigo_ONS_termeletrica, codigos_usinas_avaliadas.at(pos)));


		for (IdCenario idCenario = IdCenario_1; idCenario <= maiorIdCenarioDC; idCenario++) {

			for (int pos = 0; pos < int(vetor_idTermeletricas.size()); pos++)
				a_dados.vetorTermeletrica.at(vetor_idTermeletricas.at(pos)).setElemento(AttMatrizTermeletrica_potencia_disponivel_meta, idCenario, horizonte_estudo.getIteradorFinal(), potencia_disponivel_meta.at(pos));

		}//for (IdCenario idCenario = IdCenario_1; idCenario <= maiorIdCenarioDC; idCenario++) {

		////////////////////////////////////////////


	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::set_termeletrica_potencia_disponivel_meta: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::set_hidreletrica_vazao_turbinada_disponivel_meta(Dados& a_dados)
{
	try {

		//Horizonte de estudo
		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		const IdEstagio maiorIdEstagioDC = horizonte_otimizacao_DC.getIteradorFinal();
		const IdCenario maiorIdCenarioDC = IdCenario(numero_realizacoes_por_periodo.getElemento(horizonte_otimizacao_DC.getElemento(maiorIdEstagioDC)));

		//Inicializa todas as hidrelétricas
		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica))
			a_dados.vetorHidreletrica.at(idHidreletrica).setMatriz(AttMatrizHidreletrica_vazao_turbinada_disponivel_meta, SmartEnupla<IdCenario, SmartEnupla<Periodo, double>>(IdCenario_1, std::vector<SmartEnupla<Periodo, double>>(maiorIdCenarioDC, SmartEnupla<Periodo, double>(horizonte_estudo, getdoubleFromChar("max")))));

		//Set valor na hidrelétrica

		std::vector<int> codigos_usinas_avaliadas;

		codigos_usinas_avaliadas.push_back(156); //Três Marias
		codigos_usinas_avaliadas.push_back(162); //Queimado

		std::vector<SmartEnupla<Periodo, double>> vazao_turbinada_disponivel_meta;


		/////////////////////////
		//Três Marias vazao turbinada
		SmartEnupla<Periodo, double> vazao_turbinada_disponivel_meta_enupla_1;

		vazao_turbinada_disponivel_meta_enupla_1.addElemento(Periodo("16/05/2020-semanal"), 367.63);
		vazao_turbinada_disponivel_meta_enupla_1.addElemento(Periodo("23/05/2020-semanal"), 538.97);
		vazao_turbinada_disponivel_meta_enupla_1.addElemento(Periodo("30/05/2020-semanal"), 679.18);

		vazao_turbinada_disponivel_meta.push_back(vazao_turbinada_disponivel_meta_enupla_1);

		///////////////////////
		//Queimado vazao turbinada
		SmartEnupla<Periodo, double> vazao_turbinada_disponivel_meta_enupla_2;

		vazao_turbinada_disponivel_meta_enupla_2.addElemento(Periodo("16/05/2020-semanal"), 19.19);
		vazao_turbinada_disponivel_meta_enupla_2.addElemento(Periodo("23/05/2020-semanal"), 19.16);
		vazao_turbinada_disponivel_meta_enupla_2.addElemento(Periodo("30/05/2020-semanal"), 47.88);

		vazao_turbinada_disponivel_meta.push_back(vazao_turbinada_disponivel_meta_enupla_2);


		///////////////////////


		if (int(vazao_turbinada_disponivel_meta.size()) != int(codigos_usinas_avaliadas.size()))
			throw std::invalid_argument("Dimensoes de dados das usinas e potencia_meta devem ser iguais");

		std::vector<IdHidreletrica> vetor_idHidreletricas;

		for (int pos = 0; pos < int(codigos_usinas_avaliadas.size()); pos++)
			vetor_idHidreletricas.push_back(getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigos_usinas_avaliadas.at(pos)));

		//////////////////////////////////////////////////

		for (IdCenario idCenario = IdCenario_1; idCenario <= maiorIdCenarioDC; idCenario++) {

			for (int pos = 0; pos < int(vetor_idHidreletricas.size()); pos++) {

				const Periodo periodo_inicial = vazao_turbinada_disponivel_meta.at(pos).getIteradorInicial();
				const Periodo periodo_final = vazao_turbinada_disponivel_meta.at(pos).getIteradorFinal();

				for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo))
					a_dados.vetorHidreletrica.at(vetor_idHidreletricas.at(pos)).setElemento(AttMatrizHidreletrica_vazao_turbinada_disponivel_meta, idCenario, periodo, vazao_turbinada_disponivel_meta.at(pos).getElemento(periodo));
			}
		}//for (IdCenario idCenario = IdCenario_1; idCenario <= maiorIdCenarioDC; idCenario++) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::set_hidreletrica_vazao_turbinada_disponivel_meta: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::set_hidreletrica_potencia_disponivel_meta_from_dec_oper_usih_DC(Dados& a_dados, std::string a_nomeArquivo)
{
	try {

		std::string line;
		std::string atributo;

		std::ifstream leituraArquivo(a_nomeArquivo);

		if (leituraArquivo.is_open()) {

			//Horizonte de estudo
			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			const IdCenario cenario_finalDC = IdCenario(numero_realizacoes_por_periodo.getElemento(horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal())));

			//////////////////////////////////////////////////////////////////////////////////////////////////////////
			//Inicializa a potencia_disponivel_meta com valor getdoubleFromChar("max") -> Nesta lógica, valor "max" nao entra no PL
			//////////////////////////////////////////////////////////////////////////////////////////////////////////

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaEnd = a_dados.getMaiorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo))
					a_dados.vetorHidreletrica.at(idHidreletrica).setMatriz(AttMatrizHidreletrica_potencia_disponivel_meta, SmartEnupla<IdCenario, SmartEnupla<Periodo, double>>(IdCenario_1, std::vector <SmartEnupla<Periodo, double>>(cenario_finalDC, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0))));

			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			//////////////////////////////////////////////////////////////////

			SmartEnupla<IdHidreletrica, SmartEnupla<Periodo, double>> potencia_maxima_restricao_eletrica(idHidreletricaIni, std::vector <SmartEnupla<Periodo, double>>(int(idHidreletricaEnd - idHidreletricaIni) + 1, SmartEnupla<Periodo, double>(horizonte_estudo, getdoubleFromChar("max"))));
			SmartEnupla<IdHidreletrica, SmartEnupla<Periodo, double>> potencia_minima_restricao_eletrica(idHidreletricaIni, std::vector <SmartEnupla<Periodo, double>>(int(idHidreletricaEnd - idHidreletricaIni) + 1, SmartEnupla<Periodo, double>(horizonte_estudo, getdoubleFromChar("min"))));

			const IdRestricaoEletrica maiorIdRestricaoEletrica = a_dados.getMaiorId(IdRestricaoEletrica());

			for (IdRestricaoEletrica idRestricaoEletrica = IdRestricaoEletrica_1; idRestricaoEletrica <= maiorIdRestricaoEletrica; idRestricaoEletrica++) {

				const IdHidreletrica idHidreletrica = a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(IdElementoSistema_1).getAtributo(AttComumElementoSistema_hidreletrica, IdHidreletrica());

				if (a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).getMaiorId(IdElementoSistema()) == IdElementoSistema_1 && idHidreletrica != IdHidreletrica_Nenhum) {//Significa que a restricao só tem 1 elemento hidreletrica

					//Cálculo da potência_media por periodo
					for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						double potencia_maxima_media = 0;
						double potencia_minima_media = 0;

						const IdPatamarCarga maiorIdPatamarCarga = a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga());

						for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

							potencia_maxima_media += a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).getElementoMatriz(AttMatrizRestricaoEletrica_lim_sup, periodo, idPatamarCarga, double()) * a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, double());
							potencia_minima_media += a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).getElementoMatriz(AttMatrizRestricaoEletrica_lim_inf, periodo, idPatamarCarga, double()) * a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, double());

						}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						if (potencia_maxima_restricao_eletrica.at(idHidreletrica).getElemento(periodo) > potencia_maxima_media)
							potencia_maxima_restricao_eletrica.at(idHidreletrica).setElemento(periodo, potencia_maxima_media);

						if (potencia_minima_restricao_eletrica.at(idHidreletrica).getElemento(periodo) < potencia_minima_media)
							potencia_minima_restricao_eletrica.at(idHidreletrica).setElemento(periodo, potencia_minima_media);

					}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				}//if (a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).getMaiorId(IdElementoSistema()) == IdElementoSistema_1 && idHidreletrica != IdHidreletrica_Nenhum) {

			}//for (IdRestricaoEletrica idRestricaoEletrica = IdRestricaoEletrica_1; idRestricaoEletrica <= maiorIdRestricaoEletrica; idRestricaoEletrica++) {

			//Itaipú tem limites nos intercambios IT->ANDE IT->IV: O somatório é a geraçao total da usina IT

			const IdSubmercado idSubmercado_itaipu = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_submercado_ITAIPU);
			const IdSubmercado idSubmercado_ande = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_ANDE);
			const IdSubmercado idSubmercado_iv = getIdFromCodigoONS(lista_codigo_ONS_submercado, codigo_IV);

			std::vector<IdIntercambio> idIntercambio_inicializado = a_dados.vetorIntercambio.getIdObjetos(AttComumIntercambio_submercado_origem, idSubmercado_itaipu);

			int idIntercambio_inicializado_size = int(idIntercambio_inicializado.size());

			IdIntercambio idIntercambio_itaipu_ande = IdIntercambio_Nenhum;

			for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

				if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_ande) {
					idIntercambio_itaipu_ande = idIntercambio_inicializado.at(intercambio_inicializado);
					break;
				}//if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {

			}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

			if (idIntercambio_itaipu_ande == IdIntercambio_Nenhum)
				throw std::invalid_argument("Intercambio nao encontrado");

			////////////////

			IdIntercambio idIntercambio_itaipu_iv = IdIntercambio_Nenhum;

			for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

				if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_iv) {
					idIntercambio_itaipu_iv = idIntercambio_inicializado.at(intercambio_inicializado);
					break;
				}//if (a_dados.getAtributo(idIntercambio_inicializado.at(intercambio_inicializado), AttComumIntercambio_submercado_destino, IdSubmercado()) == idSubmercado_destino) {

			}//for (int intercambio_inicializado = 0; intercambio_inicializado < idIntercambio_inicializado_size; intercambio_inicializado++) {

			if (idIntercambio_itaipu_iv == IdIntercambio_Nenhum)
				throw std::invalid_argument("Intercambio nao encontrado");

			if (true) {

				const int codigo_usina = 66; //código para Itaipu

				const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

				if (idHidreletrica == IdHidreletrica_Nenhum)
					throw std::invalid_argument("idHidreletrica nao instanciada com codigo_" + getString(codigo_usina));

				//Cálculo da potência_media por periodo
				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					double potencia_maxima_media = 0;
					double potencia_minima_media = 0;

					const IdPatamarCarga maiorIdPatamarCarga = a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga());

					for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						potencia_maxima_media += a_dados.vetorIntercambio.at(idIntercambio_itaipu_ande).getElementoMatriz(AttMatrizIntercambio_potencia_maxima, periodo, idPatamarCarga, double()) * a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, double());
						potencia_maxima_media += a_dados.vetorIntercambio.at(idIntercambio_itaipu_iv).getElementoMatriz(AttMatrizIntercambio_potencia_maxima, periodo, idPatamarCarga, double()) * a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, double());

						potencia_minima_media += a_dados.vetorIntercambio.at(idIntercambio_itaipu_ande).getElementoMatriz(AttMatrizIntercambio_potencia_minima, periodo, idPatamarCarga, double()) * a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, double());
						potencia_minima_media += a_dados.vetorIntercambio.at(idIntercambio_itaipu_iv).getElementoMatriz(AttMatrizIntercambio_potencia_minima, periodo, idPatamarCarga, double()) * a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, double());

					}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

					if (potencia_maxima_restricao_eletrica.at(idHidreletrica).getElemento(periodo) > potencia_maxima_media)
						potencia_maxima_restricao_eletrica.at(idHidreletrica).setElemento(periodo, potencia_maxima_media);

					if (potencia_minima_restricao_eletrica.at(idHidreletrica).getElemento(periodo) < potencia_minima_media)
						potencia_minima_restricao_eletrica.at(idHidreletrica).setElemento(periodo, potencia_minima_media);

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			}//if (true) {


			/////////////////

			while (std::getline(leituraArquivo, line)) {

				strNormalizada(line);

				if (line.size() >= 27) {

					//Patamar de carga: O campo "-" indica a média ponderada x patamar no periodo completo
					atributo = line.substr(13, 5);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					const int patamarCarga = atoi(atributo.c_str());

					if (patamarCarga > 0) {

						//idPatamarCarga
						const IdPatamarCarga idPatamarCarga = IdPatamarCarga(patamarCarga);

						//idEstagio_DC

						atributo = line.substr(0, 5);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int estagio_DC = atoi(atributo.c_str());

						const IdEstagio idEstagio_DC = IdEstagio(estagio_DC);

						//idCenario

						atributo = line.substr(6, 6);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int cenario = atoi(atributo.c_str());

						const IdCenario idCenario_DC = IdCenario(cenario - estagio_DC + 1);//Utilizado para o último estágio DC. Ver arquivo saida DC para entender a lógica

						//código usina

						atributo = line.substr(28, 5);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int codigo_usina = atoi(atributo.c_str());

						const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

						if (idHidreletrica == IdHidreletrica_Nenhum)
							throw std::invalid_argument("idHidreletrica nao instanciada com codigo_" + atributo);

						//Potência meta

						atributo = line.substr(120, 9);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const double potencia_disponivel_meta_patamar = atof(atributo.c_str());

						/////////////////

						const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
						const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

						bool sobreposicao_encontrada = false;

						for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

							double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

							if (sobreposicao == 1) {
								sobreposicao_encontrada = true;

								if (idEstagio_DC < horizonte_otimizacao_DC.getIteradorFinal()) {

									for (IdCenario idCenario = IdCenario_1; idCenario <= cenario_finalDC; idCenario++) {

										double potencia_disponivel_meta = getdoubleFromChar("max");

										//if (a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_submercado, IdSubmercado()) == IdSubmercado_4 || a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_submercado, IdSubmercado()) == a_dados.vetorSubmercado.getMenorId() || a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_submercado, IdSubmercado()) == IdSubmercado_2 || a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_submercado, IdSubmercado()) == IdSubmercado_8)
											potencia_disponivel_meta = potencia_disponivel_meta_patamar * a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, double()) + a_dados.vetorHidreletrica.at(idHidreletrica).getElementoMatriz(AttMatrizHidreletrica_potencia_disponivel_meta, idCenario, periodo, double());

										a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttMatrizHidreletrica_potencia_disponivel_meta, idCenario, periodo, potencia_disponivel_meta);
									}//for (IdCenario idCenario = IdCenario_1; idCenario <= cenario_finalDC; idCenario++) {

								}//if (idEstagio_DC < horizonte_otimizacao_DC.getIteradorFinal()) {
								else if (idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal()) {

									double potencia_disponivel_meta = getdoubleFromChar("max");

									//if (a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_submercado, IdSubmercado()) == IdSubmercado_4 || a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_submercado, IdSubmercado()) == a_dados.vetorSubmercado.getMenorId() || a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_submercado, IdSubmercado()) == IdSubmercado_2 || a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_submercado, IdSubmercado()) == IdSubmercado_8)
										potencia_disponivel_meta = potencia_disponivel_meta_patamar * a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, double()) + a_dados.vetorHidreletrica.at(idHidreletrica).getElementoMatriz(AttMatrizHidreletrica_potencia_disponivel_meta, idCenario_DC, periodo, double());

									a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttMatrizHidreletrica_potencia_disponivel_meta, idCenario_DC, periodo, potencia_disponivel_meta);

								}//else if (idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal()) {


							}//if (sobreposicao == 1) {

							if (sobreposicao_encontrada && sobreposicao == 0)
								break;

						}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

					}//if (atributo != "-") {

				}//if (line.size() >= 27) {

			}//while (std::getline(leituraArquivo, line)) {

			/////////////////////////////////////////
			//Valida que a potencia_meta nao seja menor que a potencia_minima ou maior que a potencia_maxima por RE
			/////////////////////////////////////////

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					for (IdCenario idCenario = IdCenario_1; idCenario <= cenario_finalDC; idCenario++) {

						double potencia_disponivel_meta = a_dados.vetorHidreletrica.at(idHidreletrica).getElementoMatriz(AttMatrizHidreletrica_potencia_disponivel_meta, idCenario, periodo, double());

						if (potencia_maxima_restricao_eletrica.at(idHidreletrica).getElemento(periodo) < potencia_disponivel_meta)
							potencia_disponivel_meta = potencia_maxima_restricao_eletrica.at(idHidreletrica).getElemento(periodo);

						if (potencia_minima_restricao_eletrica.at(idHidreletrica).getElemento(periodo) > potencia_disponivel_meta)
							potencia_disponivel_meta = potencia_minima_restricao_eletrica.at(idHidreletrica).getElemento(periodo);

						a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttMatrizHidreletrica_potencia_disponivel_meta, idCenario, periodo, potencia_disponivel_meta);

					}//for (IdCenario idCenario = IdCenario_1; idCenario <= cenario_finalDC; idCenario++) {

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

		}//if (leituraArquivo.is_open()) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::set_hidreletrica_potencia_disponivel_meta_from_dec_oper_usih_DC: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_range_volume_from_eco_fpha_DC(Dados& a_dados, std::string a_nomeArquivo)
{
	try {

		//std::string line;
		//std::string atributo;

		//std::ifstream leituraArquivo(a_nomeArquivo);

		//if (leituraArquivo.is_open()) {

		//	//Horizonte de estudo
		//	const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		//	const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		//  const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		//	//////////////////////////////////////////////////////////////////////////////////////////////////////////
		//	//Inicializa construcao_fph_volume_minimo e construcao_fph_volume_maximo com o range min-max da usina
		//	//////////////////////////////////////////////////////////////////////////////////////////////////////////

		//	for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

		//		for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

		//			a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).addElemento(AttVetorReservatorio_construcao_fph_volume_minimo, periodo, a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_minimo, periodo, double()));
		//			a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).addElemento(AttVetorReservatorio_construcao_fph_volume_maximo, periodo, a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_maximo, periodo, double()));

		//		}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

		//	}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

		//	//////////////////////////////////////////////////////////////////

		//	while (std::getline(leituraArquivo, line)) {

		//		strNormalizada(line);

		//		atributo = line.substr(0, 4);
		//		atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

		//		const int codigo_usina = atoi(atributo.c_str());

		//		if (codigo_usina > 0) {

		//			const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

		//			if (idHidreletrica != IdHidreletrica_Nenhum) {

		//				//idEstagio_DC

		//				atributo = line.substr(5, 4);
		//				atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

		//				const int estagio_DC = atoi(atributo.c_str());

		//				const IdEstagio idEstagio_DC = IdEstagio(estagio_DC);

		//				//construcao_fph_volume_minimo

		//				atributo = line.substr(74, 8);
		//				atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

		//				const double construcao_fph_volume_minimo = atof(atributo.c_str());

		//				//construcao_fph_volume_maximo

		//				atributo = line.substr(83, 8);
		//				atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

		//				const double construcao_fph_volume_maximo = atof(atributo.c_str());

		//				/////////////////

		//				const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
		//				const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

		//				bool sobreposicao_encontrada = false;

		//				for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

		//					double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

		//					if (sobreposicao == 1) {
		//						sobreposicao_encontrada = true;

		//						a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(AttVetorReservatorio_construcao_fph_volume_minimo, periodo, construcao_fph_volume_minimo);
		//						a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(AttVetorReservatorio_construcao_fph_volume_maximo, periodo, construcao_fph_volume_maximo);

		//					}//if (sobreposicao == 1) {

		//					if (sobreposicao_encontrada && sobreposicao == 0)
		//						break;

		//				}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

		//			}//if (idHidreletrica != IdHidreletrica_Nenhum) {
		//			else
		//				throw std::invalid_argument("idHidreletrica nao instanciada com codigo_" + atributo);

		//		}//if (codigo_usina > 0) {

		//	}//while (std::getline(leituraArquivo, line)) {

		//}//if (leituraArquivo.is_open()) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_range_volume_from_eco_fpha_DC: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_volumes_meta_from_dec_oper_usih_DC(Dados& a_dados, std::string a_nomeArquivo, const bool a_somente_volume_meta_no_ultimo_estagio)
{
	try {

		std::string line;
		std::string atributo;

		std::ifstream leituraArquivo(a_nomeArquivo);

		if (leituraArquivo.is_open()) {

			//Horizonte de estudo
			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
			const IdCenario maiorIdCenarioDC = IdCenario(numero_realizacoes_por_periodo.getElemento(horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal())));

			//////////////////////////////////////////////////////////////////
			//Inicializa volume_meta

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo))
				a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setMatriz(AttMatrizReservatorio_volume_meta, SmartEnupla<IdCenario, SmartEnupla<Periodo, double>>(IdCenario_1, std::vector <SmartEnupla<Periodo, double>>(maiorIdCenarioDC, SmartEnupla<Periodo, double>(horizonte_estudo, getdoubleFromChar("max")))));

			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {


			//////////////////////////////////////////////////////////////////

			while (std::getline(leituraArquivo, line)) {

				strNormalizada(line);

				if (line.size() >= 27) {

					//Patamar de carga: O campo "-" indica a média ponderada x patamar no periodo completo
					atributo = line.substr(19, 8);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					if (atributo == "-") {

						//idEstagio_DC

						atributo = line.substr(0, 5);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int estagio_DC = atoi(atributo.c_str());

						const IdEstagio idEstagio_DC = IdEstagio(estagio_DC);

						if (!a_somente_volume_meta_no_ultimo_estagio || (a_somente_volume_meta_no_ultimo_estagio && idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal())) {

							//idCenario

							atributo = line.substr(6, 6);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int cenario = atoi(atributo.c_str());

							const IdCenario idCenario_DC = IdCenario(cenario - estagio_DC + 1);//Utilizado para o último estágio DC. Ver arquivo saida DC para entender a lógica

							//código usina

							atributo = line.substr(28, 5);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const int codigo_usina = atoi(atributo.c_str());

							const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							if (idHidreletrica == IdHidreletrica_Nenhum)
								throw std::invalid_argument("idHidreletrica nao instanciada com codigo_" + atributo);

							//Volume_util_meta

							atributo = line.substr(98, 10);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							if (atributo != "-") {//Teste para só pegar as usinas com reservatório

								const double volume_util_meta_lido = atof(atributo.c_str());

								const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
								const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

								bool sobreposicao_encontrada = false;

								for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

									double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

									if (sobreposicao == 1) {
										sobreposicao_encontrada = true;

										//Identifica se o o dia final do periodo corresponde com o dia final do periodo_DC
										const Periodo periodo_dia_final_SPT = periodo.getPeriodoDiario_do_diaFinal(periodo);
										const Periodo periodo_dia_final_DC = horizonte_otimizacao_DC.getElemento(idEstagio_DC).getPeriodoDiario_do_diaFinal(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

										double volume_util_meta = getdoubleFromChar("max");

										if (periodo_dia_final_SPT == periodo_dia_final_DC) {
											volume_util_meta = volume_util_meta_lido;

										}//if (periodo_dia_final_SPT == periodo_dia_final_DC) {


										if (idEstagio_DC < horizonte_otimizacao_DC.getIteradorFinal()) {

											for (IdCenario idCenario = IdCenario_1; idCenario <= maiorIdCenarioDC; idCenario++)
												a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(AttMatrizReservatorio_volume_meta, idCenario, periodo, volume_util_meta);

										}//if (idEstagio_DC < horizonte_otimizacao_DC.getIteradorFinal()) {
										else if (idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal())
											a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(AttMatrizReservatorio_volume_meta, idCenario_DC, periodo, volume_util_meta);

									}//if (sobreposicao == 1) {

									if (sobreposicao_encontrada && sobreposicao == 0)
										break;

								}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

							}//if (atributo != "-") {

						}//if (!a_somente_volume_meta_no_ultimo_estagio || a_somente_volume_meta_no_ultimo_estagio && idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal()) {

					}//if (atributo == "-") {

				}//if (line.size() >= 27) {

			}//while (std::getline(leituraArquivo, line)) {

		}//if (leituraArquivo.is_open()) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_volumes_meta_from_dec_oper_usih_DC: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_vazao_evaporada_meta_from_dec_oper_usih_DC(Dados& a_dados, std::string a_nomeArquivo)
{
	try {

		std::string line;
		std::string atributo;

		std::ifstream leituraArquivo(a_nomeArquivo);

		if (leituraArquivo.is_open()) {

			//Horizonte de estudo
			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			const IdCenario cenario_finalDC = IdCenario(numero_realizacoes_por_periodo.getElemento(horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal())));

			//////////////////////////////////////////////////////////////////////////////////////////////////////////
			//Inicializa a evaporaçao_meta com valor 0.0 -> Nesta lógica, todas as usinas tem um requerimento de vazao_evaporada
			//////////////////////////////////////////////////////////////////////////////////////////////////////////

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo))
					a_dados.vetorHidreletrica.at(idHidreletrica).setMatriz(AttMatrizHidreletrica_vazao_evaporada_meta, SmartEnupla<IdCenario, SmartEnupla<Periodo, double>>(IdCenario_1, std::vector <SmartEnupla<Periodo, double>>(cenario_finalDC, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0))));

			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			//////////////////////////////////////////////////////////////////

			while (std::getline(leituraArquivo, line)) {

				strNormalizada(line);

				if (line.size() >= 27) {

					//Patamar de carga: O campo "-" indica a média ponderada x patamar no periodo completo
					atributo = line.substr(19, 8);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					if (atributo == "-") {

						//idEstagio_DC

						atributo = line.substr(0, 5);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int estagio_DC = atoi(atributo.c_str());

						const IdEstagio idEstagio_DC = IdEstagio(estagio_DC);

						//idCenario

						atributo = line.substr(6, 6);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int cenario = atoi(atributo.c_str());

						const IdCenario idCenario_DC = IdCenario(cenario - estagio_DC + 1);//Utilizado para o último estágio DC. Ver arquivo saida DC para entender a lógica

						//código usina

						atributo = line.substr(28, 5);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int codigo_usina = atoi(atributo.c_str());

						const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

						if (idHidreletrica == IdHidreletrica_Nenhum)
							throw std::invalid_argument("idHidreletrica nao instanciada com codigo_" + atributo);

						//Vazao evaporada meta

						atributo = line.substr(296, 10);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						double vazao_evaporada_meta = atof(atributo.c_str());

						/////////////////

						const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
						const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

						bool sobreposicao_encontrada = false;

						for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

							double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

							if (sobreposicao == 1) {
								sobreposicao_encontrada = true;

								if (idEstagio_DC < horizonte_otimizacao_DC.getIteradorFinal()) {

									for (IdCenario idCenario = IdCenario_1; idCenario <= cenario_finalDC; idCenario++)
										a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttMatrizHidreletrica_vazao_evaporada_meta, idCenario, periodo, vazao_evaporada_meta);

								}//if (idEstagio_DC < horizonte_otimizacao_DC.getIteradorFinal()) {
								else if (idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal())
									a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttMatrizHidreletrica_vazao_evaporada_meta, idCenario_DC, periodo, vazao_evaporada_meta);


							}//if (sobreposicao == 1) {

							if (sobreposicao_encontrada && sobreposicao == 0)
								break;

						}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

					}//if (atributo == "-") {

				}//if (line.size() >= 27) {

			}//while (std::getline(leituraArquivo, line)) {

		}//if (leituraArquivo.is_open()) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_vazao_evaporada_meta_from_dec_oper_usih_DC: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_fph_from_avl_cortesfpha_dec_DC(Dados& a_dados, std::string a_nomeArquivo)
{
	try {

		std::string line;
		std::string atributo;

		std::ifstream leituraArquivo(a_nomeArquivo);

		if (leituraArquivo.is_open()) {

			//Horizonte de estudo
			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaEnd = a_dados.getMaiorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			bool secao_fph = false;

			SmartEnupla <IdHidreletrica, bool> ler_fph_hidreletrica(idHidreletricaIni, std::vector<bool>(int(idHidreletricaEnd - idHidreletricaIni) + 1, true));

			//////////////////////////////////////////////////////////////////////////////////////////////////////////
			//Identifica se as FPH foram carregadas na pre-config e inicializa para todos os periodos 1 corte = 0
			//////////////////////////////////////////////////////////////////////////////////////////////////////////

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				if (!a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.isInstanciado(IdFuncaoProducaoHidreletrica_1)) {

					FuncaoProducaoHidreletrica funcaoProducaoHidreletrica;
					funcaoProducaoHidreletrica.setAtributo(AttComumFuncaoProducaoHidreletrica_idFuncaoProducaoHidreletrica, IdFuncaoProducaoHidreletrica_1);

					a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.add(funcaoProducaoHidreletrica);

				}//if (!a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.isInstanciado(IdFuncaoProducaoHidreletrica_1)) {

				if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).getSizeMatriz(AttMatrizFuncaoProducaoHidreletrica_RHS) > 0)
					ler_fph_hidreletrica.setElemento(idHidreletrica, false); //Se a fph de uma usina foi carregada via pré-config, nao sao carregadas as fph-DC
				else {

					//Instancia idcorte_1 com valores 0 para todos os periodos do horizonte_estudo que estejam dentro do horizonte_DC
					// existe um modo do programa em que pode ter extensão do horizonte, nesse caso é utilizado produtibilidade constante)

					const Periodo periodo_ultimo_sobreposicao = get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados);

					for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						if (periodo <= periodo_ultimo_sobreposicao) {

							a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_RHS, periodo, 1, 0.0);
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_FC, periodo, 1, 0.0);
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_VH, periodo, 1, 0.0);
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_QH, periodo, 1, 0.0);
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_SH, periodo, 1, 0.0);

						}//if (periodo <= periodo_ultimo_sobreposicao) {
						else {
							//Instancia produtibilidade constante

							const TipoPerdaHidraulica tipo_perda_hidraulica = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_de_perda_hidraulica, TipoPerdaHidraulica());
							const double perda_hidraulica = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_perda_hidraulica, double());
							const double fator_de_producao = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_fator_de_producao, double());

							////////////////
							double canal_fuga_medio = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_canal_fuga_medio, double());

							if(a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(AttVetorHidreletrica_canal_fuga_medio) > 0)
								canal_fuga_medio = a_dados.vetorHidreletrica.at(idHidreletrica).getElementoVetor(AttVetorHidreletrica_canal_fuga_medio, periodo, double());

							////////////////
							double volume_minimo = a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getAtributo(AttComumReservatorio_volume_minimo, double());
							double volume_maximo = a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getAtributo(AttComumReservatorio_volume_maximo, double());

							if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(AttVetorReservatorio_volume_minimo) > 0)
								volume_minimo = a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_minimo, periodo, double());

							if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(AttVetorReservatorio_volume_maximo) > 0)
								volume_maximo = a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_maximo, periodo, double());

							const double cota_referencia = a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getCotaMedia(periodo, volume_minimo, volume_maximo);

							const double cota = cota_referencia - canal_fuga_medio;

							const double coef_QH = a_dados.vetorHidreletrica.at(idHidreletrica).calcularProdutibilidade(tipo_perda_hidraulica, perda_hidraulica, fator_de_producao, cota);

							a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_RHS, periodo, 1, 0.0);
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_FC, periodo, 1, 1.0);
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_VH, periodo, 1, 0.0);
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_QH, periodo, 1, coef_QH);
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_SH, periodo, 1, 0.0);



						}//else {

					}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				}//else {

			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			//////////////////////////////////////////////////////////////////

			while (std::getline(leituraArquivo, line)) {

				strNormalizada(line);

				if (line.size() >= 7 && !secao_fph) {

					if (line.substr(0, 7) == "@Tabela")
						secao_fph = true;

				}//if (line.size() >= 7) {

				if (secao_fph) {

					atributo = line.substr(0, 5);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					const int codigo_usina = atoi(atributo.c_str());

					if (codigo_usina > 0) {

						const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

						if (idHidreletrica != IdHidreletrica_Nenhum) {

							if (ler_fph_hidreletrica.getElemento(idHidreletrica)) {

								//idEstagio_DC

								atributo = line.substr(6, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const int estagio_DC = atoi(atributo.c_str());

								const IdEstagio idEstagio_DC = IdEstagio(estagio_DC);

								//idCorte

								atributo = line.substr(27, 7);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const int idCorte = atoi(atributo.c_str());

								//FC

								atributo = line.substr(35, 10);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const double fc = atof(atributo.c_str());

								//RHS

								atributo = line.substr(46, 16);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const double rhs = -atof(atributo.c_str()); // O sinal menos deixa o rhs padrao do SPT

								//VH

								atributo = line.substr(63, 16);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const double coef_vh = atof(atributo.c_str());

								//QTUR

								atributo = line.substr(80, 16);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const double coef_qtur = atof(atributo.c_str());

								//QVER

								atributo = line.substr(97, 16);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const double coef_qver = atof(atributo.c_str());

								/////////////////

								const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
								const Periodo periodo_final = horizonte_estudo.getIteradorFinal();


								bool sobreposicao_encontrada = false;

								for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

									double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

									if (sobreposicao == 1) {
										sobreposicao_encontrada = true;

										//Existem dados repetidos no arquivo DECOMP

										if (a_dados.getSize2Matriz(idHidreletrica, IdFuncaoProducaoHidreletrica_1, AttMatrizFuncaoProducaoHidreletrica_RHS, periodo) == idCorte) {

											a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setElemento(AttMatrizFuncaoProducaoHidreletrica_RHS, periodo, idCorte, rhs);
											a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setElemento(AttMatrizFuncaoProducaoHidreletrica_FC, periodo, idCorte, fc);
											a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setElemento(AttMatrizFuncaoProducaoHidreletrica_VH, periodo, idCorte, coef_vh);
											a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setElemento(AttMatrizFuncaoProducaoHidreletrica_QH, periodo, idCorte, coef_qtur);
											a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setElemento(AttMatrizFuncaoProducaoHidreletrica_SH, periodo, idCorte, coef_qver);

										}//if (a_dados.getSize2Matriz(idHidreletrica, IdFuncaoProducaoHidreletrica_1, AttMatrizFuncaoProducaoHidreletrica_RHS, periodo) == idCorte) {
										else if (a_dados.getSize2Matriz(idHidreletrica, IdFuncaoProducaoHidreletrica_1, AttMatrizFuncaoProducaoHidreletrica_RHS, periodo) < idCorte) {

											a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_RHS, periodo, idCorte, rhs);
											a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_FC, periodo, idCorte, fc);
											a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_VH, periodo, idCorte, coef_vh);
											a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_QH, periodo, idCorte, coef_qtur);
											a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(AttMatrizFuncaoProducaoHidreletrica_SH, periodo, idCorte, coef_qver);

										}//else if (a_dados.getSize2Matriz(idHidreletrica, IdFuncaoProducaoHidreletrica_1, AttMatrizFuncaoProducaoHidreletrica_RHS, periodo) < idCorte) {

									}//if (sobreposicao == 1) {

									if (sobreposicao_encontrada && sobreposicao == 0)
										break;

								}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

							}//if (ler_fph_hidreletrica.getElemento(idHidreletrica)) {

						}//if (idHidreletrica != IdHidreletrica_Nenhum) {
						else
							throw std::invalid_argument("idHidreletrica nao instanciada com codigo_" + atributo);

					}//if (codigo_usina > 0) {

				}//if (secao_fph) {

			}//while (std::getline(leituraArquivo, line)) {

		}//if (leituraArquivo.is_open()) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_fph_from_avl_cortesfpha_dec_DC: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_coeficientes_evaporacao_from_dec_cortes_evap_DC(Dados& a_dados, std::string a_nomeArquivo)
{
	try {

		std::string line;
		std::string atributo;

		std::ifstream leituraArquivo(a_nomeArquivo);

		if (leituraArquivo.is_open()) {

			//Horizonte de estudo
			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			bool secao_evaporacao = false;

			while (std::getline(leituraArquivo, line)) {

				strNormalizada(line);

				if (line.size() >= 7) {

					if (line.substr(0, 7) == "@Tabela" && !secao_evaporacao)
						secao_evaporacao = true;

				}//if (line.size() >= 7) {

				if (secao_evaporacao) {

					atributo = line.substr(0, 4);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					const int estagio_DC = atoi(atributo.c_str());

					if (estagio_DC > 0) {

						const IdEstagio idEstagio_DC = IdEstagio(estagio_DC);

						atributo = line.substr(7, 3);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int codigo_usina = atoi(atributo.c_str());

						const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

						if (idHidreletrica != IdHidreletrica_Nenhum) {

							/////////////////
							//Volume Referencia
							atributo = line.substr(84, 11);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double volume_referencia_evaporacao = atof(atributo.c_str());

							//Coef_1

							atributo = line.substr(111, 13);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							double coef_linear_evaporacao_1 = atof(atributo.c_str());

							//Coef_0: RHS

							atributo = line.substr(130, 7);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							double coef_linear_evaporacao_0 = atof(atributo.c_str());

							//Ajustes necessários
							//coef_linear_evaporacao_0 -= volume_referencia_evaporacao * coef_linear_evaporacao_1;
							//coef_linear_evaporacao_0 *= (-1);
							//coef_linear_evaporacao_1 *= 2;

							/////////////////

							if (idEstagio_DC == IdEstagio_1) {
								a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setVetor(AttVetorReservatorio_coef_linear_evaporacao_0, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));
								a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setVetor(AttVetorReservatorio_coef_linear_evaporacao_1, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));
							}//if (idEstagio_DC == IdEstagio_1) {

							const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
							const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

							bool sobreposicao_encontrada = false;

							for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

								double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

								if (sobreposicao == 1) {
									sobreposicao_encontrada = true;

									const double conversor_vazao_volume_periodo = std::pow(a_dados.getElementoVetor(AttVetorDados_conversor_vazao_volume, periodo, double()), -1);

									a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(AttVetorReservatorio_coef_linear_evaporacao_0, periodo, coef_linear_evaporacao_0 * conversor_vazao_volume_periodo);
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(AttVetorReservatorio_coef_linear_evaporacao_1, periodo, coef_linear_evaporacao_1 * conversor_vazao_volume_periodo);
								}//if (sobreposicao == 1) {

								if (sobreposicao_encontrada && sobreposicao == 0)
									break;

							}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

						}//if (idHidreletrica != IdHidreletrica_Nenhum) {
						else
							throw std::invalid_argument("idHidreletrica nao instanciada com codigo_" + atributo);

					}//if (estagio_DC > 0) {

				}//if (secao_evaporacao) {

			}//while (std::getline(leituraArquivo, line)) {

		}//if (leituraArquivo.is_open()) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_coeficientes_evaporacao_from_dec_cortes_evap_DC: \n" + std::string(erro.what())); }

}

bool LeituraCEPEL::leitura_turbinamento_maximo_from_avl_turb_max_DC(Dados& a_dados, std::string a_nomeArquivo_1)
{
	try {

		bool lido_turbinamento_maximo_from_relato_e_avl_turb_max_DC = false;

		std::string line;
		std::string atributo;

		std::ifstream leituraArquivo_1(a_nomeArquivo_1);

		//Filosofia: do arquivo avl_turb_max.csv carrega o QTUR_MAX correspondente ao primeiro mês
		//Os dados do segundo mês sao carregados no cálculo de qMax

		if (leituraArquivo_1.is_open()) {

			lido_turbinamento_maximo_from_relato_e_avl_turb_max_DC = true;

			//Horizonte de estudo
			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			///////////////////////////////////////////
			//0. Inicializa usinas com turbinamento = 0
			///////////////////////////////////////////

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) != TipoDetalhamentoProducaoHidreletrica_sem_producao)
					a_dados.vetorHidreletrica.at(idHidreletrica).setVetor(AttVetorHidreletrica_vazao_turbinada_maxima, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));

			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			////////////////////////////////////////////////////////
			//1. Leitura do avl_turb_max (Atualiza estagios DC t < T)
			////////////////////////////////////////////////////////

			while (std::getline(leituraArquivo_1, line)) {

				strNormalizada(line);

				if (line.size() >= 210) {

					////////////////////////////

					atributo = line.substr(0, 12);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					const int estagio_DC = atoi(atributo.c_str());

					if (estagio_DC > 0) {

						const IdEstagio idEstagio_DC = IdEstagio(estagio_DC);

						////////////////////////////

						atributo = line.substr(26, 12);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int codigo_usina = atoi(atributo.c_str());

						const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

						if (idHidreletrica == IdHidreletrica_Nenhum)
							throw std::invalid_argument("Usina nao instanciada com codigo_" + getString(codigo_usina));

						////////////////////////////

						if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) != TipoDetalhamentoProducaoHidreletrica_sem_producao) {

							atributo = line.substr(93, 12);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double turbinamento_maximo_disponivel = atof(atributo.c_str());

							bool sobreposicao_encontrada = false;

							const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
							const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

							for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

								double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

								if (sobreposicao == 1) {
									sobreposicao_encontrada = true;

									const double indisponibilidade_forcada = a_dados.getElementoVetor(idHidreletrica, AttVetorHidreletrica_indisponibilidade_forcada, periodo, double());
									const double indisponibilidade_programada = a_dados.getElementoVetor(idHidreletrica, AttVetorHidreletrica_indisponibilidade_programada, periodo, double());
									const double disponibilidade = (1.0 - indisponibilidade_forcada) * (1.0 - indisponibilidade_programada);

									double turbinamento_maximo = 0;

									if (disponibilidade > 0)
										turbinamento_maximo = turbinamento_maximo_disponivel / disponibilidade;

									a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_vazao_turbinada_maxima, periodo, turbinamento_maximo);
								}//if (sobreposicao == 1) {

								if (sobreposicao_encontrada && sobreposicao == 0)
									break;

							}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

						}//if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) != TipoDetalhamentoProducaoHidreletrica_sem_producao) {

					}//if (estagio_DC > 0) {

				}//if (line.size() >= 210) {

			}//while (std::getline(leituraArquivo, line)) {

			leituraArquivo_1.clear();
			leituraArquivo_1.close();

		}//if (leituraArquivo_1.is_open()) {

		return lido_turbinamento_maximo_from_relato_e_avl_turb_max_DC;

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_turbinamento_maximo_from_avl_turb_max_DC: \n" + std::string(erro.what())); }

}

bool LeituraCEPEL::leitura_turbinamento_maximo_from_relato_e_avl_turb_max_DC(Dados& a_dados, std::string a_nomeArquivo_1, std::string a_nomeArquivo_2)
{
	try {

		bool lido_turbinamento_maximo_from_relato_e_avl_turb_max_DC = false;

		std::string line;
		std::string atributo;

		std::ifstream leituraArquivo_1(a_nomeArquivo_1);
		std::ifstream leituraArquivo_2(a_nomeArquivo_2);

		//Filosofia: do arquivo avl_turb_max.csv carrega o QTUR_MAX correspondente ao primeiro mês
		//Os dados do segundo mês sao carregados do relatos.rvX (supondo que para o periodo mensal nao é limitado o turbinamento por engolimento)

		if (leituraArquivo_1.is_open() && leituraArquivo_2.is_open()) {

			lido_turbinamento_maximo_from_relato_e_avl_turb_max_DC = true;

			//Horizonte de estudo
			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			///////////////////////////////////////////
			//0. Inicializa usinas com turbinamento = 0
			///////////////////////////////////////////

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaEnd = a_dados.getMaiorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) != TipoDetalhamentoProducaoHidreletrica_sem_producao)
					a_dados.vetorHidreletrica.at(idHidreletrica).setVetor(AttVetorHidreletrica_vazao_turbinada_maxima, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));

			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			/////////////////////////////////////////////////////////
			//1. Leitura do relato.rvX (Atualiza último estágio DC
			/////////////////////////////////////////////////////////

			while (std::getline(leituraArquivo_1, line)) {

				strNormalizada(line);

				if (line.size() >= 106) {

					if (line.substr(3, 99) == "Relatorio  dos  Dados  do  Cadastro  das  Usinas  Hidraulicas na Configuracao - a partir do estagio") {

						atributo = line.substr(104, 2);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const IdEstagio idEstagio_DC = IdEstagio(atoi(atributo.c_str()));

						if (idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal()) {

							int conteio_usina = 0;

							while (std::getline(leituraArquivo_1, line)) {

								strNormalizada(line);

								atributo = line.substr(4, 3);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								const int codigo_usina = atoi(atributo.c_str());

								if (codigo_usina > 0) {

									const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

									if (idHidreletrica != IdHidreletrica_Nenhum) {//O relato tem usinas que nao entram no estudo de acordo com DADGER

										conteio_usina++;

										if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) != TipoDetalhamentoProducaoHidreletrica_sem_producao) {

											atributo = line.substr(84, 6);
											atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

											const double turbinamento_maximo = atof(atributo.c_str());

											const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
											const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

											bool sobreposicao_encontrada = false;

											for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

												double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

												if (sobreposicao == 1) {
													sobreposicao_encontrada = true;
													a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_vazao_turbinada_maxima, periodo, turbinamento_maximo);
												}//if (sobreposicao == 1) {

												if (sobreposicao_encontrada && sobreposicao == 0)
													break;

											}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

										}//if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) != TipoDetalhamentoProducaoHidreletrica_sem_producao) {

									}//if (idHidreletrica != IdHidreletrica_Nenhum) {

								}//if (codigo_usina > 0) {

								if (conteio_usina == int(idHidreletricaEnd - idHidreletricaIni) + 1)
									break;

							}//while (std::getline(leituraArquivo, line)) {

							if (conteio_usina < int(idHidreletricaEnd - idHidreletricaIni) + 1)
								throw std::invalid_argument("Numero de hidreletricas no arquivo relato.rvX menor as instanciadas no DADGER");

							if (idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal())
								break;

						}//if (idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal()) {

					}//if (line.substr(3, 99) == "Relatorio  dos  Dados  do  Cadastro  das  Usinas  Hidraulicas na Configuracao - a partir do estagio") {

				}//if (line.size() >= 106) {

			}//while (std::getline(leituraArquivo, line)) {

			leituraArquivo_1.clear();
			leituraArquivo_1.close();

			////////////////////////////////////////////////////////
			//2. Leitura do avl_turb_max (Atualiza estagios DC t < T
			////////////////////////////////////////////////////////

			while (std::getline(leituraArquivo_2, line)) {

				strNormalizada(line);

				if (line.size() >= 210) {

					////////////////////////////

					atributo = line.substr(0, 12);
					atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

					const int estagio_DC = atoi(atributo.c_str());

					if (estagio_DC > 0) {

						const IdEstagio idEstagio_DC = IdEstagio(estagio_DC);

						////////////////////////////

						atributo = line.substr(26, 12);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int codigo_usina = atoi(atributo.c_str());

						const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

						if (idHidreletrica == IdHidreletrica_Nenhum)
							throw std::invalid_argument("Usina nao instanciada com codigo_" + getString(codigo_usina));

						////////////////////////////

						if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) != TipoDetalhamentoProducaoHidreletrica_sem_producao) {

							atributo = line.substr(93, 12);
							atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

							const double turbinamento_maximo_disponivel = atof(atributo.c_str());

							bool sobreposicao_encontrada = false;

							const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
							const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

							for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

								double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

								if (sobreposicao == 1) {
									sobreposicao_encontrada = true;

									const double indisponibilidade_forcada = a_dados.getElementoVetor(idHidreletrica, AttVetorHidreletrica_indisponibilidade_forcada, periodo, double());
									const double indisponibilidade_programada = a_dados.getElementoVetor(idHidreletrica, AttVetorHidreletrica_indisponibilidade_programada, periodo, double());
									const double disponibilidade = (1.0 - indisponibilidade_forcada) * (1.0 - indisponibilidade_programada);

									double turbinamento_maximo = 0;

									if (disponibilidade > 0)
										turbinamento_maximo = turbinamento_maximo_disponivel / disponibilidade;

									a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_vazao_turbinada_maxima, periodo, turbinamento_maximo);
								}//if (sobreposicao == 1) {

								if (sobreposicao_encontrada && sobreposicao == 0)
									break;

							}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

						}//if (a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) != TipoDetalhamentoProducaoHidreletrica_sem_producao) {

					}//if (estagio_DC > 0) {

				}//if (line.size() >= 210) {

			}//while (std::getline(leituraArquivo, line)) {

			leituraArquivo_2.clear();
			leituraArquivo_2.close();

		}//if (leituraArquivo_1.is_open() && leituraArquivo_2.is_open()) {

		return lido_turbinamento_maximo_from_relato_e_avl_turb_max_DC;

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_turbinamento_maximo_from_relato_e_avl_turb_max_DC: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::leitura_volumes_meta_from_relatos_DC(Dados& a_dados, std::string a_nomeArquivo_1, std::string a_nomeArquivo_2)
{
	try {

		std::string line;
		std::string atributo;

		std::ifstream leituraArquivo_1(a_nomeArquivo_1);
		std::ifstream leituraArquivo_2(a_nomeArquivo_2);

		//arquivo_1: relato.rvX  -> Volume final das semanas do primeiro mês
		//arquivo_2: relato2.rvX -> Volume final das aberturas do segundo mês

		if (leituraArquivo_1.is_open() && leituraArquivo_2.is_open()) {

			//Horizonte de estudo
			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaEnd = a_dados.getMaiorId(IdHidreletrica());

			const IdEstagio maiorIdEstagioDC = horizonte_otimizacao_DC.getIteradorFinal();
			const IdCenario maiorIdCenarioDC = IdCenario(numero_realizacoes_por_periodo.getElemento(horizonte_otimizacao_DC.getElemento(maiorIdEstagioDC)));

			/////////////////////////////////////////////
			//arquivo_1: relato.rvX
			/////////////////////////////////////////////

			int estagio_DC = 0;

			while (std::getline(leituraArquivo_1, line)) {

				strNormalizada(line);

				if (line.substr(0, 41) == "    No.       Usina       Volume (% V.U.)") {

					estagio_DC++;

					int conteio_usina = 0;

					while (std::getline(leituraArquivo_1, line)) {

						atributo = line.substr(0, 7);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int codigo_usina = atoi(atributo.c_str());

						if (codigo_usina > 0) {

							const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							if (idHidreletrica != IdHidreletrica_Nenhum) {

								conteio_usina++;

								atributo = line.substr(33, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (line.substr(33, 5) != "") {//Teste para só pegar as usinas com reservatório

									const double porcentagem_volume_meta = atof(atributo.c_str()) / 100;

									const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
									const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

									const IdEstagio idEstagio_DC = IdEstagio(estagio_DC);

									bool sobreposicao_encontrada = false;

									for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

										double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

										if (sobreposicao == 1) {
											sobreposicao_encontrada = true;

											double volume_util_meta = porcentagem_volume_meta * (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_maximo, periodo, double()) - a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_minimo, periodo, double()));

											//Identifica se o o dia final do periodo corresponde com o dia final do periodo_DC
											const Periodo periodo_dia_final_SPT = periodo.getPeriodoDiario_do_diaFinal(periodo);
											const Periodo periodo_dia_final_DC = horizonte_otimizacao_DC.getElemento(idEstagio_DC).getPeriodoDiario_do_diaFinal(horizonte_otimizacao_DC.getElemento(idEstagio_DC));

											if (periodo_dia_final_SPT != periodo_dia_final_DC)
												volume_util_meta = getdoubleFromChar("max");

											for (IdCenario idCenario = IdCenario_1; idCenario <= maiorIdCenarioDC; idCenario++)
												a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).addElemento(AttMatrizReservatorio_volume_meta, idCenario, periodo, volume_util_meta);

										}//if (sobreposicao == 1) {

										if (sobreposicao_encontrada && sobreposicao == 0)
											break;

									}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

								}//if (secao_volumes && codigo_usina > 0 && line.substr(33, 5) != "") {

							}//if (idHidreletrica != IdHidreletrica_Nenhum) {

						}//if (codigo_usina > 0) {

						if (conteio_usina == int(idHidreletricaEnd - idHidreletricaIni) + 1)
							break;

					}//while (std::getline(leituraArquivo_1, line)) {

				}//if (line.substr(0, 41) == "    No.       Usina       Volume (% V.U.)") {

				if (IdEstagio(estagio_DC) == IdEstagio(horizonte_otimizacao_DC.getIteradorFinal() - 1))
					break;

			}//while (std::getline(leituraArquivo_1, line)) {

			leituraArquivo_1.clear();
			leituraArquivo_1.close();

			/////////////////////////////////////////////
			//arquivo_2: relato2.rvX
			/////////////////////////////////////////////

			int numero_cenarios = 0;

			while (std::getline(leituraArquivo_2, line)) {

				strNormalizada(line);

				if (line.substr(0, 41) == "    No.       Usina       Volume (% V.U.)") {

					numero_cenarios++;

					int conteio_usina = 0;

					while (std::getline(leituraArquivo_2, line)) {

						atributo = line.substr(0, 7);
						atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

						const int codigo_usina = atoi(atributo.c_str());

						if (codigo_usina > 0) {

							const IdHidreletrica idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, codigo_usina);

							if (idHidreletrica != IdHidreletrica_Nenhum) {

								conteio_usina++;

								atributo = line.substr(33, 5);
								atributo.erase(std::remove(atributo.begin(), atributo.end(), ' '), atributo.end());

								if (line.substr(33, 5) != "") {//Teste para só pegar as usinas com reservatório

									const IdCenario idCenario = IdCenario(numero_cenarios);

									const double porcentagem_volume_meta = atof(atributo.c_str()) / 100;

									const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
									const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

									bool sobreposicao_encontrada = false;

									for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

										double sobreposicao = periodo.sobreposicao(horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()));

										if (sobreposicao == 1) {
											sobreposicao_encontrada = true;

											double volume_util_meta = porcentagem_volume_meta * (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_maximo, periodo, double()) - a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_minimo, periodo, double()));

											//Identifica se o o dia final do periodo corresponde com o dia final do periodo_DC
											const Periodo periodo_dia_final_SPT = periodo.getPeriodoDiario_do_diaFinal(periodo);
											const Periodo periodo_dia_final_DC = horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()).getPeriodoDiario_do_diaFinal(horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()));

											if (periodo_dia_final_SPT != periodo_dia_final_DC)
												volume_util_meta = getdoubleFromChar("max");

											a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).addElemento(AttMatrizReservatorio_volume_meta, idCenario, periodo, volume_util_meta);

										}//if (sobreposicao == 1) {

										if (sobreposicao_encontrada && sobreposicao == 0)
											break;

									}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

								}//if (secao_volumes && codigo_usina > 0 && line.substr(33, 5) != "") {

							}//if (idHidreletrica != IdHidreletrica_Nenhum) {

						}//if (codigo_usina > 0) {

						if (conteio_usina == int(idHidreletricaEnd - idHidreletricaIni) + 1)
							break;

					}//while (std::getline(leituraArquivo_2, line)) {

				}//if (line.substr(0, 41) == "    No.       Usina       Volume (% V.U.)") {

				if (IdCenario(numero_cenarios) == maiorIdCenarioDC)
					break;

			}//while (std::getline(leituraArquivo_2, line)) {


			leituraArquivo_2.clear();
			leituraArquivo_2.close();

		}//if (leituraArquivo_2.is_open() && leituraArquivo_1.is_open()) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::leitura_volumes_meta_from_relatos_DC: \n" + std::string(erro.what())); }

}


void LeituraCEPEL::defineHorizontes_CP(Dados& a_dados)
{
	try {



		if(a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo()).size() == 0)
			define_horizonte_otimizacao_CP(a_dados);
		
		if (a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio()).size() == 0)
			define_horizonte_estudo_CP(a_dados);

		valida_horizonte_estudo_CP_respeito_horizonte_otimizacao_DC(a_dados);

		if (!dadosPreConfig_instanciados) {
			a_dados.setAtributo(AttComumDados_periodo_referencia, a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio()).getIteradorInicial());
			a_dados.setAtributo(AttComumDados_estagio_final, a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo()).getIteradorFinal());
			a_dados.setAtributo(AttComumDados_estagio_acoplamento_pre_estudo, estagio_acoplamento_pre_estudo);
		}//if (!dadosPreConfig_instanciados) {
		else {

			if (a_dados.getAtributo(AttComumDados_periodo_referencia, Periodo()) != a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio()).getIteradorInicial())
				throw std::invalid_argument("Pre-config deve ter periodo_referencia igual a: " + getString(a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio()).getIteradorInicial()));

			if (a_dados.getAtributo(AttComumDados_estagio_final, IdEstagio()) != a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo()).getIteradorFinal())
				throw std::invalid_argument("Pre-config deve ter estagio_final igual a: " + getString(a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo()).getIteradorFinal()));

			if (a_dados.getAtributo(AttComumDados_estagio_acoplamento_pre_estudo, IdEstagio()) != estagio_acoplamento_pre_estudo)
				throw std::invalid_argument("Pre-config deve ter estagio_acoplamento_pre_estudo igual a: " + getString(estagio_acoplamento_pre_estudo));

		}//	else {


		//////////////////////////////////////////////////////////////////////////////
		//Instancia horizonte_estudo_DECK com os periodos do horizonte_otimizacao_DC
		//////////////////////////////////////////////////////////////////////////////
		
		const IdEstagio idEstagio_inicial = horizonte_otimizacao_DC.getIteradorInicial();
		const IdEstagio idEstagio_final = horizonte_otimizacao_DC.getIteradorFinal();

		for (IdEstagio idEstagio_DC = idEstagio_inicial; idEstagio_DC <= idEstagio_final; idEstagio_DC++)
			horizonte_estudo_DECK.addElemento(horizonte_otimizacao_DC.at(idEstagio_DC), true);

	}//try{
	catch (const std::exception& erro) { throw std::invalid_argument("Dados::defineHorizontes_CP(): \n" + std::string(erro.what())); }
}

void LeituraCEPEL::define_horizonte_otimizacao_CP(Dados& a_dados) {

	try {

		int conteioDias;

		std::string string_periodo;

		IdDia idDia;
		IdMes idMes;
		IdAno idAno;

		//*****************************************
		// Define horizonte otimização
		//*****************************************

		SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao;

		//O DC no mínimo tem dois estágios (pode ocorrer em alguma RV4)
		if (idEstagioMaximo > horizonte_otimizacao_DC.getIteradorFinal())
			idEstagioMaximo = horizonte_otimizacao_DC.getIteradorFinal();

		if (idEstagioMaximo == IdEstagio_2) {

			//*****************************************
			// 1°estágio
			//*****************************************

			const Periodo periodo_inicial = data_execucao + 1;

			Periodo periodo_1(TipoPeriodo_semanal, periodo_inicial);
			horizonte_otimizacao.addElemento(periodo_1);

			//*****************************************
			// 2°estágio
			//*****************************************

			const Periodo periodo_ultimo_estagio_DC = horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal());

			const IdDia idDia_maiordiadomes = periodo_ultimo_estagio_DC.getMaiorDiaDoMes();
			const IdMes idMes_maiordiadomes = horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()).getMes();
			const IdAno idAno_maiordiadomes = horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()).getAno();

			const Periodo maiordiadomes(idDia_maiordiadomes, idMes_maiordiadomes, idAno_maiordiadomes);

			periodo_1++; //Aumenta 1 semana

			idDia = periodo_1.getDia();
			idMes = periodo_1.getMes();
			idAno = periodo_1.getAno();

			string_periodo = getString(idDia) + "/" + getString(idMes) + "/" + getString(idAno);

			Periodo periodo_diario(idDia, idMes, idAno);

			conteioDias = 1; //O primeiro dia conta na formação do periodo
			while (true) {

				periodo_diario++;

				if (periodo_diario > maiordiadomes)
					break;

				conteioDias++;

			}//while (true) {

			if (conteioDias == 1) { string_periodo += "-diario"; }
			else if (conteioDias == 7) { string_periodo += "-semanal"; }
			else if (conteioDias == int(idDia_maiordiadomes)) { string_periodo += "-mensal"; }
			else { string_periodo += "-" + getString(conteioDias) + "dias"; }

			const Periodo periodoMensal(string_periodo);


			const Periodo periodo_2(string_periodo);

			horizonte_otimizacao.addElemento(periodo_2);

			//*****************************************
			// Atualiza vetor horizonte_otimizacao
			//*****************************************

			if (horizonte_otimizacao.getIteradorFinal() != idEstagioMaximo)
				throw std::invalid_argument("idEstagioMaximo utilizado no vetor numero_aberturas nao corresponde ao iteradorFinal do horizonte_otimizacao");

		}//if (idEstagioMaximo == IdEstagio_2) {
		else if (idEstagioMaximo == IdEstagio_3) {

			//*****************************************
			// 1°estágio
			//*****************************************

			const Periodo periodo_inicial = data_execucao + 1;

			Periodo periodo_1(TipoPeriodo_semanal, periodo_inicial);
			horizonte_otimizacao.addElemento(periodo_1);

			//*****************************************
			// 2°estágio
			//*****************************************

			const Periodo periodo_ultimo_estagio_DC = horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal());

			periodo_1++; //Aumenta 1 semana

			idDia = periodo_1.getDia();
			idMes = periodo_1.getMes();
			idAno = periodo_1.getAno();

			string_periodo = getString(idDia) + "/" + getString(idMes) + "/" + getString(idAno);

			Periodo periodo_diario(idDia, idMes, idAno);

			conteioDias = 1; //O primeiro dia conta na formação do periodo
			while (true) {

				periodo_diario++;

				if (periodo_diario >= periodo_ultimo_estagio_DC)
					break;

				conteioDias++;

			}//while (true) {

			if (conteioDias == 1) { string_periodo += "-diario"; }
			else if (conteioDias == 7) { string_periodo += "-semanal"; }
			else { string_periodo += "-" + getString(conteioDias) + "dias"; }

			const Periodo periodo_2(string_periodo);

			horizonte_otimizacao.addElemento(periodo_2);

			//*****************************************
			// 3°estágio
			//*****************************************

			idDia = periodo_diario.getDia();
			idMes = periodo_diario.getMes();
			idAno = periodo_diario.getAno();

			string_periodo = getString(idDia) + "/" + getString(idMes) + "/" + getString(idAno);

			const IdDia idDia_maiordiadomes = periodo_diario.getMaiorDiaDoMes(horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()).getMes());
			const IdMes idMes_maiordiadomes = horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()).getMes();
			const IdAno idAno_maiordiadomes = horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()).getAno();

			const Periodo maiordiadomes(idDia_maiordiadomes, idMes_maiordiadomes, idAno_maiordiadomes);

			conteioDias = 1; //O primeiro dia conta na formação do periodo
			while (true) {

				if (periodo_diario == maiordiadomes)
					break;

				periodo_diario++;
				conteioDias++;

			}//while (true) {


			if (conteioDias == 1) { string_periodo += "-diario"; }
			else if (conteioDias == 7) { string_periodo += "-semanal"; }
			else if (conteioDias == int(idDia_maiordiadomes)) { string_periodo += "-mensal"; }
			else { string_periodo += "-" + getString(conteioDias) + "dias"; }

			const Periodo periodo_3(string_periodo);

			horizonte_otimizacao.addElemento(periodo_3);

			//*****************************************
			// Atualiza vetor horizonte_otimizacao
			//*****************************************

			if (horizonte_otimizacao.getIteradorFinal() != idEstagioMaximo)
				throw std::invalid_argument("idEstagioMaximo utilizado no vetor numero_aberturas nao corresponde ao iteradorFinal do horizonte_otimizacao");

		}//else if (idEstagioMaximo == IdEstagio_3) {
		else
			throw std::invalid_argument("Numero de estagios para o horizonte_otimizacao nao implementado");


		a_dados.setVetor(AttVetorDados_horizonte_otimizacao, horizonte_otimizacao);

	}//try{
	catch (const std::exception& erro) { throw std::invalid_argument("Dados::define_horizonte_otimizacao_CP(Dados &a_dados): \n" + std::string(erro.what())); }
}

void LeituraCEPEL::define_horizonte_estudo_CP(Dados& a_dados) {
	try {

		SmartEnupla<Periodo, IdEstagio>  horizonte_estudo;

		SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());

		//*****************************************
		// Define horizonte estudo
		//*****************************************

		const bool horizonte_estudo_semanal = true;
		const bool ultimo_estagio_mensal = true;

		if (idEstagioMaximo == IdEstagio_2) {

			if (horizonte_estudo_semanal) {

				const IdEstagio idEstagio_IteradorInicial = horizonte_otimizacao.getIteradorInicial();
				const IdEstagio idEstagio_IteradorFinal = horizonte_otimizacao.getIteradorFinal();

				for (IdEstagio idEstagio = idEstagio_IteradorInicial; idEstagio <= idEstagio_IteradorFinal; idEstagio++) {

					if (idEstagio == IdEstagio_1) {

						horizonte_estudo.addElemento(horizonte_otimizacao_DC.getElemento(IdEstagio_1), idEstagio);

					}//if (idEstagio == IdEstagio_1 {

					else if (idEstagio == IdEstagio_2) {

						if (ultimo_estagio_mensal) {

							horizonte_estudo.addElemento(horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()), idEstagio);

						}//if (ultimo_estagio_mensal) {
						else {

							const IdEstagio maioridEstagio_DC = horizonte_otimizacao_DC.getIteradorFinal();

							for (IdEstagio idEstagio_DC = IdEstagio_2; idEstagio_DC <= maioridEstagio_DC; idEstagio_DC++) {

								if (idEstagio_DC < maioridEstagio_DC)
									horizonte_estudo.addElemento(horizonte_otimizacao_DC.getElemento(idEstagio_DC), idEstagio);
								else {

									Periodo periodo_final_DC = horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal());

									const IdDia idDia_maiordiadomes = periodo_final_DC.getMaiorDiaDoMes(horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()).getMes());
									const IdMes idMes_maiordiadomes = periodo_final_DC.getMes();
									const IdAno idAno_maiordiadomes = periodo_final_DC.getAno();

									const Periodo maiordiadomes(idDia_maiordiadomes, idMes_maiordiadomes, idAno_maiordiadomes);

									int conteioDias = 1;

									Periodo periodo_diario_inicial = Periodo(TipoPeriodo_diario, periodo_final_DC);
									Periodo periodo_diario = periodo_diario_inicial;

									while (true) {

										if (conteioDias > 7) {

											Periodo periodo_semanal(TipoPeriodo_semanal, periodo_diario_inicial);
											horizonte_estudo.addElemento(periodo_semanal, idEstagio);

											conteioDias = 1;
											periodo_diario_inicial = periodo_diario;

										}//if (conteioDias == 7) {

										if (periodo_diario >= maiordiadomes) {

											std::string string_periodo = getString(periodo_diario_inicial.getDia()) + "/" + getString(periodo_diario_inicial.getMes()) + "/" + getString(periodo_diario_inicial.getAno());

											if (conteioDias == 7)
												string_periodo += "-semanal";
											else if (conteioDias == 1)
												string_periodo += "-diario";
											else if (conteioDias == int(idDia_maiordiadomes)) { string_periodo += "-mensal"; }
											else
												string_periodo += "-" + getString(conteioDias) + "dias";

											Periodo periodo_final(string_periodo);
											horizonte_estudo.addElemento(periodo_final, idEstagio);

											break;

										}//else if (periodo_diario >= maiordiadomes) {

										periodo_diario++;
										conteioDias++;

									}//while (true) {

								}//else {

							}//for (IdEstagio idEstagio_DC = IdEstagio_2; idEstagio_DC < maioridEstagio_DC; idEstagio_DC++) {

						}// else {

					}//else if (idEstagio == IdEstagio_2) {

				}//for (IdEstagio idEstagio = idEstagio_IteradorInicial; idEstagio <= idEstagio_IteradorFinal; idEstagio++) {

			}//if (horizonte_estudo_semanal) {
			else {
				throw std::invalid_argument("Metodo nao implementado");

			}//else {

		}//if (idEstagioMaximo == IdEstagio_2) {
		else if (idEstagioMaximo == IdEstagio_3) {

			if (horizonte_estudo_semanal) {

				for (IdEstagio idEstagio = horizonte_otimizacao.getIteradorInicial(); idEstagio <= horizonte_otimizacao.getIteradorFinal(); idEstagio++) {

					if (idEstagio == IdEstagio_1)
						horizonte_estudo.addElemento(horizonte_otimizacao_DC.getElemento(IdEstagio_1), idEstagio);

					else if (idEstagio == IdEstagio_2)
						for (IdEstagio idEstagio_DC = IdEstagio_2; idEstagio_DC < horizonte_otimizacao_DC.getIteradorFinal(); idEstagio_DC++)
							horizonte_estudo.addElemento(horizonte_otimizacao_DC.getElemento(idEstagio_DC), idEstagio);

					else if (idEstagio == IdEstagio_3) {

						if (ultimo_estagio_mensal) {

							horizonte_estudo.addElemento(horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()), idEstagio);

						}//if (ultimo_estagio_mensal) {
						else {
							//Realiza uma discretizado em dias e semanas

							Periodo periodo_final_DC = horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal());

							const IdDia idDia_maiordiadomes = periodo_final_DC.getMaiorDiaDoMes(horizonte_otimizacao_DC.getElemento(horizonte_otimizacao_DC.getIteradorFinal()).getMes());
							const IdMes idMes_maiordiadomes = periodo_final_DC.getMes();
							const IdAno idAno_maiordiadomes = periodo_final_DC.getAno();

							const Periodo maiordiadomes(idDia_maiordiadomes, idMes_maiordiadomes, idAno_maiordiadomes);

							int conteioDias = 1;

							Periodo periodo_diario_inicial = Periodo(TipoPeriodo_diario, periodo_final_DC);
							Periodo periodo_diario = periodo_diario_inicial;

							while (true) {

								if (conteioDias > 7) {

									Periodo periodo_semanal(TipoPeriodo_semanal, periodo_diario_inicial);
									horizonte_estudo.addElemento(periodo_semanal, idEstagio);

									conteioDias = 1;
									periodo_diario_inicial = periodo_diario;

								}//if (conteioDias == 7) {

								if (periodo_diario >= maiordiadomes) {

									std::string string_periodo = getString(periodo_diario_inicial.getDia()) + "/" + getString(periodo_diario_inicial.getMes()) + "/" + getString(periodo_diario_inicial.getAno());

									if (conteioDias == 7)
										string_periodo += "-semanal";
									else if (conteioDias == 1)
										string_periodo += "-diario";
									else if (conteioDias == int(idDia_maiordiadomes)) { string_periodo += "-mensal"; }
									else
										string_periodo += "-" + getString(conteioDias) + "dias";

									Periodo periodo_final(string_periodo);
									horizonte_estudo.addElemento(periodo_final, idEstagio);

									break;

								}//else if (periodo_diario >= maiordiadomes) {

								periodo_diario++;
								conteioDias++;

							}//while (true) {

						}

					}//else if (idEstagio == IdEstagio_3) {

				}//for (IdEstagio idEstagio = idEstagio_IteradorInicial; idEstagio <= idEstagio_IteradorFinal; idEstagio++) {

			}//if (horizonte_estudo_semanal) {

		}//else if (idEstagioMaximo == IdEstagio_3) {

		else
			throw std::invalid_argument("Numero de estagios para o horizonte_otimizacao nao implementado");

		//*****************************************
		// Atualiza vetor horizonte_estudo
		//*****************************************

		a_dados.setVetor(AttVetorDados_horizonte_estudo, horizonte_estudo);


	}//try{
	catch (const std::exception& erro) { throw std::invalid_argument("Dados::define_horizonte_estudo_CP(Dados &a_dados): \n" + std::string(erro.what())); }
}

void LeituraCEPEL::valida_horizonte_estudo_CP_respeito_horizonte_otimizacao_DC(Dados& a_dados) {
	try {

		//*****************************************
		// Verifica que os tipos de períodos do horizonte_estudo sejam menores ou iguais ao tipos de períodos do horizonte_otimizacao_DC
		//*****************************************

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		const IdEstagio idEstagio_inicial = horizonte_otimizacao_DC.getIteradorInicial();
		const IdEstagio idEstagio_final = horizonte_otimizacao_DC.getIteradorFinal();

		for (IdEstagio idEstagio_DC = idEstagio_inicial; idEstagio_DC <= idEstagio_final; idEstagio_DC++) {

			const Periodo periodo_DC = horizonte_otimizacao_DC.at(idEstagio_DC);

			for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				const double sobreposicao = periodo.sobreposicao(periodo_DC); //Quanto o periodo_DC preenche o periodo

				if (sobreposicao > 0 && sobreposicao != 1.0) //Significa que um período de estudo tem um tipo maior que o período DC
					throw std::invalid_argument("Periodo no horizonte de estudo com tipo maior ao periodo do modelo DECOMP");

			}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {
				
		}//for (IdEstagio idEstagio_DC = idEstagio_inicial; idEstagio_DC <= idEstagio_final; idEstagio_DC++) {

	}//try{
	catch (const std::exception& erro) { throw std::invalid_argument("Dados::valida_horizonte_estudo_CP_respeito_horizonte_otimizacao_DC(Dados &a_dados): \n" + std::string(erro.what())); }
}

SmartEnupla<IdCenario, SmartEnupla<Periodo, IdRealizacao>> LeituraCEPEL::define_mapeamento_espaco_amostral_arvore_simetrica_CP(Dados& a_dados, const IdCenario a_cenario_inicial, const IdCenario a_cenario_final)
{
	try {

		//Filosofia: Somente serve se a árvore de cenários for simêtrica
		//Assume-se que o processo estocástico realiza como o DECOMP, i.e., semanal/semanal/.../mensal


		const int numero_cenarios = a_dados.getAtributo(AttComumDados_numero_cenarios, int());

		const IdCenario cenario_final = IdCenario(numero_cenarios);

		SmartEnupla<IdCenario, SmartEnupla<Periodo, IdRealizacao>> mapeamento_espaco_amostral_arvore_simetrica;
		SmartEnupla<IdCenario, SmartEnupla<Periodo, IdRealizacao>> mapeamento_espaco_amostral_arvore_simetrica_reduzida;

		////////////////////////////////////////////////////////////////
		//Cria vetor com o número de "sub-cenários" em cada nó da árvore
		////////////////////////////////////////////////////////////////

		SmartEnupla<Periodo, int> numero_sub_cenarios;

		for (Periodo periodo = horizonte_processo_estocastico.getIteradorInicial(); periodo <= horizonte_processo_estocastico.getIteradorFinal(); horizonte_processo_estocastico.incrementarIterador(periodo)) {

			int sub_cenarios = numero_cenarios;

			sub_cenarios /= numero_realizacoes_por_periodo.getElemento(periodo);
			numero_sub_cenarios.addElemento(periodo, sub_cenarios);

		}//for (Periodo periodo = horizonte_processo_estocastico.getIteradorInicial(); periodo <= horizonte_processo_estocastico.getIteradorFinal(); horizonte_processo_estocastico.incrementarIterador(periodo)) {

		////////////////////////////////////////////////////////////////

		/////////////////////////////////////////////////
		//Realiza mapeamento espaço amostral
		/////////////////////////////////////////////////

		SmartEnupla<Periodo, int> conteio_sub_cenarios(numero_sub_cenarios, 0);
		SmartEnupla<Periodo, int> realizacao(numero_sub_cenarios, 1);


		for (IdCenario idCenario = IdCenario_1; idCenario <= cenario_final; idCenario++) {

			SmartEnupla<Periodo, IdRealizacao> mapeamento_espaco_amostral_arvore_simetrica_cenario;

			for (Periodo periodo = horizonte_processo_estocastico.getIteradorInicial(); periodo <= horizonte_processo_estocastico.getIteradorFinal(); horizonte_processo_estocastico.incrementarIterador(periodo)) {

				const int sub_cenarios = numero_sub_cenarios.getElemento(periodo);

				if (conteio_sub_cenarios.getElemento(periodo) >= sub_cenarios) {

					const int aumento_realizacao = realizacao.getElemento(periodo) + 1;
					realizacao.setElemento(periodo, aumento_realizacao);

					conteio_sub_cenarios.setElemento(periodo, 0);

				}//if (conteio_sub_cenarios.getElemento(periodo) > sub_cenarios) {

				const IdRealizacao idRealizacao = IdRealizacao(realizacao.getElemento(periodo));

				mapeamento_espaco_amostral_arvore_simetrica_cenario.addElemento(periodo, idRealizacao);

				///////////

				const int aumento_sub_cenarios = conteio_sub_cenarios.getElemento(periodo) + 1;
				conteio_sub_cenarios.setElemento(periodo, aumento_sub_cenarios);

			}//for (Periodo periodo = horizonte_processo_estocastico.getIteradorInicial(); periodo <= horizonte_processo_estocastico.getIteradorFinal(); horizonte_processo_estocastico.incrementarIterador(periodo)) {

			/////////////////////////////////////////////////////////////////

			mapeamento_espaco_amostral_arvore_simetrica.addElemento(idCenario, mapeamento_espaco_amostral_arvore_simetrica_cenario);

		}//for (IdCenario idCenario = a_cenario_inicial; idCenario <= a_cenario_final; idCenario++) {

		///////////////////////////////////////////////////////////////////////
		//Reduzir mapeamento_espaco_amostral_arvore_simetrica 
		//de acordo aos IdCenario a_cenario_inicial, IdCenario a_cenario_final
		///////////////////////////////////////////////////////////////////////

		if (a_cenario_inicial == IdCenario_1 && a_cenario_final == cenario_final)
			mapeamento_espaco_amostral_arvore_simetrica_reduzida = mapeamento_espaco_amostral_arvore_simetrica;
		else {

			for (IdCenario idCenario = a_cenario_inicial; idCenario <= a_cenario_final; idCenario++)
				mapeamento_espaco_amostral_arvore_simetrica_reduzida.addElemento(idCenario, mapeamento_espaco_amostral_arvore_simetrica.getElemento(idCenario));

		}//else {

		return mapeamento_espaco_amostral_arvore_simetrica_reduzida;

	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::define_mapeamento_espaco_amostral_arvore_simetrica_CP: \n" + std::string(erro.what())); }

}

/*
void LeituraCEPEL::define_realizacao_transformada_espaco_amostral_arvore_completa_CP(Dados& a_dados)
{
	try {

		//Horizonte do processo estocástico
		//const SmartEnupla<Periodo, IdEstagio> horizonte_processo_estocastico = a_dados.processoEstocastico_hidrologico.getVetor(AttVetorProcessoEstocastico_horizonte_processo_estocastico, Periodo(), IdEstagio());

		/////////////////////////////////////////////////
		//Determina o número de cenários da árvore
		/////////////////////////////////////////////////

		//const IdEstagio idEstagio_inicial = a_numero_realizacoes_por_estagio.getIteradorInicial();
		//const IdEstagio idEstagio_final = a_numero_realizacoes_por_estagio.getIteradorFinal();

		const int numero_cenarios = a_dados.getAtributo(AttComumDados_numero_cenarios, int());
		const IdCenario cenario_final = IdCenario(numero_cenarios);
		const IdCenario cenario_inicial = IdCenario_1;

		const IdVariavelAleatoria maiorIdVariavelAleatoria = a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.getMaiorId();

		const SmartEnupla <IdCenario, SmartEnupla<Periodo, IdRealizacao>> mapeamento_espaco_amostral = define_mapeamento_espaco_amostral_arvore_simetrica_CP(a_dados, cenario_inicial, cenario_final);

		/////////////////////////////////////////////////
		//Realiza mapeamento espaço amostral
		/////////////////////////////////////////////////

		for (IdCenario idCenario = cenario_inicial; idCenario <= cenario_final; idCenario++) {

			for (IdVariavelAleatoria idVariavelAleatoria = IdVariavelAleatoria_1; idVariavelAleatoria <= maiorIdVariavelAleatoria; idVariavelAleatoria++) {

				for (Periodo periodo = horizonte_processo_estocastico.getIteradorInicial(); periodo <= horizonte_processo_estocastico.getIteradorFinal(); horizonte_processo_estocastico.incrementarIterador(periodo)) {

					//const IdRealizacao idRealizacao = a_dados.processoEstocastico_hidrologico.getElementoMatriz(AttMatrizProcessoEstocastico_mapeamento_espaco_amostral, idCenario, periodo, IdRealizacao());

					const IdRealizacao idRealizacao = mapeamento_espaco_amostral.getElemento(idCenario).getElemento(periodo);

					const double afluencia = a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVariavelAleatoria).getElementoMatriz(AttMatrizVariavelAleatoria_residuo_espaco_amostral, periodo, idRealizacao, double());

					a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVariavelAleatoria).addElemento(AttMatrizVariavelAleatoria_cenarios_realizacao_transformada_espaco_amostral, idCenario, periodo, afluencia);

				}//for (Periodo periodo = horizonte_processo_estocastico.getIteradorInicial(); periodo <= horizonte_processo_estocastico.getIteradorFinal(); horizonte_processo_estocastico.incrementarIterador(periodo)) {

			}//for (IdVariavelAleatoria idVariavelAleatoria = IdVariavelAleatoria_1; idVariavelAleatoria <= maiorIdVariavelAleatoria; idVariavelAleatoria++) {

		}//for (IdCenario idCenario = cenario_inicial; idCenario <= cenario_final; idCenario++) {

	}//try {
	catch (const std::exception & erro) { throw std::invalid_argument("LeituraCEPEL::define_realizacao_transformada_espaco_amostral_arvore_completa_CP(Dados& a_dados): \n" + std::string(erro.what())); }

}//void LeituraCEPEL::define_realizacao_transformada_espaco_amostral_DC(Dados& a_dados)
*/

void LeituraCEPEL::define_numero_cenarios_CP(Dados& a_dados) {

	try {

		const int numero_maximo_cenarios = 8000;

		const SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());
		const SmartEnupla<IdEstagio, int> numero_aberturas = a_dados.getVetor(AttVetorDados_numero_aberturas, IdEstagio(), int());

		/////////////////////////////////////////////////
		//Determina o número de cenários da árvore
		/////////////////////////////////////////////////

		int numero_cenarios = 1;

		if (int(numero_realizacoes_por_periodo.size())) {

			//Assume-se que a árvore é simêtrica

			for (Periodo periodo = horizonte_processo_estocastico.getIteradorInicial(); periodo <= horizonte_processo_estocastico.getIteradorFinal(); horizonte_processo_estocastico.incrementarIterador(periodo))
				numero_cenarios *= numero_realizacoes_por_periodo.getElemento(periodo);

		}//else if (int(numero_realizacoes_por_periodo.size())) {
		else
			throw std::invalid_argument("Deve ser informado o mapeamento_arvore_cenarios ou numero_realizacoes_por_periodo");

		if (!dadosPreConfig_instanciados) {

			if (numero_cenarios > numero_maximo_cenarios)
				numero_cenarios = numero_maximo_cenarios;

			a_dados.setAtributo(AttComumDados_numero_cenarios, numero_cenarios);
			//a_dados.setAtributo(AttComumDados_visitar_todos_cenarios_por_iteracao, true);

		}//if (!dadosPreConfig_instanciados) {
		else {
			if (a_dados.getAtributo(AttComumDados_numero_cenarios, int()) > numero_cenarios)
				throw std::invalid_argument("Pre-config deve ter numero_cenarios menor ou igual a: " + getString(numero_cenarios));
		}//	else {

	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::define_numero_cenarios_CP(Dados& a_dados): \n" + std::string(erro.what())); }

}

void LeituraCEPEL::define_afluencia_arvore_de_cenarios_postos_CP(Dados& a_dados) {

	try {

		const SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());

		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		const int numero_nos = int(vazao_no_posto.size());

		for (int no = 0; no < numero_nos; no++) {

			/////////////////////////////////////////////////////////////////////////////////////
			//Identifica o estágio do registro
			//Filosofia: Devido à estrutura da árvore DECOMP  o arquivo de VAZOES.DAT
			//o idNo = idEstagio para t < T
			// 
			//Períodos no horizonte de otimização diferentes ao horizonte do processo estocástico:
			// 1. Vai ter só aberturas no primeiro período de otimização com sobreposição com o períoodo do horizonte do processo estocástico
			// 2. O valor do residuo vai ser alocado no primeiro período de otimização com sobreposição com o períoodo do horizonte do processo estocástico, caso contrário, afluencia = 0
			// 3. Por meio da estrutura do modelo PAR coloca-se 100 % de autocorreção com o período anterior
			/////////////////////////////////////////////////////////////////////////////////////

			IdEstagio idEstagio_DC = IdEstagio_Nenhum;

			const int numero_estagios_DC = int(horizonte_otimizacao_DC.size());

			if (no + 1 < numero_estagios_DC)
				idEstagio_DC = IdEstagio(no + 1);
			else
				idEstagio_DC = horizonte_otimizacao_DC.getIteradorFinal();

			///////////////////

			const Periodo periodo_DC = horizonte_otimizacao_DC.at(idEstagio_DC);

			double soma_sobreposicao = 0.0;

			bool is_encontrada_sobreposicao = false;

			for (IdEstagio idEstagio_otimizacao = horizonte_otimizacao.getIteradorInicial(); idEstagio_otimizacao <= horizonte_otimizacao.getIteradorFinal(); idEstagio_otimizacao++) {

				const Periodo periodo_otimizacao = horizonte_otimizacao.getElemento(idEstagio_otimizacao);

				const double sobreposicao = periodo_DC.sobreposicao(periodo_otimizacao);
				
				if (sobreposicao > 0.0) {

					is_encontrada_sobreposicao = true;

					///////////////////////////////////////////////////////
					//Determina o periodo do processo estocástico (pega a menor granularidade entre o periodo_DC e o periodo_otimizacao)
					// E identifica se é o primeiro período com sobreposição
					///////////////////////////////////////////////////////

					Periodo periodo_processo_estocastico = periodo_DC;
					bool is_first_sobreposicao = false;

					if (periodo_DC.getTipoPeriodo() <= periodo_otimizacao.getTipoPeriodo()) { //Granularidade do periodo_otimizacao <= periodo_DC
						periodo_processo_estocastico = periodo_otimizacao;

						if(periodo_otimizacao.sobreposicao(periodo_DC) == 1.0)//Garante que o periodo_otimizacao esteja "dentro" do periodo_DC
							soma_sobreposicao += sobreposicao;

						//////////////
						const Periodo periodo_teste = Periodo(periodo_otimizacao.getTipoPeriodo(), periodo_DC);

						if (periodo_teste == periodo_otimizacao)
							is_first_sobreposicao = true;

					}//if (periodo_DC.getTipoPeriodo() < periodo_otimizacao.getTipoPeriodo()) {
					else { //Granularidade do periodo_otimizacao > periodo_DC
						soma_sobreposicao += sobreposicao;
						is_first_sobreposicao = true;

					}//else {

					//////////////////////////////////////////////////////

					for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

						const int posto = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_codigo_posto, int());

						double afluencia = vazao_no_posto.at(no).at(posto - 1);

						if (!is_first_sobreposicao && (idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal()))
							afluencia = 0.0;

						IdRealizacao idRealizacao = IdRealizacao_1;

						if (is_first_sobreposicao && idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal())
							idRealizacao = IdRealizacao(no - numero_estagios_DC + 2); //Cada registro do último estágio é uma realização


						if (is_first_sobreposicao || (!is_first_sobreposicao && (no - numero_estagios_DC + 1 == 0)) || (!is_first_sobreposicao && (idEstagio_DC < horizonte_otimizacao_DC.getIteradorFinal())))
							a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(lista_hidreletrica_IdVariavelAleatoria.at(idHidreletrica)).addElemento(AttMatrizVariavelAleatoria_residuo_espaco_amostral, periodo_processo_estocastico, idRealizacao, afluencia);

					}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				}//if (sobreposicao_preenche_periodo_DC > 0 ) {

				if (is_encontrada_sobreposicao && sobreposicao == 0.0) {

					if (!doubleCompara(1e-6, soma_sobreposicao, 1.0))
						throw std::invalid_argument("Periodo do processo estocastico nao subsituido por uma decomposicao equivalente");

					break;

				}//if (is_encontrada_sobreposicao && sobreposicao == 0.0) {

			}//for (IdEstagio idEstagio_otimizacao = horizonte_otimizacao.getIteradorInicial(); idEstagio_otimizacao <= horizonte_otimizacao.getIteradorFinal(); idEstagio_otimizacao++) {

		}//for (int no = 0; no < numero_nos; no++) {

	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::define_afluencia_arvore_de_cenarios_postos_CP: \n" + std::string(erro.what())); }

} // void LeituraCEPEL::define_afluencia_postos_CP(Dados& a_dados) {

void LeituraCEPEL::define_variavel_aleatoria_interna_CP(Dados& a_dados){
	try {

		if (!processoEstocasticoHidrologicoPreConfig_instanciado) {

			//Nota: A VariavelAleatoriaInterna armazena os valores de afluência passadas + tendência (afluências menores ao periodo de acoplamento) + residuo_espaco_amostral (processo estocástico)
			//Logo na validação imprime na afluência_tendencia para o problema de MP, e limita a VariavelAleatoriaInterna somente à tendência

			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
			const SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaEnd = a_dados.getMaiorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			SmartEnupla<Periodo, SmartEnupla<IdHidreletrica, double>> afluencia_incremental_periodo_hidreletrica_GEVAZP;

			if (int(valor_afluencia_passadas_GEVAZP.size()) > 0) {//Somente reporta a tendência das afluências passadas se são incluídos os arquivos GEVAZP: VAZOES.DAT e PREVS.RVX

				//Inicializa vetores de afluência natural das hidréletricas por periodo

				const Periodo periodo_inicial_historico = valor_afluencia_passadas_GEVAZP.at(0).getIteradorInicial();
				const Periodo periodo_final_historico = valor_afluencia_passadas_GEVAZP.at(0).getIteradorFinal();

				for (Periodo periodo = periodo_inicial_historico; periodo <= periodo_final_historico; valor_afluencia_passadas_GEVAZP.at(0).incrementarIterador(periodo)) {

					SmartEnupla<IdHidreletrica, double> afluencia_natural_hidreletrica_GEVAZP = SmartEnupla<IdHidreletrica, double>(idHidreletricaIni, std::vector<double>(int(idHidreletricaEnd - idHidreletricaIni) + 1, NAN));

					for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

						const int posto = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_codigo_posto, int());

						if (posto == 168) { //Sobradinho (Posto incremental 168 + as afluências naturais dos postos a montante para obter a natural de sobradinho)

							double vazao_afluencia_natural = valor_afluencia_passadas_GEVAZP.at(posto - 1).getElemento(periodo);

							const int numero_hidreletricas_montante = a_dados.getSizeVetor(idHidreletrica, AttVetorHidreletrica_montante);
							for (int m = 1; m <= numero_hidreletricas_montante; m++) {
								const IdHidreletrica idHidreletrica_montante = a_dados.getElementoVetor(idHidreletrica, AttVetorHidreletrica_montante, m, IdHidreletrica());

								vazao_afluencia_natural += valor_afluencia_passadas_GEVAZP.at(a_dados.vetorHidreletrica.at(idHidreletrica_montante).getAtributo(AttComumHidreletrica_codigo_posto, int()) - 1).getElemento(periodo);

							}//for (int m = 1; m <= numero_hidreletricas_montante; m++) {

							afluencia_natural_hidreletrica_GEVAZP.setElemento(idHidreletrica, vazao_afluencia_natural);

						}//if (posto == 168) {
						else
							afluencia_natural_hidreletrica_GEVAZP.setElemento(idHidreletrica, valor_afluencia_passadas_GEVAZP.at(posto - 1).getElemento(periodo));


					}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

					//Calcula a afluência incremental
					const SmartEnupla<IdHidreletrica, double> afluencia_incremental_hidreletrica_GEVAZP = a_dados.calculaAfluenciaIncremental(afluencia_natural_hidreletrica_GEVAZP);

					afluencia_incremental_periodo_hidreletrica_GEVAZP.addElemento(periodo, afluencia_incremental_hidreletrica_GEVAZP);

				}//for (Periodo periodo = periodo_inicial_historico; periodo <= periodo_final_historico; valor_afluencia_passadas.at(0).incrementarIterador(periodo)) {

			}//if (int(valor_afluencia_passadas_GEVAZP.size()) > 0) {

			SmartEnupla<Periodo, SmartEnupla<IdHidreletrica, double>> afluencia_incremental_periodo_hidreletrica_historico;
			SmartEnupla<Periodo, SmartEnupla<IdHidreletrica, double>> afluencia_natural_periodo_hidreletrica_historico;

			if (int(valor_afluencia_historica.size()) > 0) {//Somente reporta a tendência das afluências passadas se são incluídos os arquivos GEVAZP: VAZOES.DAT e PREVS.RVX

				//Inicializa vetores de afluência natural das hidréletricas por periodo

				const Periodo periodo_inicial_historico = valor_afluencia_historica.at(0).getIteradorInicial();
				const Periodo periodo_final_historico = valor_afluencia_historica.at(0).getIteradorFinal();

				for (Periodo periodo = periodo_inicial_historico; periodo <= periodo_final_historico; valor_afluencia_historica.at(0).incrementarIterador(periodo)) {

					SmartEnupla<IdHidreletrica, double> afluencia_natural_hidreletrica_historica = SmartEnupla<IdHidreletrica, double>(idHidreletricaIni, std::vector<double>(int(idHidreletricaEnd - idHidreletricaIni) + 1, NAN));

					for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

						int posto = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_codigo_posto, int());

						if (posto == 168) { //Sobradinho (Posto incremental 168 + as afluências naturais dos postos a montante para obter a natural de sobradinho)

							double vazao_afluencia_natural = valor_afluencia_historica.at(posto - 1).getElemento(periodo);

							const int numero_hidreletricas_montante = a_dados.getSizeVetor(idHidreletrica, AttVetorHidreletrica_montante);
							for (int m = 1; m <= numero_hidreletricas_montante; m++) {
								const IdHidreletrica idHidreletrica_montante = a_dados.getElementoVetor(idHidreletrica, AttVetorHidreletrica_montante, m, IdHidreletrica());

								vazao_afluencia_natural += valor_afluencia_historica.at(a_dados.vetorHidreletrica.at(idHidreletrica_montante).getAtributo(AttComumHidreletrica_codigo_posto, int()) - 1).getElemento(periodo);

							}//for (int m = 1; m <= numero_hidreletricas_montante; m++) {

							afluencia_natural_hidreletrica_historica.setElemento(idHidreletrica, vazao_afluencia_natural);

						}//if (posto == 168) {
						else
							afluencia_natural_hidreletrica_historica.setElemento(idHidreletrica, valor_afluencia_historica.at(posto - 1).getElemento(periodo));

					}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

					//Calcula a afluência incremental
					const SmartEnupla<IdHidreletrica, double> afluencia_incremental_hidreletrica_historico = a_dados.calculaAfluenciaIncremental(afluencia_natural_hidreletrica_historica);

					afluencia_incremental_periodo_hidreletrica_historico.addElemento(periodo, afluencia_incremental_hidreletrica_historico);
					afluencia_natural_periodo_hidreletrica_historico.addElemento(periodo, afluencia_natural_hidreletrica_historica);

				}//for (Periodo periodo = periodo_inicial_historico; periodo <= periodo_final_historico; valor_afluencia_passadas.at(0).incrementarIterador(periodo)) {

			}//if (int(valor_afluencia_historica.size()) > 0) {

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				SmartEnupla<Periodo, double> tendencia_temporal;

				const int posto = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_codigo_posto, int());

				const IdVariavelAleatoria idVariavelAleatoria = lista_hidreletrica_IdVariavelAleatoria.at(idHidreletrica);

				VariavelAleatoriaInterna variavelAleatoriaInterna;
				variavelAleatoriaInterna.setAtributo(AttComumVariavelAleatoriaInterna_idVariavelAleatoriaInterna, IdVariavelAleatoriaInterna_1);
				variavelAleatoriaInterna.setAtributo(AttComumVariavelAleatoriaInterna_nome, getFullString(idHidreletrica));

				a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVariavelAleatoria).vetorVariavelAleatoriaInterna.add(variavelAleatoriaInterna);

				////////////////////////

				//const Periodo periodo_acoplamento = horizonte_otimizacao.getElemento(a_dados.getAtributo(AttComumDados_estagio_acoplamento_pre_estudo, IdEstagio()));

				// XXX DECOMP

				SmartEnupla<Periodo, bool> horizonte_processo_estocastico_sem_extencao;

				const Periodo periodo_ultimo_sobreposicao = get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados);

				for (Periodo periodo = horizonte_processo_estocastico.getIteradorInicial(); periodo <= horizonte_processo_estocastico.getIteradorFinal(); horizonte_processo_estocastico.incrementarIterador(periodo)) {

					if (periodo <= periodo_ultimo_sobreposicao)
						horizonte_processo_estocastico_sem_extencao.addElemento(periodo, true);

				}//for (Periodo periodo = horizonte_processo_estocastico.getIteradorInicial(); periodo <= horizonte_processo_estocastico.getIteradorFinal(); horizonte_processo_estocastico.incrementarIterador(periodo)) {

				///////////////

				a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVariavelAleatoria).vetorVariavelAleatoriaInterna.at(IdVariavelAleatoriaInterna_1).setAtributo(AttComumVariavelAleatoriaInterna_grau_liberdade, 0.0);

				a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVariavelAleatoria).setVetor(AttVetorVariavelAleatoria_tipo_relaxacao, SmartEnupla<Periodo, TipoRelaxacaoVariavelAleatoria>(horizonte_processo_estocastico_sem_extencao, TipoRelaxacaoVariavelAleatoria_sem_relaxacao));
				a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVariavelAleatoria).vetorVariavelAleatoriaInterna.at(IdVariavelAleatoriaInterna_1).setVetor(AttVetorVariavelAleatoriaInterna_coeficiente_participacao, SmartEnupla<Periodo, double>(horizonte_processo_estocastico_sem_extencao, 1.0));

				for (Periodo periodo = horizonte_processo_estocastico_sem_extencao.getIteradorInicial(); periodo <= horizonte_processo_estocastico_sem_extencao.getIteradorFinal(); horizonte_processo_estocastico_sem_extencao.incrementarIterador(periodo)) {

					bool is_encontrada_sobreposicao = false;

					for (IdEstagio idEstagio_DC = horizonte_otimizacao_DC.getIteradorInicial(); idEstagio_DC <= horizonte_otimizacao_DC.getIteradorFinal(); idEstagio_DC++) {

						const double sobreposicao = horizonte_otimizacao_DC.at(idEstagio_DC).sobreposicao(periodo);

						if (sobreposicao > 0.0) {

							is_encontrada_sobreposicao = true;

							///////////////////////////////////////////////////////
							//Identifica se é o primeiro período com sobreposição
							///////////////////////////////////////////////////////

							bool is_first_sobreposicao = false;

							if (horizonte_otimizacao_DC.at(idEstagio_DC).getTipoPeriodo() <= periodo.getTipoPeriodo()) { //Granularidade do periodo_otimizacao <= periodo_DC

								const Periodo periodo_teste = Periodo(periodo.getTipoPeriodo(), horizonte_otimizacao_DC.at(idEstagio_DC));

								if (periodo_teste == periodo)
									is_first_sobreposicao = true;

							}//if (periodo_DC.getTipoPeriodo() < periodo_otimizacao.getTipoPeriodo()) {
							else { //Granularidade do periodo_otimizacao > periodo_DC
								is_first_sobreposicao = true;

							}//else {

							//////////////////////////////////////////////////////

							double coeficiente_linear_auto_correlacao = 0.0;

							if (!is_first_sobreposicao and idEstagio_DC == horizonte_otimizacao_DC.getIteradorFinal())
								coeficiente_linear_auto_correlacao = 1.0;

							a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVariavelAleatoria).addElemento(AttMatrizVariavelAleatoria_coeficiente_linear_auto_correlacao, periodo, 1, coeficiente_linear_auto_correlacao);


						}//if (sobreposicao == 1.0) {

						if (is_encontrada_sobreposicao && sobreposicao == 0.0)
							break;

					}//for (IdEstagio idEstagio_otimizacao = horizonte_otimizacao.getIteradorInicial(); idEstagio_otimizacao <= horizonte_otimizacao.getIteradorFinal(); idEstagio_otimizacao++) {

				}//for (Periodo periodo = horizonte_processo_estocastico_sem_extencao.getIteradorInicial(); periodo <= horizonte_processo_estocastico_sem_extencao.getIteradorFinal(); horizonte_processo_estocastico_sem_extencao.incrementarIterador(periodo)) {


					///////////////////////////////////////////////
					//1. Afluências passadas
					///////////////////////////////////////////////

				if (int(valor_afluencia_passadas_GEVAZP.size()) > 0) { //Somente reporta a tendência das afluências passadas se são incluídos os arquivos GEVAZP: VAZOES.DAT e PREVS.RVX

					const Periodo periodo_inicial_historico = valor_afluencia_passadas_GEVAZP.at(posto - 1).getIteradorInicial();
					const Periodo periodo_final_historico = valor_afluencia_passadas_GEVAZP.at(posto - 1).getIteradorFinal();

					for (Periodo periodo = periodo_inicial_historico; periodo <= periodo_final_historico; valor_afluencia_passadas_GEVAZP.at(posto - 1).incrementarIterador(periodo)) {

						double afluencia_incremental;

						if (posto == 300)//posto com incremental 0
							afluencia_incremental = 0;
						else
							afluencia_incremental = afluencia_incremental_periodo_hidreletrica_GEVAZP.at(periodo).getElemento(idHidreletrica);

						tendencia_temporal.addElemento(periodo, afluencia_incremental);

					}//for (Periodo periodo = periodo_inicial_historico; periodo <= periodo_final_historico; valor_afluencia_passadas.at(posto-1).incrementarIterador(periodo)) {

				}//if (int(valor_afluencia_passadas.size()) > 0) {

				///////////////////////////////////////////////
				//2. Afluências histórico
				///////////////////////////////////////////////

				if (int(valor_afluencia_historica.size()) > 0) { //Somente reporta a o histórico das afluências se são incluídos os arquivos GEVAZP: VAZOES.DAT

					const Periodo periodo_inicial_historico = valor_afluencia_historica.at(posto - 1).getIteradorInicial();
					const Periodo periodo_final_historico = valor_afluencia_historica.at(posto - 1).getIteradorFinal();

					for (Periodo periodo = periodo_inicial_historico; periodo <= periodo_final_historico; valor_afluencia_historica.at(posto - 1).incrementarIterador(periodo)) {

						if (horizonte_estudo.getIteradorInicial().sobreposicao(periodo) == 0.0) {//Não pega períodos dentro do horizonte de estudo

							double afluencia_incremental;

							if (posto == 300)//posto com incremental 0
								afluencia_incremental = 0;
							else
								afluencia_incremental = afluencia_incremental_periodo_hidreletrica_historico.at(periodo).getElemento(idHidreletrica);

							if (!a_dados.vetorHidreletrica.at(idHidreletrica).vetorAfluencia.isInstanciado(IdAfluencia_vazao_afluente)) {
								Afluencia afluencia;
								afluencia.setAtributo(AttComumAfluencia_idAfluencia, IdAfluencia_vazao_afluente);
								a_dados.vetorHidreletrica.at(idHidreletrica).vetorAfluencia.add(afluencia);
							}

							a_dados.vetorHidreletrica.at(idHidreletrica).vetorAfluencia.at(IdAfluencia_vazao_afluente).addElemento(AttVetorAfluencia_incremental_historico, periodo, afluencia_incremental);
							a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVariavelAleatoria).vetorVariavelAleatoriaInterna.at(IdVariavelAleatoriaInterna_1).addElemento(AttVetorVariavelAleatoriaInterna_serie_temporal, periodo, afluencia_incremental);
							a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVariavelAleatoria).vetorVariavelAleatoriaInterna.at(IdVariavelAleatoriaInterna_1).addElemento(AttVetorVariavelAleatoriaInterna_serie_temporal_transformada, periodo, afluencia_incremental);
							//a_dados.vetorHidreletrica.at(idHidreletrica).vetorAfluencia.at(IdAfluencia_vazao_afluente).addElemento(AttVetorAfluencia_natural_historico, periodo, afluencia_natural_periodo_hidreletrica_historico.at(periodo).getElemento(idHidreletrica));

						}//if (horizonte_estudo.getIteradorInicial().sobreposicao(periodo) == 0.0) {

					}//for (Periodo periodo = periodo_inicial_historico; periodo <= periodo_final_historico; valor_afluencia_passadas.at(posto-1).incrementarIterador(periodo)) {

				}//if (int(valor_afluencia_passadas.size()) > 0) {

				a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVariavelAleatoria).addTendenciaTemporalVariavelAleatoriaInterna(IdVariavelAleatoriaInterna_1, tendencia_temporal);
				

			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

		}//if (!processoEstocasticoHidrologicoPreConfig_instanciado) {
		/*
		else {

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			const SmartEnupla<Periodo, double> horizonte_tendencia(a_dados.processoEstocastico_hidrologico.getVetor(IdVariavelAleatoria_1, IdVariavelAleatoriaInterna_1, AttVetorVariavelAleatoriaInterna_tendencia_temporal, Periodo(), double()), NAN);

			valor_afluencia_passadas_GEVAZP = SmartEnupla<int, SmartEnupla<Periodo, double>>(0, std::vector<SmartEnupla<Periodo, double>>(320, horizonte_tendencia));

			for (Periodo periodo = horizonte_tendencia.getIteradorInicial(); periodo <= horizonte_tendencia.getIteradorFinal(); horizonte_tendencia.incrementarIterador(periodo)) {

				for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

					IdVariavelAleatoria idVar = IdVariavelAleatoria_Nenhum;
					IdVariavelAleatoriaInterna idVarInt = IdVariavelAleatoriaInterna_Nenhum;

					a_dados.processoEstocastico_hidrologico.getIdVariavelAleatoriaIdVariavelAleatoriaInternaFromIdFisico(idVar, idVarInt, idHidreletrica);

					const double afluencia_incremental = a_dados.processoEstocastico_hidrologico.getElementoVetor(idVar, idVarInt, AttVetorVariavelAleatoriaInterna_tendencia_temporal, periodo, double());

					//Atualiza afluencia_natural para a pr�pria usina e para todas as usinas a jusante da idHidreletrica

					IdHidreletrica idhidreletrica_jusante = idHidreletrica;

					while (idhidreletrica_jusante != IdHidreletrica_Nenhum) {

						const int posto_jusante = a_dados.getAtributo(idhidreletrica_jusante, AttComumHidreletrica_codigo_posto, int());

						if (isnan(valor_afluencia_passadas_GEVAZP.at(posto_jusante - 1).at(periodo)))
							valor_afluencia_passadas_GEVAZP.at(posto_jusante - 1).at(periodo) = afluencia_incremental;
						else
							valor_afluencia_passadas_GEVAZP.at(posto_jusante - 1).at(periodo) += afluencia_incremental;

						idhidreletrica_jusante = a_dados.getAtributo(idhidreletrica_jusante, AttComumHidreletrica_jusante, IdHidreletrica());

					}//while (idhidreletrica_jusante != IdHidreletrica_Nenhum) {

				}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				valor_afluencia_passadas_GEVAZP.at(172 - 1).at(periodo) = valor_afluencia_passadas_GEVAZP.at(169 - 1).at(periodo);
				valor_afluencia_passadas_GEVAZP.at(173 - 1).at(periodo) = valor_afluencia_passadas_GEVAZP.at(169 - 1).at(periodo);
				valor_afluencia_passadas_GEVAZP.at(176 - 1).at(periodo) = valor_afluencia_passadas_GEVAZP.at(169 - 1).at(periodo);
				valor_afluencia_passadas_GEVAZP.at(178 - 1).at(periodo) = valor_afluencia_passadas_GEVAZP.at(169 - 1).at(periodo);

			}//for (Periodo periodo = periodo_inicial_historico; periodo <= periodo_final_historico; valor_afluencia_passadas.at(0).incrementarIterador(periodo)) {

		}
		*/
	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::define_variavel_aleatoria_interna_CP(Dados& a_dados): \n" + std::string(erro.what())); }

}//void LeituraCEPEL::define_variavel_aleatoria_interna_CP(Dados& a_dados, const IdCenario a_cenario_inicial, const IdCenario a_cenario_final)

/*
void LeituraCEPEL::inicializarPenalidades_DC(Dados& a_dados)
{

	try {

		//Horizonte de estudo
		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			const IdSubmercado idSubmercado = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_submercado, IdSubmercado());
			const IdPatamarCarga maiorIdPatamarCarga = a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, horizonte_estudo.getIteradorInicial(), IdPatamarCarga());

			const double penalidade = a_dados.getElementoMatriz(idSubmercado, IdPatamarDeficit_1, AttMatrizPatamarDeficit_custo, horizonte_estudo.getIteradorInicial(), maiorIdPatamarCarga, double());

			if(a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_penalidade_desvio_agua, double()) == 0)//Atributo que pode ser informado no DECK DC
				a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_penalidade_desvio_agua, penalidade);

			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_penalidade_turbinamento_minimo, penalidade);
			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_penalidade_vazao_defluente_minima, penalidade);
			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_penalidade_vazao_defluente_maxima, penalidade);
			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_penalidade_volume_minimo, penalidade);
			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_penalidade_potencia_minima, penalidade);

		}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

	}//try {
	catch (const std::exception & erro) { throw std::invalid_argument("LeituraCEPEL::inicializarPenalidades_DC(): \n" + std::string(erro.what())); }

}//void LeituraCEPEL::inicializarPenalidades_DC()
*/

void LeituraCEPEL::modifica_lista_jusante_hidreletrica_com_casos_validados_CP(Dados& a_dados) {

	try {

		IdHidreletrica idHidreletrica;
		IdHidreletrica idHidreletrica_jusante;

		//Conecta Irape->Itapebi

		idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 148); //codigo_ONS = 148 -> IRAPE
		idHidreletrica_jusante = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 154); //codigo_ONS = 154 -> ITAPEBI

		if (!hidreletricasPreConfig_instanciadas)
			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_jusante, idHidreletrica_jusante);
		else if (hidreletricasPreConfig_instanciadas)
			lista_jusante_hidreletrica.setElemento(idHidreletrica, idHidreletrica_jusante);

		//Conecta Maua->Capivara

		idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 57); //codigo_ONS = 57 -> MAUA
		idHidreletrica_jusante = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 61); //codigo_ONS = 61 -> CAPIVARA

		if (!hidreletricasPreConfig_instanciadas)
			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_jusante, idHidreletrica_jusante);
		else if (hidreletricasPreConfig_instanciadas)
			lista_jusante_hidreletrica.setElemento(idHidreletrica, idHidreletrica_jusante);

		//Conecta Estreito Toc->Tucurui

		idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 267); //codigo_ONS = 267 -> ESTREITO TOC
		idHidreletrica_jusante = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 275); //codigo_ONS = 275 -> TUCURUI

		if (!hidreletricasPreConfig_instanciadas)
			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_jusante, idHidreletrica_jusante);
		else if (hidreletricasPreConfig_instanciadas)
			lista_jusante_hidreletrica.setElemento(idHidreletrica, idHidreletrica_jusante);

		//Conecta B.Coqueiros->Foz R.Claro

		idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 312); //codigo_ONS = 312 -> B. COQUEIROS
		idHidreletrica_jusante = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 315); //codigo_ONS = 315 -> FOZ R. CLARO

		if (!hidreletricasPreConfig_instanciadas)
			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_jusante, idHidreletrica_jusante);
		else if (hidreletricasPreConfig_instanciadas)
			lista_jusante_hidreletrica.setElemento(idHidreletrica, idHidreletrica_jusante);

		//Conecta Espora->I.Solteira

		idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 290); //codigo_ONS = 290 -> ESPORA 
		idHidreletrica_jusante = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 34); //codigo_ONS = 34 -> I. SOLTEIRA 

		if (!hidreletricasPreConfig_instanciadas)
			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_jusante, idHidreletrica_jusante);
		else if (hidreletricasPreConfig_instanciadas)
			lista_jusante_hidreletrica.setElemento(idHidreletrica, idHidreletrica_jusante);

		//Conecta Sta Cecilia->Simplicio

		idHidreletrica = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 125); //codigo_ONS = 125 -> STA CECILIA 
		idHidreletrica_jusante = getIdFromCodigoONS(lista_codigo_ONS_hidreletrica, 129); //codigo_ONS = 129 -> SIMPLICIO 

		if (!hidreletricasPreConfig_instanciadas)
			a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_jusante, idHidreletrica_jusante);
		else if (hidreletricasPreConfig_instanciadas)
			lista_jusante_hidreletrica.setElemento(idHidreletrica, idHidreletrica_jusante);

	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::modifica_lista_jusante_hidreletrica_com_casos_validados_CP: \n" + std::string(erro.what())); }

} // void LeituraCEPEL::modifica_lista_jusante_hidreletrica_com_casos_validados_CP(Dados& a_dados) {

void LeituraCEPEL::inicializa_vazao_defluente_CP(Dados& a_dados) {

	try {

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		//Inicializa matriz com a vazao_defluente_minima
		for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			if (a_dados.getSizeVetor(idHidreletrica, AttVetorHidreletrica_vazao_defluente_minima) == 0)
				a_dados.vetorHidreletrica.at(idHidreletrica).setVetor(AttVetorHidreletrica_vazao_defluente_minima, SmartEnupla<Periodo, double>(horizonte_estudo, a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_vazao_defluente_minima, double())));

		}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

		//Se a vazao_defluente_minima_historica for maior, atualiza matriz

		if (int(porcentagem_vazao_minima_historica_REE.size()) > 0) {

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				const int codigo_REE = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_codigo_REE, int());

				set_zero_vazao_defluente_minima_historica_usina_fio_sem_reservatorio_a_montante(a_dados, idHidreletrica);

				const double vazao_defluente_minima_historica = a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_vazao_defluente_minima_historica, double());

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					if (a_dados.vetorHidreletrica.at(idHidreletrica).getElementoVetor(AttVetorHidreletrica_vazao_defluente_minima, periodo, double()) < vazao_defluente_minima_historica * porcentagem_vazao_minima_historica_REE.at(codigo_REE).getElemento(periodo))
						a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_vazao_defluente_minima, periodo, vazao_defluente_minima_historica * porcentagem_vazao_minima_historica_REE.at(codigo_REE).getElemento(periodo));

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			/*
			for (int codigo_ONS_REE = 1; codigo_ONS_REE <= maior_ONS_REE; codigo_ONS_REE++) {

				const std::vector<IdHidreletrica> idHidreletricas_REE = getIdsFromCodigoONS(lista_codigo_ONS_REE, codigo_ONS_REE);
				
				const int numero_usinas_no_REE = int(idHidreletricas_REE.size());

				for (int usina_REE = 0; usina_REE < numero_usinas_no_REE; usina_REE++) {

					const IdHidreletrica idHidreletrica = idHidreletricas_REE.at(usina_REE);

					set_zero_vazao_defluente_minima_historica_usina_fio_sem_reservatorio_a_montante(a_dados, idHidreletrica);

					const double vazao_defluente_minima_historica = a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_vazao_defluente_minima_historica, double());

					for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							if (a_dados.vetorHidreletrica.at(idHidreletrica).getElementoVetor(AttVetorHidreletrica_vazao_defluente_minima, periodo, double()) < vazao_defluente_minima_historica * porcentagem_vazao_minima_historica_REE.at(codigo_ONS_REE).getElemento(periodo))
								a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_vazao_defluente_minima, periodo, vazao_defluente_minima_historica * porcentagem_vazao_minima_historica_REE.at(codigo_ONS_REE).getElemento(periodo));

					}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				}//for (int usina_REE = 0; usina_REE < numero_usinas_no_REE; usina_REE++)

			}//for (int codigo_ONS_REE = 1; codigo_ONS_REE <= maior_ONS_REE; codigo_ONS_REE++) {
			*/

		}//if (int(porcentagem_vazao_minima_historica_REE.size()) > 0) {

	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::inicializa_vazao_defluente_CP_CP: \n" + std::string(erro.what())); }

} // void LeituraCEPEL::inicializa_vazao_defluente_CP(Dados& a_dados) {

void LeituraCEPEL::valida_bacia_sao_francisco(Dados& a_dados){

	try{

		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			if (a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_codigo_posto, int()) == 168) {

				IdHidreletrica idHidreletrica_jusante = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_jusante, IdHidreletrica());

				while (idHidreletrica_jusante != IdHidreletrica_Nenhum) {

					a_dados.vetorHidreletrica.at(idHidreletrica_jusante).setAtributo(AttComumHidreletrica_codigo_posto, 300);
					idHidreletrica_jusante = a_dados.vetorHidreletrica.at(idHidreletrica_jusante).getAtributo(AttComumHidreletrica_jusante, IdHidreletrica());

				}//while (idHidreletrica_jusante != IdHidreletrica_Nenhum) {

				/*
				for (IdHidreletrica idHidreletrica_jus = idHidreletricaIni; idHidreletrica_jus < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica_jus)) {

					if (idHidreletrica_jus != IdHidreletrica_176_COMPPAFMOX && idHidreletrica_jus != IdHidreletrica_168_ENA_SOBRADINHO && idHidreletrica_jus != IdHidreletrica_172_ENA_ITAPARICA && idHidreletrica_jus != IdHidreletrica_178_ENA_XINGO) {

						const int posto = a_dados.getAtributo(idHidreletrica_jus, AttComumHidreletrica_codigo_posto, int());

						if ((posto == 172) || (posto == 173) || (posto == 175) || (posto == 178))
							a_dados.vetorHidreletrica.at(idHidreletrica_jus).setAtributo(AttComumHidreletrica_codigo_posto, 300);

					}//if

				} // for (IdHidreletrica idHidreletrica_jus = idHidreletricaIni; idHidreletrica_jus < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica_jus)) {
				*/
			} // if (a_dados.getAtributo(idHidreletrica, AttComumHidreletrica_codigo_posto, int()) == 168) {

		} // for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {


	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::valida_bacia_sao_francisco: \n" + std::string(erro.what())); }

} // void LeituraCEPEL::valida_bacia_sao_francisco(Dados& a_dados){

void LeituraCEPEL::imprime_na_tela_avisos_de_possiveis_inviabilidades_fph(Dados& a_dados) {

	try {

		if (idEstagioMaximo > IdEstagio_2) {

			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//1. Identifica as usinas sem montante nem jusante/jusante_desvio
			////////////////////////////////////////////////////////////////////////////////////////////////////////////

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			std::vector<IdHidreletrica> vetor_hidreletrica_aislada; //usinas sem montante nem jusante

			for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {
				if (a_dados.getSizeVetor(idHidreletrica, AttVetorHidreletrica_montante) == 0 && a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_jusante, IdHidreletrica()) == IdHidreletrica_Nenhum && a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_jusante_desvio, IdHidreletrica()) == IdHidreletrica_Nenhum && a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) != TipoDetalhamentoProducaoHidreletrica_sem_producao)
					vetor_hidreletrica_aislada.push_back(idHidreletrica);
			}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//2. Calcula a afluencia_minima para tornar a FPH viável na pior condiçao de volume (v = 0)
			//Nota: Este procedimento é realizado somente para o último periodo
			////////////////////////////////////////////////////////////////////////////////////////////////////////////

			const Periodo periodo_final = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio()).getIteradorFinal();
			//const Periodo periodo_final_DECK = horizonte_estudo_DECK.getIteradorFinal();
			const Periodo periodo_final_DECK = horizonte_processo_estocastico.getIteradorFinal();

			const int size_vetor_hidreletrica_aislada = int(vetor_hidreletrica_aislada.size());

			for (int pos = 0; pos < size_vetor_hidreletrica_aislada; pos++) {

				const IdHidreletrica idHidreletrica = vetor_hidreletrica_aislada.at(pos);

				const int numero_planos = a_dados.getSize2Matriz(idHidreletrica, IdFuncaoProducaoHidreletrica_1, AttMatrizFuncaoProducaoHidreletrica_RHS, periodo_final);

				double afluencia_minima_para_viabilidade = 0;

				for (int i = 1; i <= numero_planos; i++) {

					const double rhs = a_dados.getElementoMatriz(idHidreletrica, IdFuncaoProducaoHidreletrica_1, AttMatrizFuncaoProducaoHidreletrica_RHS, periodo_final, i, double());
					const double coef_qh = a_dados.getElementoMatriz(idHidreletrica, IdFuncaoProducaoHidreletrica_1, AttMatrizFuncaoProducaoHidreletrica_QH, periodo_final, i, double());

					if (afluencia_minima_para_viabilidade < rhs * std::pow(coef_qh, -1))
						afluencia_minima_para_viabilidade = rhs * std::pow(coef_qh, -1);

				}//for (int i = 1; i <= numero_planos; i++) {

				if (a_dados.getAtributo(AttComumDados_representar_producao_hidreletrica_com_turbinamento_disponivel, bool()))
					afluencia_minima_para_viabilidade /= a_dados.getElementoVetor(idHidreletrica, AttVetorHidreletrica_disponibilidade, periodo_final, double());

				//Compara a afluencia_minima_para_viabilidade com as afluencias da árvore de cenários


				const IdCenario cenario_inicial = a_dados.arranjoResolucao.getAtributo(a_dados.arranjoResolucao.getAtributo(AttComumArranjoResolucao_idProcesso, IdProcesso()), AttComumProcesso_menor_cenario, IdCenario());
				const IdCenario cenario_final = a_dados.arranjoResolucao.getAtributo(a_dados.arranjoResolucao.getAtributo(AttComumArranjoResolucao_idProcesso, IdProcesso()), AttComumProcesso_maior_cenario, IdCenario());

				const IdProcesso idProcesso = a_dados.arranjoResolucao.getAtributo(AttComumArranjoResolucao_idProcesso, IdProcesso());

				for (IdCenario idCenario = cenario_inicial; idCenario <= cenario_final; idCenario++) {

					IdVariavelAleatoria idVar;
					IdVariavelAleatoriaInterna idVarInterna;

					a_dados.processoEstocastico_hidrologico.getIdVariavelAleatoriaIdVariavelAleatoriaInternaFromIdFisico(idVar, idVarInterna, idHidreletrica);

					const double afluencia = a_dados.processoEstocastico_hidrologico.getElementoMatriz(idVar, idVarInterna, AttMatrizVariavelAleatoriaInterna_cenarios_realizacao_espaco_amostral, periodo_final_DECK, idCenario, double());

					if (afluencia_minima_para_viabilidade > afluencia) {
						std::cout << getFullString(idProcesso) << " -Possivel inviabilidade na FPH da usina_ " << a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_nome, std::string()) << " " << getFullString(idHidreletrica) << " -Valor de afluencia no periodo_mensal inferior a " << afluencia_minima_para_viabilidade << std::endl;
						break;
					}//if (afluencia_minima_para_viabilidade > a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(IdVariavelAleatoria(idHidreletrica)).getElementoMatriz(AttMatrizVariavelAleatoria_residuo_espaco_amostral, periodo, IdRealizacao(idCenario), double())) {

				}//for (IdCenario idCenario = cenario_inicial; idCenario <= cenario_final; idCenario++) {

			}//for (int pos = 0; pos < size_vetor_hidreletrica_aislada; pos++) {

		}//if (idEstagioMaximo > IdEstagio_2) {

	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::imprime_na_tela_avisos_de_possiveis_inviabilidades_fph: \n" + std::string(erro.what())); }

} // void LeituraCEPEL::imprime_na_tela_avisos_de_possiveis_inviabilidades_fph(Dados& a_dados) {

void LeituraCEPEL::atualiza_volume_util_maximo_com_percentual_volume_util_maximo(Dados& a_dados) {

	try {

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(AttVetorReservatorio_volume_util_maximo) > 0) {

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					const double volume_minimo = a_dados.getAtributo(idHidreletrica, IdReservatorio_1, AttComumReservatorio_volume_minimo, double());
					const double volume_maximo = a_dados.getAtributo(idHidreletrica, IdReservatorio_1, AttComumReservatorio_volume_maximo, double());

					if (volume_minimo > volume_maximo)
						throw std::invalid_argument("Volume Minimo = " + getString(volume_minimo) + " maior que Volume Maximo = " + getString(volume_maximo) + " em " + getFullString(idHidreletrica) + " em " + getString(periodo));

					double percentual_volume_util_maximo = 1.0; //É possível que no deck nao seja informado valores para o percentual do volume_espera para uma usina específica, nesse caso, considera-se 1.0 como default

					if(a_dados.getSizeVetor(idHidreletrica, IdReservatorio_1, AttVetorReservatorio_percentual_volume_util_maximo) > 0)
						percentual_volume_util_maximo = a_dados.getElementoVetor(idHidreletrica, IdReservatorio_1, AttVetorReservatorio_percentual_volume_util_maximo, periodo, double());

					double volume_util_maximo = (volume_maximo - volume_minimo) * percentual_volume_util_maximo;

					if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_util_maximo, periodo, double()) > volume_util_maximo)
						a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(AttVetorReservatorio_volume_util_maximo, periodo, volume_util_maximo);

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			}//if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(AttVetorReservatorio_volume_util_maximo) > 0) {

		}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualiza_volume_util_maximo_com_percentual_volume_util_maximo: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualiza_restricao_operativa_UHE_tipoRestricaoHidraulica_energia_armazenada(Dados& a_dados, std::string a_diretorio, const int a_maior_ONS_REE) {

	try {

		const double conversao_MWporVazao_em_MWhporVolume = 1e6 / 3600.0;

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());

		const IdRestricaoOperativaUHE maiorIdRestricaoOperativaUHE = a_dados.getMaiorId(IdRestricaoOperativaUHE());

		for (IdRestricaoOperativaUHE idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1; idRestricaoOperativaUHE <= maiorIdRestricaoOperativaUHE; idRestricaoOperativaUHE++) {

			if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoHidraulica, TipoRestricaoHidraulica()) == TipoRestricaoHidraulica_energia_armazenada) {

				////////////////////////////////////////////
				//Calcula as produtibilidade_acumulada_EAR
				////////////////////////////////////////////
			
				if (a_dados.vetorHidreletrica.at(a_dados.getMenorId(IdHidreletrica())).vetorReservatorioEquivalente.getMaiorId() == IdReservatorioEquivalente_Nenhum) { //Pode ter sido instanciado para o cálculo das produtibilidade_acumulada_EAR em restrições de energia armazenada RHV
					atualizar_vetores_premissas_calculo_produtibilidades(a_dados, SmartEnupla<Periodo, bool>(horizonte_estudo, true));
					calcular_produtibilidade_EAR_acumulada_x_usina_x_REE_x_periodo(a_dados, SmartEnupla<Periodo, bool>(horizonte_estudo, true));
				}
				else if (a_dados.vetorHidreletrica.at(a_dados.getMenorId(IdHidreletrica())).vetorReservatorioEquivalente.at(a_dados.getMenorId(a_dados.getMenorId(IdHidreletrica()), IdReservatorioEquivalente())).getSizeVetor(AttVetorReservatorioEquivalente_produtibilidade_acumulada_EAR) == 0) {
					atualizar_vetores_premissas_calculo_produtibilidades(a_dados, SmartEnupla<Periodo, bool>(horizonte_estudo, true));
					calcular_produtibilidade_EAR_acumulada_x_usina_x_REE_x_periodo(a_dados, SmartEnupla<Periodo, bool>(horizonte_estudo, true));
				}
					
				SmartEnupla<Periodo, double> energia_maxima_REE (horizonte_estudo, 0.0); //Calcula com base no volume_util_maximo * produtibilidade_acumulada_EAR das hidrelétricas que aportam no REE

				///////////////////////////////////

				const int codigo_restricao_operativa_RHE_energia = lista_codigo_ONS_restricao_operativa_UHE_energia_armazenada.getElemento(idRestricaoOperativaUHE);

				int aux_pos_codigo_restricao_energia_armazenada = -1;

				for (int pos_codigo_restricao_energia_armazenada = 1; pos_codigo_restricao_energia_armazenada <= int(codigo_restricao_energia_armazenada.size()); pos_codigo_restricao_energia_armazenada++) {

					if (codigo_restricao_energia_armazenada.getElemento(pos_codigo_restricao_energia_armazenada) == codigo_restricao_operativa_RHE_energia) {
						aux_pos_codigo_restricao_energia_armazenada = pos_codigo_restricao_energia_armazenada;
						break;

					}//if (codigo_restricao_energia_armazenada.getElemento(pos_codigo_restricao_energia_armazenada) == codigo_restricao_operativa_RHE_energia) {

				}//for (int pos_codigo_restricao_energia_armazenada = 1; pos_codigo_restricao_energia_armazenada <= int(codigo_restricao_energia_armazenada.size()); pos_codigo_restricao_energia_armazenada++) {


				const IdReservatorioEquivalente idReservatorioEquivalente = idReservatorioEquivalente_restricao_energia_armazenada.getElemento(aux_pos_codigo_restricao_energia_armazenada);

				///////////////////////////////////

				const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
				const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

				for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

					if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorioEquivalente.isInstanciado(idReservatorioEquivalente)) {

						if (a_dados.getSizeVetor(idHidreletrica, idReservatorioEquivalente, AttVetorReservatorioEquivalente_produtibilidade_acumulada_EAR) > 0) {

							IdElementoSistema idElementoSistema = a_dados.getMaiorId(idRestricaoOperativaUHE, IdElementoSistema());

							if (idElementoSistema == IdElementoSistema_Nenhum) { idElementoSistema = IdElementoSistema_1; }
							else { idElementoSistema++; }

							ElementoSistema elementoSistema;
							elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);
							elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema_hidreletrica);
							elementoSistema.setAtributo(AttComumElementoSistema_hidreletrica, idHidreletrica);
							elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa_volume_final);

							///////////////////////////////////
							//Cálculo da energia_maxima_REE
							///////////////////////////////////

							SmartEnupla<Periodo, double> fator_participacao(horizonte_estudo, 0.0);

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								const double produtibilidade_acumulada_EAR = a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorioEquivalente.at(idReservatorioEquivalente).getElementoVetor(AttVetorReservatorioEquivalente_produtibilidade_acumulada_EAR, periodo, double());
								fator_participacao.at(periodo) = produtibilidade_acumulada_EAR * conversao_MWporVazao_em_MWhporVolume;

								const double volume_util_minimo = a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_util_minimo, periodo, double());
								const double volume_util_maximo = a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_util_maximo, periodo, double());

								double energia_maxima_periodo_anterior = energia_maxima_REE.getElemento(periodo);
								double energia_maxima_periodo_nova = energia_maxima_periodo_anterior + (volume_util_maximo - volume_util_minimo) * produtibilidade_acumulada_EAR * conversao_MWporVazao_em_MWhporVolume;

								energia_maxima_REE.setElemento(periodo, energia_maxima_periodo_nova);

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							////////////////////////
							SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_fator_participacao(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
								matriz_fator_participacao.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								int numero_patamares_x_periodo = 0;

								for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

									if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
										numero_patamares_x_periodo++;

										const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);
										matriz_fator_participacao.at(periodo).at(idPatamarCarga) = fator_participacao.at(periodo);

									}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {

								}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_fator_participacao);

							/////////////////////////

							a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.add(elementoSistema);

						}//if (a_dados.getSizeVetor(idHidreletrica, idReservatorioEquivalente, AttVetorReservatorioEquivalente_produtibilidade_acumulada_EAR) > 0) {

					}//if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorioEquivalente.isInstanciado(idReservatorioEquivalente)) {

				}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

				/////////////////////

				if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getAtributo(AttComumRestricaoOperativaUHE_tipoUnidadeRestricaoHidraulica, TipoUnidadeRestricaoHidraulica()) == TipoUnidadeRestricaoHidraulica_percentual) {

					////////////////////////////
					//Determina os tipos de períodos do hosrizonte_estudo_DECK

					std::vector<TipoPeriodo> tipo_periodos_horizonte_DECK;

					for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

						bool is_tipo_periodo_encontrado = false;

						const TipoPeriodo tipo_periodo = periodo_deck.getTipoPeriodo();

						for (int pos = 0; pos < int(tipo_periodos_horizonte_DECK.size()); pos++) {

							if (tipo_periodo == tipo_periodos_horizonte_DECK.at(pos)) {
								is_tipo_periodo_encontrado = true;
								break;
							}//if (tipo_periodo == tipo_periodos_horizonte_DECK.at(pos)) {

						}//for (int pos = 0; pos < int(tipo_periodos_horizonte_DECK.size()); pos++) {

						/////
						if (!is_tipo_periodo_encontrado)
							tipo_periodos_horizonte_DECK.push_back(tipo_periodo);

					}//for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

					////////////////////////////

					const Periodo periodo_ultimo_sobreposicao = get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados);

					for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						const IdPatamarCarga maiorIdPatamarCarga = a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga());

						for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

							const double limite_inferior_percentual = a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getElementoMatriz(AttMatrizRestricaoOperativaUHE_lim_inf, periodo, idPatamarCarga, double());
							
							if (limite_inferior_percentual != getdoubleFromChar("min")) {

								///////////////////////////////////////////////////////
								//Verifica se é um período final do período semanal
								///////////////////////////////////////////////////////

								bool is_periodo_um_periodo_final_deck = false;

								if (periodo <= periodo_ultimo_sobreposicao) {

									if (periodo == horizonte_estudo.getIteradorFinal())
										is_periodo_um_periodo_final_deck = true;
									else {

										Periodo periodo_teste = Periodo(periodo.getTipoPeriodo(), periodo + 1);

										if(periodo_teste > periodo_ultimo_sobreposicao)
											is_periodo_um_periodo_final_deck = true;
										else {

											for (int pos = 0; pos < int(tipo_periodos_horizonte_DECK.size()); pos++) {

												const TipoPeriodo tipo_periodo = tipo_periodos_horizonte_DECK.at(pos);
												const Periodo periodo_seguinte = Periodo(tipo_periodo, periodo + 1);

												for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

													if (periodo_seguinte == periodo_deck) {
														is_periodo_um_periodo_final_deck = true;
														break;
													}//if (periodo_seguinte == periodo_deck) {

												}//for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

											}//for (int pos = 0; pos < int(tipo_periodos_horizonte_DECK.size()); pos++) {
										}//else {
									}//else {

								}//if (periodo <= periodo_ultimo_sobreposicao) {
								else if (periodo > periodo_ultimo_sobreposicao) {

									//Verifica que seja o último período do horizonte de otimização

									for (IdEstagio idEstagio = horizonte_otimizacao.getIteradorInicial(); idEstagio <= horizonte_otimizacao.getIteradorFinal(); idEstagio++) {

										const Periodo periodo_otimizacao = horizonte_otimizacao.at(idEstagio);

										const double sobreposicao = periodo.sobreposicao(periodo_otimizacao);

										if (sobreposicao > 0.0) {

											Periodo periodo_teste = Periodo(periodo_otimizacao.getTipoPeriodo(), periodo + 1);
											Periodo periodo_otimizacao_teste = Periodo(periodo_otimizacao.getTipoPeriodo(), periodo_otimizacao + 1);

											if(periodo_teste == periodo_otimizacao_teste) //Garante que o período onde a restrição RHE é ativada é no último período pertencente ao período de otimização
												is_periodo_um_periodo_final_deck = true;

											break;

										}//if (sobreposicao > 0.0) {

									}//for (IdEstagio idEstagio = horizonte_otimizacao.getIteradorInicial(); idEstagio <= horizonte_otimizacao.getIteradorFinal(); idEstagio++) {

								}//else if (periodo > periodo_ultimo_sobreposicao) {
									

								///////////////////////////////////////////////////////
							
								if (is_periodo_um_periodo_final_deck) {

									const double limite_inferior_MW = limite_inferior_percentual * energia_maxima_REE.getElemento(periodo) / 100;

									a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_inf, periodo, idPatamarCarga, limite_inferior_MW);

								}//if (is_periodo_um_periodo_final_deck) {
								else if(!is_periodo_um_periodo_final_deck)
									a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_inf, periodo, idPatamarCarga, getdoubleFromChar("min"));//Na leitura é instanciado com o valor percentual do registro, e.g., 20% -> se coloca -inf caso não seja um período final de estágio DC 

							}//if (limite_inferior_percentual != getdoubleFromChar("min")) {

						}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
							
					}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setAtributo(AttComumRestricaoOperativaUHE_tipoUnidadeRestricaoHidraulica, TipoUnidadeRestricaoHidraulica_MW);

				}//if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getAtributo(AttComumRestricaoOperativaUHE_tipoUnidadeRestricaoHidraulica, TipoUnidadeRestricaoHidraulica()) == TipoUnidadeRestricaoHidraulica_percentual) {

			}//if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoHidraulica, TipoRestricaoHidraulica()) == TipoRestricaoHidraulica_energia_armazenada) {

		}//for (IdRestricaoOperativaUHE idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1; idRestricaoOperativaUHE <= maiorIdRestricaoOperativaUHE; idRestricaoOperativaUHE++) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualiza_restricao_operativa_UHE_tipoRestricaoHidraulica_energia_armazenada: \n" + std::string(erro.what())); }

}

Periodo LeituraCEPEL::get_periodo_ultimo_sobreposicao_com_horizonte_DC(Dados& a_dados) {

	try {

		/////////////////////////////////////////////////////////////////////////////
		// Identifica o último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		/////////////////////////////////////////////////////////////////////////////

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

		const Periodo periodo_inicial = horizonte_estudo.getIteradorInicial();
		const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

		const Periodo periodo_final_DC = horizonte_otimizacao_DC.at(horizonte_otimizacao_DC.getIteradorFinal());

		Periodo periodo_ultimo_sobreposicao = periodo_inicial;

		bool is_sobreposicao_encontrada = false;

		for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

			const double sobreposicao = periodo.sobreposicao(periodo_final_DC);

			if (sobreposicao > 0.0) {
				is_sobreposicao_encontrada = true;
				periodo_ultimo_sobreposicao = periodo;
			}//if (sobreposicao > 0.0) {

			if (sobreposicao == 0.0 && is_sobreposicao_encontrada)
				break;

		}//for (Periodo periodo = periodo_inicial; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

		return periodo_ultimo_sobreposicao;

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::get_periodo_ultimo_sobreposicao_com_horizonte_DC: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido(Dados& a_dados) {

	try {

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Nota: Método para atualizar os períodos do horizonte_estudo > ao último período do horizonte_DC (condição da extensão do horizonte_estudo)
		// Verifica se o vetor/matriz está instanciado e caso positivo, atualiza todos os periodos do horizonte de estudo > ao último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		atualizar_valores_periodos_horizonte_expandido_hidreletrica(a_dados);
		atualizar_valores_periodos_horizonte_expandido_termeletrica(a_dados);
		atualizar_valores_periodos_horizonte_expandido_submercado(a_dados);
		atualizar_valores_periodos_horizonte_expandido_intercambio(a_dados);
		atualizar_valores_periodos_horizonte_expandido_usina_elevatoria(a_dados);
		atualizar_valores_periodos_horizonte_expandido_restricao_eletrica(a_dados);
		atualizar_valores_periodos_horizonte_expandido_restricao_operativa_UHE(a_dados);

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_hidreletrica(Dados& a_dados) {

	try {

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Nota: Método para atualizar os períodos do horizonte_estudo > ao último período do horizonte_DC (condição da extensão do horizonte_estudo)
		// Verifica se o vetor/matriz está instanciado e caso positivo, atualiza todos os periodos do horizonte de estudo > ao último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		////////////////////////////
		//AttVetorHidreletrica
		////////////////////////////

		SmartEnupla<int, AttVetorHidreletrica> attVetorHidreletrica;

		if (true) {
			int pos_elemento = 1;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_cota_montante_usina_jusante);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_vazao_turbinada_minima);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_vazao_turbinada_maxima);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_canal_fuga_medio);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_vazao_defluente_minima);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_vazao_defluente_maxima);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_vazao_desviada_minima);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_vazao_desviada_maxima);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_vazao_retirada);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_indisponibilidade_forcada);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_indisponibilidade_programada);
			pos_elemento++;
			attVetorHidreletrica.addElemento(pos_elemento, AttVetorHidreletrica_disponibilidade);

		}
		////////////////////////////
		//AttMatrizHidreletrica
		////////////////////////////

		SmartEnupla<int, AttMatrizHidreletrica> attMatrizHidreletrica;

		if (true) {
			int pos_elemento = 1;
			attMatrizHidreletrica.addElemento(pos_elemento, AttMatrizHidreletrica_potencia_minima);
			pos_elemento++;
			attMatrizHidreletrica.addElemento(pos_elemento, AttMatrizHidreletrica_potencia_maxima);
			pos_elemento++;
			attMatrizHidreletrica.addElemento(pos_elemento, AttMatrizHidreletrica_potencia_disponivel_minima);
			pos_elemento++;
			attMatrizHidreletrica.addElemento(pos_elemento, AttMatrizHidreletrica_potencia_disponivel_maxima);
			pos_elemento++;
			attMatrizHidreletrica.addElemento(pos_elemento, AttMatrizHidreletrica_vazao_turbinada_disponivel_minima);
			pos_elemento++;
			attMatrizHidreletrica.addElemento(pos_elemento, AttMatrizHidreletrica_vazao_turbinada_disponivel_maxima);
			pos_elemento++;
			attMatrizHidreletrica.addElemento(pos_elemento, AttMatrizHidreletrica_vazao_defluente_minima);
			pos_elemento++;
			attMatrizHidreletrica.addElemento(pos_elemento, AttMatrizHidreletrica_vazao_defluente_maxima);
			pos_elemento++;
			attMatrizHidreletrica.addElemento(pos_elemento, AttMatrizHidreletrica_vazao_desviada_minima);
			pos_elemento++;
			attMatrizHidreletrica.addElemento(pos_elemento, AttMatrizHidreletrica_vazao_desviada_maxima);
		}
		
		////////////////////////////
		//AttVetorReservatorio
		////////////////////////////

		SmartEnupla<int, AttVetorReservatorio> attVetorReservatorio;

		if (true) {
			int pos_elemento = 1;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_coef_linear_evaporacao_0);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_coef_linear_evaporacao_1);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_volume_morto_completo);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_enchendo_volume_morto);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_cota_referencia);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_volume_minimo);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_volume_maximo);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_meta_enchimento_volume_morto);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_taxa_enchimento_volume_morto);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_poli_cota_volume_0);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_poli_cota_volume_1);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_poli_cota_volume_2);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_poli_cota_volume_3);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_poli_cota_volume_4);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_poli_cota_area_0);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_poli_cota_area_1);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_poli_cota_area_2);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_poli_cota_area_3);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_poli_cota_area_4);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_percentual_volume_util_maximo);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_percentual_volume_util_minimo);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_volume_util_minimo);
			pos_elemento++;
			attVetorReservatorio.addElemento(pos_elemento, AttVetorReservatorio_volume_util_maximo);
		}
		
		////////////////////////////
		//AttMatrizFuncaoProducaoHidreletrica
		////////////////////////////

		SmartEnupla<int, AttMatrizFuncaoProducaoHidreletrica> attMatrizFuncaoProducaoHidreletrica;

		//if (true) {
		if (false) {
			int pos_elemento = 1;
			attMatrizFuncaoProducaoHidreletrica.addElemento(pos_elemento, AttMatrizFuncaoProducaoHidreletrica_RHS);
			pos_elemento++;
			attMatrizFuncaoProducaoHidreletrica.addElemento(pos_elemento, AttMatrizFuncaoProducaoHidreletrica_FC);
			pos_elemento++;
			attMatrizFuncaoProducaoHidreletrica.addElemento(pos_elemento, AttMatrizFuncaoProducaoHidreletrica_VH);
			pos_elemento++;
			attMatrizFuncaoProducaoHidreletrica.addElemento(pos_elemento, AttMatrizFuncaoProducaoHidreletrica_QH);
			pos_elemento++;
			attMatrizFuncaoProducaoHidreletrica.addElemento(pos_elemento, AttMatrizFuncaoProducaoHidreletrica_SH);

		}


		/////////////////////////////////////////////////////////////////////////////
		//1. Identifica o último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		/////////////////////////////////////////////////////////////////////////////

		const Periodo periodo_ultimo_sobreposicao = get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados);

		/////////////////////////////////////////////////////////////////////////////
		//2. Identifica o último periodo do horizonte de estudo
		/////////////////////////////////////////////////////////////////////////////

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

		for (Periodo periodo = periodo_ultimo_sobreposicao; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

			if (periodo > periodo_ultimo_sobreposicao) {//Periodos extensão do horizonte

				for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

					////////////////////////////
					//AttVetorHidreletrica
					////////////////////////////

					for (int pos = 1; pos <= int(attVetorHidreletrica.size()); pos++) {

						//Precisa instanciar este vetor para depois ser atualizado com pre-config do MP
						if ((a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(attVetorHidreletrica.at(pos)) == 0) && (attVetorHidreletrica.at(pos) == AttVetorHidreletrica_canal_fuga_medio)) {
							a_dados.vetorHidreletrica.at(idHidreletrica).setVetor(AttVetorHidreletrica_canal_fuga_medio, SmartEnupla<Periodo, double>(horizonte_estudo, a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_canal_fuga_medio, double())));
						}

						if (a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(attVetorHidreletrica.at(pos)) > 0) {
							const double valor = a_dados.vetorHidreletrica.at(idHidreletrica).getElementoVetor(attVetorHidreletrica.at(pos), periodo_ultimo_sobreposicao, double());
							a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(attVetorHidreletrica.at(pos), periodo, valor);
						}//if (a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(attVetorHidreletrica.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attVetorHidreletrica.size()); pos++) {

					////////////////////////////
					//AttMatrizHidreletrica
					////////////////////////////

					for (int pos = 1; pos <= int(attMatrizHidreletrica.size()); pos++) {

						if (a_dados.vetorHidreletrica.at(idHidreletrica).getSizeMatriz(attMatrizHidreletrica.at(pos)) > 0) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
								const double valor = a_dados.vetorHidreletrica.at(idHidreletrica).getElementoMatriz(attMatrizHidreletrica.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
								a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(attMatrizHidreletrica.at(pos), periodo, idPatamarCarga, valor);
							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//if (a_dados.vetorHidreletrica.at(idHidreletrica).getSizeMatriz(attMatrizHidreletrica.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attMatrizHidreletrica.size()); pos++) {

					////////////////////////////
					//AttVetorReservatorio
					////////////////////////////

					for (int pos = 1; pos <= int(attVetorReservatorio.size()); pos++) {

						//Precisa instanciar este vetor para depois ser atualizado com pre-config do MP
						if ((a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(attVetorReservatorio.at(pos)) == 0) && (attVetorReservatorio.at(pos) == AttVetorReservatorio_volume_minimo || attVetorReservatorio.at(pos) == AttVetorReservatorio_volume_maximo)) {
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setVetor(AttVetorReservatorio_volume_minimo, SmartEnupla<Periodo, double>(horizonte_estudo, a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getAtributo(AttComumReservatorio_volume_minimo, double())));
							a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setVetor(AttVetorReservatorio_volume_maximo, SmartEnupla<Periodo, double>(horizonte_estudo, a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getAtributo(AttComumReservatorio_volume_maximo, double())));
						}//if ((a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(attVetorReservatorio.at(pos)) == 0) && (attVetorReservatorio.at(pos) == AttVetorReservatorio_volume_minimo || attVetorReservatorio.at(pos) == AttVetorReservatorio_volume_maximo)) {

						if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(attVetorReservatorio.at(pos)) > 0) {
							
							if (attVetorReservatorio.at(pos) == AttVetorReservatorio_volume_morto_completo || attVetorReservatorio.at(pos) == AttVetorReservatorio_enchendo_volume_morto) {
								//Valores int
								const int valor = a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(attVetorReservatorio.at(pos), periodo_ultimo_sobreposicao, int());
								a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(attVetorReservatorio.at(pos), periodo, valor);

							}
							else {
								//Valores double
								const double valor = a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(attVetorReservatorio.at(pos), periodo_ultimo_sobreposicao, double());
								a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(attVetorReservatorio.at(pos), periodo, valor);

							}
						}//if (a_dados.vetorHidreletrica.at(idHidreletrica).getSizeVetor(attVetorReservatorio.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attVetorReservatorio.size()); pos++) {


					////////////////////////////
					//AttMatrizFuncaoProducaoHidreletrica
					////////////////////////////

					for (int pos = 1; pos <= int(attMatrizFuncaoProducaoHidreletrica.size()); pos++) {

						if (a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).getSizeMatriz(attMatrizFuncaoProducaoHidreletrica.at(pos)) > 0) {

							const int plano_inicial = a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).getIterador2Inicial(attMatrizFuncaoProducaoHidreletrica.at(pos), periodo_ultimo_sobreposicao, int());
							const int plano_final   = a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).getIterador2Final(attMatrizFuncaoProducaoHidreletrica.at(pos), periodo_ultimo_sobreposicao, int());

							for (int plano = plano_inicial; plano <= plano_final; plano++) {

								if (a_dados.getSize2Matriz(idHidreletrica, IdFuncaoProducaoHidreletrica_1, attMatrizFuncaoProducaoHidreletrica.at(pos), periodo) == plano) {
									const double valor = a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).getElementoMatriz(attMatrizFuncaoProducaoHidreletrica.at(pos), periodo_ultimo_sobreposicao, plano, double());
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).setElemento(attMatrizFuncaoProducaoHidreletrica.at(pos), periodo, plano, valor);
								}
								else {
									const double valor = a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).getElementoMatriz(attMatrizFuncaoProducaoHidreletrica.at(pos), periodo_ultimo_sobreposicao, plano, double());
									a_dados.vetorHidreletrica.at(idHidreletrica).vetorFuncaoProducaoHidreletrica.at(IdFuncaoProducaoHidreletrica_1).addElemento(attMatrizFuncaoProducaoHidreletrica.at(pos), periodo, plano, valor);
								}
							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//if (a_dados.vetorHidreletrica.at(idHidreletrica).getSizeMatriz(attMatrizFuncaoProducaoHidreletrica.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attMatrizFuncaoProducaoHidreletrica.size()); pos++) {


				}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			}//if (periodo > periodo_ultimo_sobreposicao) {

		}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_hidreletrica: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_termeletrica(Dados& a_dados) {

	try {

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Nota: Método para atualizar os períodos do horizonte_estudo > ao último período do horizonte_DC (condição da extensão do horizonte_estudo)
		// Verifica se o vetor/matriz está instanciado e caso positivo, atualiza todos os periodos do horizonte de estudo > ao último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		const IdTermeletrica	idTermeletricaIni = a_dados.getMenorId(IdTermeletrica());
		const IdTermeletrica	idTermeletricaOut = a_dados.getIdOut(IdTermeletrica());

		////////////////////////////
		//AttVetorTermeletrica
		////////////////////////////

		SmartEnupla<int, AttVetorTermeletrica> attVetorTermeletrica;

		if (true) {
			int pos_elemento = 1;
			attVetorTermeletrica.addElemento(pos_elemento, AttVetorTermeletrica_fator_de_capacidade);
			pos_elemento++;
			attVetorTermeletrica.addElemento(pos_elemento, AttVetorTermeletrica_disponibilidade);
			pos_elemento++;
			attVetorTermeletrica.addElemento(pos_elemento, AttVetorTermeletrica_indisponibilidade_forcada);
			pos_elemento++;
			attVetorTermeletrica.addElemento(pos_elemento, AttVetorTermeletrica_indisponibilidade_programada);
		}
		
		////////////////////////////
		//AttMatrizTermeletrica
		////////////////////////////

		SmartEnupla<int, AttMatrizTermeletrica> attMatrizTermeletrica;

		if (true) {
			int pos_elemento = 1;
			attMatrizTermeletrica.addElemento(pos_elemento, AttMatrizTermeletrica_custo_de_operacao);
			pos_elemento++;
			attMatrizTermeletrica.addElemento(pos_elemento, AttMatrizTermeletrica_potencia_util);
			pos_elemento++;
			attMatrizTermeletrica.addElemento(pos_elemento, AttMatrizTermeletrica_potencia_minima);
			pos_elemento++;
			attMatrizTermeletrica.addElemento(pos_elemento, AttMatrizTermeletrica_potencia_maxima);
			pos_elemento++;
			attMatrizTermeletrica.addElemento(pos_elemento, AttMatrizTermeletrica_potencia_disponivel_minima);
			pos_elemento++;
			attMatrizTermeletrica.addElemento(pos_elemento, AttMatrizTermeletrica_potencia_disponivel_maxima);
			pos_elemento++;
			attMatrizTermeletrica.addElemento(pos_elemento, AttMatrizTermeletrica_potencia_disponivel_comandada);

		}


		/////////////////////////////////////////////////////////////////////////////
		//1. Identifica o último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		/////////////////////////////////////////////////////////////////////////////
		const Periodo periodo_ultimo_sobreposicao = get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados);

		/////////////////////////////////////////////////////////////////////////////
		//2. Identifica o último periodo do horizonte de estudo
		/////////////////////////////////////////////////////////////////////////////

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

		for (Periodo periodo = periodo_ultimo_sobreposicao; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

			if (periodo > periodo_ultimo_sobreposicao) {//Periodos extensão do horizonte

				for (IdTermeletrica idTermeletrica = idTermeletricaIni; idTermeletrica < idTermeletricaOut; a_dados.vetorTermeletrica.incr(idTermeletrica)) {

					////////////////////////////
					//AttVetorTermeletrica
					////////////////////////////

					for (int pos = 1; pos <= int(attVetorTermeletrica.size()); pos++) {

						if (a_dados.vetorTermeletrica.at(idTermeletrica).getSizeVetor(attVetorTermeletrica.at(pos)) > 0) {
							const double valor = a_dados.vetorTermeletrica.at(idTermeletrica).getElementoVetor(attVetorTermeletrica.at(pos), periodo_ultimo_sobreposicao, double());
							a_dados.vetorTermeletrica.at(idTermeletrica).setElemento(attVetorTermeletrica.at(pos), periodo, valor);
						}//if (a_dados.vetorTermeletrica.at(idTermeletrica).getSizeVetor(attVetorTermeletrica.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attVetorTermeletrica.size()); pos++) {

					////////////////////////////
					//AttMatrizTermeletrica
					////////////////////////////

					for (int pos = 1; pos <= int(attMatrizTermeletrica.size()); pos++) {

						if (a_dados.vetorTermeletrica.at(idTermeletrica).getSizeMatriz(attMatrizTermeletrica.at(pos)) > 0) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
								const double valor = a_dados.vetorTermeletrica.at(idTermeletrica).getElementoMatriz(attMatrizTermeletrica.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
								a_dados.vetorTermeletrica.at(idTermeletrica).setElemento(attMatrizTermeletrica.at(pos), periodo, idPatamarCarga, valor);
							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//if (a_dados.vetorTermeletrica.at(idTermeletrica).getSizeMatriz(attMatrizTermeletrica.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attMatrizHidreletrica_modificar.at(idHidreletrica).size()); pos++) {

				}//for (IdTermeletrica idTermeletrica = idTermeletricaIni; idTermeletrica < idTermeletricaOut; a_dados.vetorTermeletrica.incr(idTermeletrica)) {

			}//if (periodo > periodo_ultimo_sobreposicao) {

		}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_termeletrica: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_submercado(Dados& a_dados) {

	try {

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Nota: Método para atualizar os períodos do horizonte_estudo > ao último período do horizonte_DC (condição da extensão do horizonte_estudo)
		// Verifica se o vetor/matriz está instanciado e caso positivo, atualiza todos os periodos do horizonte de estudo > ao último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		const IdSubmercado idSubmercadoIni = a_dados.getMenorId(IdSubmercado());
		const IdSubmercado idSubmercadoOut = a_dados.getIdOut(IdSubmercado());

		////////////////////////////
		//AttMatrizSubmercado
		////////////////////////////

		SmartEnupla<int, AttMatrizSubmercado> attMatrizSubmercado;

		if (true) {
			int pos_elemento = 1;
			attMatrizSubmercado.addElemento(pos_elemento, AttMatrizSubmercado_demanda);

		}

		////////////////////////////
		//AttMatrizPatamarDeficit
		////////////////////////////

		SmartEnupla<int, AttMatrizPatamarDeficit> attMatrizPatamarDeficit;

		if (true) {
			int pos_elemento = 1;
			attMatrizPatamarDeficit.addElemento(pos_elemento, AttMatrizPatamarDeficit_potencia_maxima);
			pos_elemento++;
			attMatrizPatamarDeficit.addElemento(pos_elemento, AttMatrizPatamarDeficit_percentual);
			pos_elemento++;
			attMatrizPatamarDeficit.addElemento(pos_elemento, AttMatrizPatamarDeficit_custo);

		}

		////////////////////////////
		//AttMatrizUsinaNaoSimulada
		////////////////////////////

		SmartEnupla<int, AttMatrizUsinaNaoSimulada> attMatrizUsinaNaoSimulada;

		if (true) {
			int pos_elemento = 1;
			attMatrizUsinaNaoSimulada.addElemento(pos_elemento, AttMatrizUsinaNaoSimulada_potencia_maxima);
			pos_elemento++;
			attMatrizUsinaNaoSimulada.addElemento(pos_elemento, AttMatrizUsinaNaoSimulada_potencia_minima);
		}


		/////////////////////////////////////////////////////////////////////////////
		//1. Identifica o último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		/////////////////////////////////////////////////////////////////////////////
		const Periodo periodo_ultimo_sobreposicao = get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados);

		/////////////////////////////////////////////////////////////////////////////
		//2. Identifica o último periodo do horizonte de estudo
		/////////////////////////////////////////////////////////////////////////////

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

		for (Periodo periodo = periodo_ultimo_sobreposicao; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

			if (periodo > periodo_ultimo_sobreposicao) {//Periodos extensão do horizonte

				for (IdSubmercado idSubmercado = idSubmercadoIni; idSubmercado < idSubmercadoOut; a_dados.vetorSubmercado.incr(idSubmercado)) {

					////////////////////////////
					//AttMatrizSubmercado
					////////////////////////////

					for (int pos = 1; pos <= int(attMatrizSubmercado.size()); pos++) {

						if (a_dados.vetorSubmercado.at(idSubmercado).getSizeMatriz(attMatrizSubmercado.at(pos)) > 0) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
								const double valor = a_dados.vetorSubmercado.at(idSubmercado).getElementoMatriz(attMatrizSubmercado.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
								a_dados.vetorSubmercado.at(idSubmercado).setElemento(attMatrizSubmercado.at(pos), periodo, idPatamarCarga, valor);
							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//if (a_dados.vetorSubmercado.at(idSubmercado).getSizeMatriz(attMatrizSubmercado.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attMatrizHidreletrica_modificar.at(idHidreletrica).size()); pos++) {

					////////////////////////////
					//AttMatrizPatamarDeficit
					////////////////////////////

					const IdPatamarDeficit menorIdPatamarDeficit = a_dados.getMenorId(idSubmercado, IdPatamarDeficit());
					const IdPatamarDeficit maiorIdPatamarDeficit = a_dados.getMaiorId(idSubmercado, IdPatamarDeficit());

					if (menorIdPatamarDeficit != IdPatamarDeficit_Nenhum) {

						for (IdPatamarDeficit idPatamarDeficit = menorIdPatamarDeficit; idPatamarDeficit <= maiorIdPatamarDeficit; idPatamarDeficit++) {

							for (int pos = 1; pos <= int(attMatrizPatamarDeficit.size()); pos++) {

								if (a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).getSizeMatriz(attMatrizPatamarDeficit.at(pos)) > 0) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

									for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
										const double valor = a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).getElementoMatriz(attMatrizPatamarDeficit.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
										a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setElemento(attMatrizPatamarDeficit.at(pos), periodo, idPatamarCarga, valor);
									}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

								}//if (a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).getSizeMatriz(attMatrizPatamarDeficit.at(pos)) > 0) {

							}//for (int pos = 1; pos <= int(attMatrizHidreletrica_modificar.at(idHidreletrica).size()); pos++) {

						}//for (IdPatamarDeficit idPatamarDeficit = menorIdPatamarDeficit; idPatamarDeficit <= maiorIdPatamarDeficit; idPatamarDeficit++) {

					}

					////////////////////////////
					//AttMatrizUsinaNaoSimulada
					////////////////////////////

					const IdUsinaNaoSimulada idUsinaNaoSimuladaIni = a_dados.getMenorId(idSubmercado, IdUsinaNaoSimulada());
					const IdUsinaNaoSimulada idUsinaNaoSimuladaOut = a_dados.getIdOut(idSubmercado, IdUsinaNaoSimulada());

					for (IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimuladaIni; idUsinaNaoSimulada < idUsinaNaoSimuladaOut; a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada)) {

						for (int pos = 1; pos <= int(attMatrizUsinaNaoSimulada.size()); pos++) {

							if (a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).getSizeMatriz(attMatrizUsinaNaoSimulada.at(pos)) > 0) {

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

								for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
									const double valor = a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).getElementoMatriz(attMatrizUsinaNaoSimulada.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
									a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(attMatrizUsinaNaoSimulada.at(pos), periodo, idPatamarCarga, valor);
								}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

							}//if (a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).getSizeMatriz(attMatrizUsinaNaoSimulada.at(pos)) > 0) {

						}//for (int pos = 1; pos <= int(attMatrizHidreletrica_modificar.at(idHidreletrica).size()); pos++) {

					}//for (IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimuladaIni; idUsinaNaoSimulada < idUsinaNaoSimuladaOut; a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada)) {

				}//for (IdSubmercado idSubmercado = idSubmercadoIni; idSubmercado < idSubmercadoOut; a_dados.vetorSubmercado.incr(idSubmercado)) {

			}//if (periodo > periodo_ultimo_sobreposicao) {

		}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_submercado: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_intercambio(Dados& a_dados) {

	try {

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Nota: Método para atualizar os períodos do horizonte_estudo > ao último período do horizonte_DC (condição da extensão do horizonte_estudo)
		// Verifica se o vetor/matriz está instanciado e caso positivo, atualiza todos os periodos do horizonte de estudo > ao último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		const IdIntercambio menorIdIntercambio = a_dados.getMenorId(IdIntercambio());
		const IdIntercambio maiorIdIntercambio = a_dados.getMaiorId(IdIntercambio());

		////////////////////////////
		//AttMatrizIntercambio
		////////////////////////////

		SmartEnupla<int, AttMatrizIntercambio> attMatrizIntercambio;

		if (true) {
			int pos_elemento = 1;
			attMatrizIntercambio.addElemento(pos_elemento, AttMatrizIntercambio_potencia_maxima);
			pos_elemento++;
			attMatrizIntercambio.addElemento(pos_elemento, AttMatrizIntercambio_potencia_minima);

		}

		/////////////////////////////////////////////////////////////////////////////
		//1. Identifica o último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		/////////////////////////////////////////////////////////////////////////////
		const Periodo periodo_ultimo_sobreposicao = get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados);

		/////////////////////////////////////////////////////////////////////////////
		//2. Identifica o último periodo do horizonte de estudo
		/////////////////////////////////////////////////////////////////////////////

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

		for (Periodo periodo = periodo_ultimo_sobreposicao; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

			if (periodo > periodo_ultimo_sobreposicao) {//Periodos extensão do horizonte

				for (IdIntercambio idIntercambio = menorIdIntercambio; idIntercambio <= maiorIdIntercambio; idIntercambio++) {

					////////////////////////////
					//AttMatrizIntercambio
					////////////////////////////

					for (int pos = 1; pos <= int(attMatrizIntercambio.size()); pos++) {

						if (a_dados.vetorIntercambio.at(idIntercambio).getSizeMatriz(attMatrizIntercambio.at(pos)) > 0) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
								const double valor = a_dados.vetorIntercambio.at(idIntercambio).getElementoMatriz(attMatrizIntercambio.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
								a_dados.vetorIntercambio.at(idIntercambio).setElemento(attMatrizIntercambio.at(pos), periodo, idPatamarCarga, valor);
							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//if (a_dados.vetorIntercambio.at(idIntercambio).getSizeMatriz(attMatrizIntercambio.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attMatrizHidreletrica_modificar.at(idHidreletrica).size()); pos++) {

				}//for (IdIntercambio idIntercambio = menorIdIntercambio; idIntercambio <= maiorIdIntercambio; idIntercambio++) {

			}//if (periodo > periodo_ultimo_sobreposicao) {

		}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_intercambio: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_usina_elevatoria(Dados& a_dados) {

	try {

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Nota: Método para atualizar os períodos do horizonte_estudo > ao último período do horizonte_DC (condição da extensão do horizonte_estudo)
		// Verifica se o vetor/matriz está instanciado e caso positivo, atualiza todos os periodos do horizonte de estudo > ao último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		const IdUsinaElevatoria menorIdUsinaElevatoria = a_dados.getMenorId(IdUsinaElevatoria());
		const IdUsinaElevatoria maiorIdUsinaElevatoria = a_dados.getMaiorId(IdUsinaElevatoria());

		////////////////////////////
		//AttVetorUsinaElevatoria
		////////////////////////////

		SmartEnupla<int, AttVetorUsinaElevatoria> attVetorUsinaElevatoria;

		if (true) {
			int pos_elemento = 1;
			attVetorUsinaElevatoria.addElemento(pos_elemento, AttVetorUsinaElevatoria_fator_disponibilidade);
			pos_elemento++;
			attVetorUsinaElevatoria.addElemento(pos_elemento, AttVetorUsinaElevatoria_vazao_bombeada_minima);
			pos_elemento++;
			attVetorUsinaElevatoria.addElemento(pos_elemento, AttVetorUsinaElevatoria_vazao_bombeada_maxima);

		}

		////////////////////////////
		//AttMatrizUsinaElevatoria
		////////////////////////////

		SmartEnupla<int, AttMatrizUsinaElevatoria> attMatrizUsinaElevatoria;

		if (true) {
			int pos_elemento = 1;
			attMatrizUsinaElevatoria.addElemento(pos_elemento, AttMatrizUsinaElevatoria_vazao_bombeada_disponivel_maxima);
			pos_elemento++;
			attMatrizUsinaElevatoria.addElemento(pos_elemento, AttMatrizUsinaElevatoria_vazao_bombeada_disponivel_minima);

		}

		/////////////////////////////////////////////////////////////////////////////
		//1. Identifica o último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		/////////////////////////////////////////////////////////////////////////////
		const Periodo periodo_ultimo_sobreposicao = get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados);

		/////////////////////////////////////////////////////////////////////////////
		//2. Identifica o último periodo do horizonte de estudo
		/////////////////////////////////////////////////////////////////////////////

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

		for (Periodo periodo = periodo_ultimo_sobreposicao; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

			if (periodo > periodo_ultimo_sobreposicao) {//Periodos extensão do horizonte

				for (IdUsinaElevatoria idUsinaElevatoria = menorIdUsinaElevatoria; idUsinaElevatoria <= maiorIdUsinaElevatoria; idUsinaElevatoria++) {

					////////////////////////////
					//AttVetorUsinaElevatoria
					////////////////////////////

					for (int pos = 1; pos <= int(attVetorUsinaElevatoria.size()); pos++) {

						if (a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).getSizeVetor(attVetorUsinaElevatoria.at(pos)) > 0) {
							const double valor = a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).getElementoVetor(attVetorUsinaElevatoria.at(pos), periodo_ultimo_sobreposicao, double());
							a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setElemento(attVetorUsinaElevatoria.at(pos), periodo, valor);
						}//if (a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).getSizeVetor(attVetorUsinaElevatoria.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attVetorUsinaElevatoria.size()); pos++) {


					////////////////////////////
					//AttMatrizUsinaElevatoria
					////////////////////////////

					for (int pos = 1; pos <= int(attMatrizUsinaElevatoria.size()); pos++) {

						if (a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).getSizeMatriz(attMatrizUsinaElevatoria.at(pos)) > 0) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
								const double valor = a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).getElementoMatriz(attMatrizUsinaElevatoria.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
								a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).setElemento(attMatrizUsinaElevatoria.at(pos), periodo, idPatamarCarga, valor);
							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//if (a_dados.vetorUsinaElevatoria.at(idUsinaElevatoria).getSizeMatriz(attMatrizUsinaElevatoria.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attMatrizHidreletrica_modificar.at(idHidreletrica).size()); pos++) {

				}//for (IdUsinaElevatoria idUsinaElevatoria = menorIdUsinaElevatoria; idUsinaElevatoria <= maiorIdUsinaElevatoria; idUsinaElevatoria++) {

			}//if (periodo > periodo_ultimo_sobreposicao) {

		}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_usina_elevatoria: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_restricao_eletrica(Dados& a_dados) {

	try {

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Nota: Método para atualizar os períodos do horizonte_estudo > ao último período do horizonte_DC (condição da extensão do horizonte_estudo)
		// Verifica se o vetor/matriz está instanciado e caso positivo, atualiza todos os periodos do horizonte de estudo > ao último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		const IdRestricaoEletrica menorIdRestricaoEletrica = a_dados.getMenorId(IdRestricaoEletrica());
		const IdRestricaoEletrica maiorIdRestricaoEletrica = a_dados.getMaiorId(IdRestricaoEletrica());

		////////////////////////////
		//AttMatrizRestricaoEletrica
		////////////////////////////

		SmartEnupla<int, AttMatrizRestricaoEletrica> attMatrizRestricaoEletrica;

		if (true) {
			int pos_elemento = 1;
			attMatrizRestricaoEletrica.addElemento(pos_elemento, AttMatrizRestricaoEletrica_lim_inf);
			pos_elemento++;
			attMatrizRestricaoEletrica.addElemento(pos_elemento, AttMatrizRestricaoEletrica_lim_sup);
		}

		////////////////////////////
		//AttMatrizElementoSistema
		////////////////////////////

		SmartEnupla<int, AttMatrizElementoSistema> attMatrizElementoSistema;

		if (true) {
			int pos_elemento = 1;
			attMatrizElementoSistema.addElemento(pos_elemento, AttMatrizElementoSistema_fator_participacao);

		}


		/////////////////////////////////////////////////////////////////////////////
		//1. Identifica o último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		/////////////////////////////////////////////////////////////////////////////
		const Periodo periodo_ultimo_sobreposicao = get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados);

		/////////////////////////////////////////////////////////////////////////////
		//2. Identifica o último periodo do horizonte de estudo
		/////////////////////////////////////////////////////////////////////////////

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

		for (Periodo periodo = periodo_ultimo_sobreposicao; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

			if (periodo > periodo_ultimo_sobreposicao) {//Periodos extensão do horizonte

				for (IdRestricaoEletrica idRestricaoEletrica = menorIdRestricaoEletrica; idRestricaoEletrica <= maiorIdRestricaoEletrica; idRestricaoEletrica++) {

					////////////////////////////
					//AttMatrizRestricaoEletrica
					////////////////////////////

					for (int pos = 1; pos <= int(attMatrizRestricaoEletrica.size()); pos++) {

						if (a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).getSizeMatriz(attMatrizRestricaoEletrica.at(pos)) > 0) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
								const double valor = a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).getElementoMatriz(attMatrizRestricaoEletrica.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
								a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(attMatrizRestricaoEletrica.at(pos), periodo, idPatamarCarga, valor);
							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//if (a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).getSizeMatriz(attMatrizRestricaoEletrica.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attMatrizHidreletrica_modificar.at(idHidreletrica).size()); pos++) {

					////////////////////////////
					//AttMatrizElementoSistema
					////////////////////////////

					const IdElementoSistema menorIdElementoSistema = a_dados.getMenorId(idRestricaoEletrica, IdElementoSistema());
					const IdElementoSistema maiorIdElementoSistema = a_dados.getMaiorId(idRestricaoEletrica, IdElementoSistema());

					for (IdElementoSistema idElementoSistema = menorIdElementoSistema; idElementoSistema <= maiorIdElementoSistema; idElementoSistema++) {

						for (int pos = 1; pos <= int(attMatrizElementoSistema.size()); pos++) {

							if (a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(idElementoSistema).getSizeMatriz(attMatrizElementoSistema.at(pos)) > 0) {

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

								for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
									const double valor = a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(idElementoSistema).getElementoMatriz(attMatrizElementoSistema.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
									a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(idElementoSistema).setElemento(attMatrizElementoSistema.at(pos), periodo, idPatamarCarga, valor);
								}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

							}//if (a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(idElementoSistema).getSizeMatriz(attMatrizElementoSistema.at(pos)) > 0) {

						}//for (int pos = 1; pos <= int(attMatrizHidreletrica_modificar.at(idHidreletrica).size()); pos++) {

					}//for (IdElementoSistema idElementoSistema = menorIdElementoSistema; idElementoSistema <= maiorIdElementoSistema; idElementoSistema++) {



				}//for (IdRestricaoEletrica idRestricaoEletrica = menorIdRestricaoEletrica; idRestricaoEletrica <= maiorIdRestricaoEletrica; idRestricaoEletrica++) {

			}//if (periodo > periodo_ultimo_sobreposicao) {

		}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_restricao_eletrica: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_restricao_operativa_UHE(Dados& a_dados) {

	try {

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Nota: Método para atualizar os períodos do horizonte_estudo > ao último período do horizonte_DC (condição da extensão do horizonte_estudo)
		// Verifica se o vetor/matriz está instanciado e caso positivo, atualiza todos os periodos do horizonte de estudo > ao último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		const IdRestricaoOperativaUHE menorIdRestricaoOperativaUHE = a_dados.getMenorId(IdRestricaoOperativaUHE());
		const IdRestricaoOperativaUHE maiorIdRestricaoOperativaUHE = a_dados.getMaiorId(IdRestricaoOperativaUHE());

		////////////////////////////
		//AttMatrizRestricaoOperativaUHE
		////////////////////////////

		SmartEnupla<int, AttMatrizRestricaoOperativaUHE> attMatrizRestricaoOperativaUHE;

		if (true) {
			int pos_elemento = 1;
			attMatrizRestricaoOperativaUHE.addElemento(pos_elemento, AttMatrizRestricaoOperativaUHE_lim_inf);
			pos_elemento++;
			attMatrizRestricaoOperativaUHE.addElemento(pos_elemento, AttMatrizRestricaoOperativaUHE_lim_sup);

		}

		////////////////////////////
		//AttMatrizElementoSistema
		////////////////////////////

		SmartEnupla<int, AttMatrizElementoSistema> attMatrizElementoSistema;

		if (true) {
			int pos_elemento = 1;
			attMatrizElementoSistema.addElemento(pos_elemento, AttMatrizElementoSistema_fator_participacao);

		}


		/////////////////////////////////////////////////////////////////////////////
		//1. Identifica o último periodo do horizonte de estudo
		// com sobreposição com o horizonte_DC
		/////////////////////////////////////////////////////////////////////////////
		const Periodo periodo_ultimo_sobreposicao = get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados);

		/////////////////////////////////////////////////////////////////////////////
		//2. Identifica o último periodo do horizonte de estudo
		/////////////////////////////////////////////////////////////////////////////

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const Periodo periodo_final = horizonte_estudo.getIteradorFinal();

		for (Periodo periodo = periodo_ultimo_sobreposicao; periodo <= periodo_final; horizonte_estudo.incrementarIterador(periodo)) {

			if (periodo > periodo_ultimo_sobreposicao) {//Periodos extensão do horizonte

				for (IdRestricaoOperativaUHE idRestricaoOperativaUHE = menorIdRestricaoOperativaUHE; idRestricaoOperativaUHE <= maiorIdRestricaoOperativaUHE; idRestricaoOperativaUHE++) {

					////////////////////////////
					//AttMatrizRestricaoOperativaUHE
					////////////////////////////

					for (int pos = 1; pos <= int(attMatrizRestricaoOperativaUHE.size()); pos++) {

						if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getSizeMatriz(attMatrizRestricaoOperativaUHE.at(pos)) > 0) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
								const double valor = a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getElementoMatriz(attMatrizRestricaoOperativaUHE.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
								a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(attMatrizRestricaoOperativaUHE.at(pos), periodo, idPatamarCarga, valor);
							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getSizeMatriz(attMatrizRestricaoOperativaUHE.at(pos)) > 0) {

					}//for (int pos = 1; pos <= int(attMatrizHidreletrica_modificar.at(idHidreletrica).size()); pos++) {

					////////////////////////////
					//AttMatrizElementoSistema
					////////////////////////////

					const IdElementoSistema menorIdElementoSistema = a_dados.getMenorId(idRestricaoOperativaUHE, IdElementoSistema());
					const IdElementoSistema maiorIdElementoSistema = a_dados.getMaiorId(idRestricaoOperativaUHE, IdElementoSistema());

					if (menorIdElementoSistema != IdElementoSistema_Nenhum) {//As restrições de energia armazenada ainda não tem instanciados os elementosSistema porque precisam de todas as atualizações para o cálculo das produtibilidades EAR

						for (IdElementoSistema idElementoSistema = menorIdElementoSistema; idElementoSistema <= maiorIdElementoSistema; idElementoSistema++) {

							for (int pos = 1; pos <= int(attMatrizElementoSistema.size()); pos++) {

								if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema).getSizeMatriz(attMatrizElementoSistema.at(pos)) > 0) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

									for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
										const double valor = a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema).getElementoMatriz(attMatrizElementoSistema.at(pos), periodo_ultimo_sobreposicao, idPatamarCarga, double());
										a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema).setElemento(attMatrizElementoSistema.at(pos), periodo, idPatamarCarga, valor);
									}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

								}//if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema).getSizeMatriz(attMatrizElementoSistema.at(pos)) > 0) {

							}//for (int pos = 1; pos <= int(attMatrizHidreletrica_modificar.at(idHidreletrica).size()); pos++) {

						}//for (IdElementoSistema idElementoSistema = menorIdElementoSistema; idElementoSistema <= maiorIdElementoSistema; idElementoSistema++) {

					}//if (menorIdElementoSistema != IdElementoSistema_Nenhum) {

				}//for (IdRestricaoEletrica idRestricaoEletrica = menorIdRestricaoEletrica; idRestricaoEletrica <= maiorIdRestricaoEletrica; idRestricaoEletrica++) {

			}//if (periodo > periodo_ultimo_sobreposicao) {

		}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_restricao_operativa_UHE: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_com_DadosEntradaMP_PRECONFIG(Dados& a_dados, std::string a_diretorio) {

	try {

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());

		const Periodo periodo_final_PE_DECOMP = horizonte_otimizacao.at(horizonte_estudo.at(get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados)));

		Dados dados_MP;

		EntradaSaidaDados entradaSaidaDados;

		entradaSaidaDados.setDiretorioEntrada(a_diretorio);
		bool dadosPreConfig_horizonte_estudo                 = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("DADOS_AttVetorOperacional_PorPeriodo.csv", dados_MP, TipoAcessoInstancia_direto);
		bool dadosPreConfig_percentual_duracao_patamar_carga = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("DADOS_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_MP, TipoAcessoInstancia_direto);
		entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("SUBMERCADO_AttComumOperacional.csv", dados_MP, TipoAcessoInstancia_m1);
		bool dadosPreConfig_submercado                       = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("SUBMERCADO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_MP, TipoAcessoInstancia_m1);
		entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("INTERCAMBIO_AttComumOperacional.csv", dados_MP, TipoAcessoInstancia_m1);
		bool dadosPreConfig_intercambio = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("INTERCAMBIO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_MP, TipoAcessoInstancia_m1);
		bool dadosPreConfig_patamar_deficit                  = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("SUBMERCADO_PATAMAR_DEFICIT_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_MP, TipoAcessoInstancia_m2);
		bool dadosPreConfig_usina_nao_simulada               = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("SUBMERCADO_USINA_NAO_SIMULADA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_MP, TipoAcessoInstancia_m2);
		
		entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("HIDRELETRICA_AttComumOperacional.csv", dados_MP, TipoAcessoInstancia_m1);
		entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("HIDRELETRICA_RESERVATORIO_AttComumOperacional.csv", dados_MP, TipoAcessoInstancia_m2);
		bool dadosPreConfig_hidreletrica_premissa = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("HIDRELETRICA_AttVetorPremissa_PorPeriodo.csv", dados_MP, TipoAcessoInstancia_m1);
		bool dadosPreConfig_reservatorio_premissa            = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("HIDRELETRICA_RESERVATORIO_AttVetorPremissa_PorPeriodo.csv", dados_MP, TipoAcessoInstancia_m2);
		bool dadosPreConfig_reservatorio_operacional         = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("HIDRELETRICA_RESERVATORIO_AttVetorOperacional_PorPeriodo.csv", dados_MP, TipoAcessoInstancia_m2);
		

		//////////////////////////////////////////////////////////////
		//SUBMERCADO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//////////////////////////////////////////////////////////////

		if (dadosPreConfig_submercado) {

			if (!dadosPreConfig_horizonte_estudo)
				throw std::invalid_argument("Deve ser instanciado o horizonte_estudo_MP com DADOS_AttVetorOperacional_PorPeriodo.csv em diretorio: " + a_diretorio);
			
			if (!dadosPreConfig_percentual_duracao_patamar_carga)
				throw std::invalid_argument("Deve ser instanciado o percentual_duracao_patamar_carga com DADOS_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv em diretorio: " + a_diretorio);

			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo_MP = dados_MP.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		
			for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

					if (periodo < periodo_MP)//Evita percorrer todo o horizonte_estudo_MP
						break;

					/////////

					if (periodo == periodo_MP && periodo_MP > periodo_final_PE_DECOMP) {//Atualiza com info de pre-config do MP

						const IdPatamarCarga maiorIdPatamarCarga_MP = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(dados_MP, periodo);
						const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

						if(maiorIdPatamarCarga != maiorIdPatamarCarga_MP)
							throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_MP");

						///////////////////////////////////////////////////////
						//AttMatrizDados_percentual_duracao_patamar_carga
						///////////////////////////////////////////////////////

						for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
							const double valor = dados_MP.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, double());
							a_dados.setElemento(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga, valor);
						}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						///////////////////////////////////////////////////////
						//AttMatrizSubmercado_demanda
						///////////////////////////////////////////////////////

						const IdSubmercado idSubmercadoIni = a_dados.getMenorId(IdSubmercado());
						const IdSubmercado idSubmercadoOut = a_dados.getIdOut(IdSubmercado());

						for (IdSubmercado idSubmercado = idSubmercadoIni; idSubmercado < idSubmercadoOut; a_dados.vetorSubmercado.incr(idSubmercado)) {

							for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
								const double valor = dados_MP.vetorSubmercado.at(idSubmercado).getElementoMatriz(AttMatrizSubmercado_demanda, periodo, idPatamarCarga, double());
								a_dados.vetorSubmercado.at(idSubmercado).setElemento(AttMatrizSubmercado_demanda, periodo, idPatamarCarga, valor);

							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//for (IdSubmercado idSubmercado = idSubmercadoIni; idSubmercado < idSubmercadoOut; a_dados.vetorSubmercado.incr(idSubmercado)) {

					}//if (periodo == periodo_MP) {

				}//for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {
			
			}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

		}//if (dadosPreConfig_submercado) {

		//////////////////////////////////////////////////////////////
		//INTERCAMBIO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//////////////////////////////////////////////////////////////

		if (dadosPreConfig_intercambio) {

			if (!dadosPreConfig_horizonte_estudo)
				throw std::invalid_argument("Deve ser instanciado o horizonte_estudo_MP com DADOS_AttVetorOperacional_PorPeriodo.csv em diretorio: " + a_diretorio);

			if (!dadosPreConfig_percentual_duracao_patamar_carga)
				throw std::invalid_argument("Deve ser instanciado o percentual_duracao_patamar_carga com DADOS_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv em diretorio: " + a_diretorio);

			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo_MP = dados_MP.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

					if (periodo < periodo_MP)//Evita percorrer todo o horizonte_estudo_MP
						break;

					/////////

					if (periodo == periodo_MP && periodo_MP > periodo_final_PE_DECOMP) {//Atualiza com info de pre-config do MP

						const IdPatamarCarga maiorIdPatamarCarga_MP = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(dados_MP, periodo);
						const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

						if (maiorIdPatamarCarga != maiorIdPatamarCarga_MP)
							throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_MP");

						///////////////////////////////////////////////////////
						//AttMatrizIntercambio_potencia_minima e potencia_maxima
						///////////////////////////////////////////////////////

						const IdIntercambio menorIdIntercambio = a_dados.getMenorId(IdIntercambio());
						const IdIntercambio maiorIdIntercambio = a_dados.getMaiorId(IdIntercambio());

						const IdIntercambio menorIdIntercambio_MP = dados_MP.getMenorId(IdIntercambio());
						const IdIntercambio maiorIdIntercambio_MP = dados_MP.getMaiorId(IdIntercambio());

						for (IdIntercambio idIntercambio = menorIdIntercambio; idIntercambio <= maiorIdIntercambio; idIntercambio++) {

							const IdSubmercado submercado_origem  = a_dados.vetorIntercambio.at(idIntercambio).getAtributo(AttComumIntercambio_submercado_origem, IdSubmercado());
							const IdSubmercado submercado_destino = a_dados.vetorIntercambio.at(idIntercambio).getAtributo(AttComumIntercambio_submercado_destino, IdSubmercado());

							//Premissa: O MP não tem informação da expansão dos intercâmbios de IT, IV, ANDE. Portanto, é mantida a info do CP

							bool is_atualizar_limites_intercambios = true;

							if (submercado_origem == IdSubmercado_ITAIPU || submercado_destino == IdSubmercado_ITAIPU\
								||submercado_origem == IdSubmercado_IVAIPORA || submercado_destino == IdSubmercado_IVAIPORA\
								|| submercado_origem == IdSubmercado_ANDE || submercado_destino == IdSubmercado_ANDE) {
								is_atualizar_limites_intercambios = false;
							}

							/////////////////////////////////////////
							//Atualiza intercâmbios
							/////////////////////////////////////////

							if (is_atualizar_limites_intercambios) {

								IdIntercambio idIntercambio_MP_aux = IdIntercambio_Nenhum;

								for (IdIntercambio idIntercambio_MP = menorIdIntercambio_MP; idIntercambio_MP <= maiorIdIntercambio_MP; idIntercambio_MP++) {

									if (dados_MP.vetorIntercambio.at(idIntercambio_MP).getAtributo(AttComumIntercambio_submercado_origem, IdSubmercado()) == submercado_origem && \
										dados_MP.vetorIntercambio.at(idIntercambio_MP).getAtributo(AttComumIntercambio_submercado_destino, IdSubmercado()) == submercado_destino) {
										idIntercambio_MP_aux = idIntercambio_MP;
										break;
									}

								}//for (IdIntercambio idIntercambio_MP = menorIdIntercambio_MP; idIntercambio_MP <= maiorIdIntercambio_MP; idIntercambio_MP++) {

								if (idIntercambio_MP_aux != IdIntercambio_Nenhum) {

									for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
										//potencia_minima
										double valor = dados_MP.vetorIntercambio.at(idIntercambio_MP_aux).getElementoMatriz(AttMatrizIntercambio_potencia_minima, periodo, idPatamarCarga, double());
										a_dados.vetorIntercambio.at(idIntercambio).setElemento(AttMatrizIntercambio_potencia_minima, periodo, idPatamarCarga, valor);

										//potencia_maxima
										valor = dados_MP.vetorIntercambio.at(idIntercambio_MP_aux).getElementoMatriz(AttMatrizIntercambio_potencia_maxima, periodo, idPatamarCarga, double());
										a_dados.vetorIntercambio.at(idIntercambio).setElemento(AttMatrizIntercambio_potencia_maxima, periodo, idPatamarCarga, valor);

									}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

								}//if (idIntercambio_MP_aux != IdIntercambio_Nenhum) {

							}//if (is_atualizar_limites_intercambios) {

						}//for (IdIntercambio idIntercambio = menorIdIntercambio; idIntercambio <= maiorIdIntercambio; idIntercambio++) {

					}//if (periodo == periodo_MP) {

				}//for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

			}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

		}//if (dadosPreConfig_intercambio) {

		/////////////////////////////////////////////////////////////////////////////
		//SUBMERCADO_PATAMAR_DEFICIT_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		/////////////////////////////////////////////////////////////////////////////

		if (dadosPreConfig_patamar_deficit) {

			if (!dadosPreConfig_horizonte_estudo)
				throw std::invalid_argument("Deve ser instanciado o horizonte_estudo_MP com DADOS_AttVetorOperacional_PorPeriodo.csv em diretorio: " + a_diretorio);

			if (!dadosPreConfig_percentual_duracao_patamar_carga)
				throw std::invalid_argument("Deve ser instanciado o percentual_duracao_patamar_carga com DADOS_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv em diretorio: " + a_diretorio);

			if (!dadosPreConfig_submercado)
				throw std::invalid_argument("Deve ser instanciado a demanda com SUBMERCADO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv em diretorio: " + a_diretorio);


			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo_MP = dados_MP.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

					if (periodo < periodo_MP)//Evita percorrer todo o horizonte_estudo_MP
						break;

					/////////

					if (periodo == periodo_MP && periodo_MP > periodo_final_PE_DECOMP) {//Atualiza com info de pre-config do MP

						const IdPatamarCarga maiorIdPatamarCarga_MP = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(dados_MP, periodo);
						const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

						if (maiorIdPatamarCarga != maiorIdPatamarCarga_MP)
							throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_MP");

						///////////////////////////////////////////////////////
						//AttMatrizPatamarDeficit_custo
						///////////////////////////////////////////////////////

						const IdSubmercado idSubmercadoIni = a_dados.getMenorId(IdSubmercado());
						const IdSubmercado idSubmercadoOut = a_dados.getIdOut(IdSubmercado());

						for (IdSubmercado idSubmercado = idSubmercadoIni; idSubmercado < idSubmercadoOut; a_dados.vetorSubmercado.incr(idSubmercado)) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Podem existir diferenças nos Ids entre o CP e o MP, portanto, vai ser realizada a seguinte lógica:
							//Condição A: #Ids_CP >= #Ids_MP -> Zera para o período P a info de todos os Ids_CP, e depois atualiza a info com os Ids_MP
							//Condição B: #Ids_CP  < #Ids_MP -> Zera para o período P a info de todos os Ids_CP, e depois atualiza a info com os Ids_MP instanciando novos Ids_CP
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							const IdPatamarDeficit menorIdPatamarDeficit = a_dados.vetorSubmercado.at(idSubmercado).getMenorId(IdPatamarDeficit());
							
							const IdPatamarDeficit maiorIdPatamarDeficit = a_dados.vetorSubmercado.at(idSubmercado).getMaiorId(IdPatamarDeficit());
							const IdPatamarDeficit maiorIdPatamarDeficit_MP = dados_MP.vetorSubmercado.at(idSubmercado).getMaiorId(IdPatamarDeficit());

							if (menorIdPatamarDeficit != IdPatamarDeficit_Nenhum) {

								if (maiorIdPatamarDeficit >= maiorIdPatamarDeficit_MP) {

									for (IdPatamarDeficit idPatamarDeficit = menorIdPatamarDeficit; idPatamarDeficit <= maiorIdPatamarDeficit; idPatamarDeficit++) {

										for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

											//////////////////////////////////////////
											//AttMatrizPatamarDeficit_custo
											//////////////////////////////////////////
											double valor = 0.0;

											if (idPatamarDeficit <= maiorIdPatamarDeficit_MP) //Atualiza o CP com info do MP
												valor = dados_MP.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).getElementoMatriz(AttMatrizPatamarDeficit_custo, periodo, idPatamarCarga, double());

											a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setElemento(AttMatrizPatamarDeficit_custo, periodo, idPatamarCarga, valor);

											//////////////////////////////////////////
											//AttMatrizPatamarDeficit_percentual (no MP já está convertido em potencia_maxima)
											//////////////////////////////////////////
											valor = 0.0;
											if (idPatamarDeficit <= maiorIdPatamarDeficit_MP) { //Atualiza o CP com info do MP
												const double demanda_MP = dados_MP.vetorSubmercado.at(idSubmercado).getElementoMatriz(AttMatrizSubmercado_demanda, periodo, idPatamarCarga, double());
												const double potencia_maxima_MP = dados_MP.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).getElementoMatriz(AttMatrizPatamarDeficit_potencia_maxima, periodo, idPatamarCarga, double());

												if (demanda_MP > 0.0 && (potencia_maxima_MP - demanda_MP) < 0.0001)
													valor = 1.0;
												else if (demanda_MP > 0.0)
													valor = double(potencia_maxima_MP / demanda_MP);

											}//if (idPatamarDeficit <= maiorIdPatamarDeficit_MP) {

											a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setElemento(AttMatrizPatamarDeficit_percentual, periodo, idPatamarCarga, valor);

										}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

									}//for (IdPatamarDeficit idPatamarDeficit = menorIdPatamarDeficit; idPatamarDeficit <= maiorIdPatamarDeficit; idPatamarDeficit++) {

								}//if (maiorIdPatamarDeficit >= maiorIdPatamarDeficit_MP) {
								else if (maiorIdPatamarDeficit < maiorIdPatamarDeficit_MP) {

									///////////////////////////////////////////
									//1. Zera a informação e cria os novos idsCP
									///////////////////////////////////////////

									for (IdPatamarDeficit idPatamarDeficit = menorIdPatamarDeficit; idPatamarDeficit <= maiorIdPatamarDeficit_MP; idPatamarDeficit++) {

										if (idPatamarDeficit <= maiorIdPatamarDeficit) {//Zera a info do CP

											for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
												double valor = 0.0;
												//////////////////////////////////////////
												//AttMatrizPatamarDeficit_custo
												//////////////////////////////////////////
												a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setElemento(AttMatrizPatamarDeficit_custo, periodo, idPatamarCarga, valor);

												//////////////////////////////////////////
												//AttMatrizPatamarDeficit_percentual
												//////////////////////////////////////////
												a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setElemento(AttMatrizPatamarDeficit_percentual, periodo, idPatamarCarga, valor);
											}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
										}//if (idPatamarDeficit <= maiorIdPatamarDeficit) {
										else if (idPatamarDeficit > maiorIdPatamarDeficit) {//Cria um novo idPatamarDeficit com info zerada

											PatamarDeficit patamarDeficit;

											patamarDeficit.setAtributo(AttComumPatamarDeficit_idPatamarDeficit, idPatamarDeficit);

											a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.add(patamarDeficit);

											SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_patamarDeficit_percentual(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
											SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_patamarDeficit_custo(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

											for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

												const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
												matriz_patamarDeficit_percentual.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));
												matriz_patamarDeficit_custo.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

											}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

											/////////////////////////////////////

											a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setMatriz(AttMatrizPatamarDeficit_percentual, matriz_patamarDeficit_percentual);
											a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setMatriz(AttMatrizPatamarDeficit_custo, matriz_patamarDeficit_custo);

										}//else if (idPatamarDeficit > maiorIdPatamarDeficit) {

									}//for (IdPatamarDeficit idPatamarDeficit = menorIdPatamarDeficit; idPatamarDeficit <= maiorIdPatamarDeficit_MP; idPatamarDeficit++) {

									///////////////////////////////////////////
									//2. Atualiza info do CP com o MP
									///////////////////////////////////////////

									for (IdPatamarDeficit idPatamarDeficit = menorIdPatamarDeficit; idPatamarDeficit <= maiorIdPatamarDeficit_MP; idPatamarDeficit++) {

										for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

											//////////////////////////////////////////
											//AttMatrizPatamarDeficit_custo
											//////////////////////////////////////////
											double valor = dados_MP.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).getElementoMatriz(AttMatrizPatamarDeficit_custo, periodo, idPatamarCarga, double());
											a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setElemento(AttMatrizPatamarDeficit_custo, periodo, idPatamarCarga, valor);

											//////////////////////////////////////////
											//AttMatrizPatamarDeficit_percentual (no MP já está convertido em potencia_maxima)
											//////////////////////////////////////////

											valor = 0.0;

											const double demanda_MP = dados_MP.vetorSubmercado.at(idSubmercado).getElementoMatriz(AttMatrizSubmercado_demanda, periodo, idPatamarCarga, double());
											const double potencia_maxima_MP = dados_MP.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).getElementoMatriz(AttMatrizPatamarDeficit_potencia_maxima, periodo, idPatamarCarga, double());

											if (demanda_MP > 0.0 && (potencia_maxima_MP - demanda_MP) < 0.0001)
												valor = 1.0;
											else if (demanda_MP > 0.0)
												valor = double(potencia_maxima_MP / demanda_MP);

											a_dados.vetorSubmercado.at(idSubmercado).vetorPatamarDeficit.at(idPatamarDeficit).setElemento(AttMatrizPatamarDeficit_percentual, periodo, idPatamarCarga, valor);

										}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

									}//for (IdPatamarDeficit idPatamarDeficit = menorIdPatamarDeficit; idPatamarDeficit <= maiorIdPatamarDeficit_MP; idPatamarDeficit++) {

								}//else if (maiorIdPatamarDeficit < maiorIdPatamarDeficit_MP) {

							}//if (menorIdPatamarDeficit != IdPatamarDeficit_Nenhum) {

						}//for (IdSubmercado idSubmercado = idSubmercadoIni; idSubmercado < idSubmercadoOut; a_dados.vetorSubmercado.incr(idSubmercado)) {

					}//if (periodo == periodo_MP) {

				}//for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

			}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

		}//if (dadosPreConfig_patamar_deficit) {

		/////////////////////////////////////////////////////////////////////////////
		//SUBMERCADO_USINA_NAO_SIMULADA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		/////////////////////////////////////////////////////////////////////////////

		if (dadosPreConfig_usina_nao_simulada) {

			if (!dadosPreConfig_horizonte_estudo)
				throw std::invalid_argument("Deve ser instanciado o horizonte_estudo_MP com DADOS_AttVetorOperacional_PorPeriodo.csv em diretorio: " + a_diretorio);

			if (!dadosPreConfig_percentual_duracao_patamar_carga)
				throw std::invalid_argument("Deve ser instanciado o percentual_duracao_patamar_carga com DADOS_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv em diretorio: " + a_diretorio);

			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo_MP = dados_MP.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

					if (periodo < periodo_MP)//Evita percorrer todo o horizonte_estudo_MP
						break;

					/////////

					if (periodo == periodo_MP && periodo_MP > periodo_final_PE_DECOMP) {//Atualiza com info de pre-config do MP

						const IdPatamarCarga maiorIdPatamarCarga_MP = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(dados_MP, periodo);
						const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

						if (maiorIdPatamarCarga != maiorIdPatamarCarga_MP)
							throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_MP");

						///////////////////////////////////////////////////////
						//AttMatrizUsinaNaoSimulada
						///////////////////////////////////////////////////////

						const IdSubmercado idSubmercadoIni = a_dados.getMenorId(IdSubmercado());
						const IdSubmercado idSubmercadoOut = a_dados.getIdOut(IdSubmercado());

						for (IdSubmercado idSubmercado = idSubmercadoIni; idSubmercado < idSubmercadoOut; a_dados.vetorSubmercado.incr(idSubmercado)) {

							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
							//Podem existir diferenças nos Ids entre o CP e o MP, portanto, vai ser realizada a seguinte lógica:
							//Zera para o período P a info de todos os Ids_CP, depois cria novos Ids_CP (se necessário) e atualiza a info com os Ids_MP
							/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

							const IdUsinaNaoSimulada idUsinaNaoSimuladaIni = a_dados.vetorSubmercado.at(idSubmercado).getMenorId(IdUsinaNaoSimulada());
							const IdUsinaNaoSimulada idUsinaNaoSimuladaOut = a_dados.vetorSubmercado.at(idSubmercado).getIdOut(IdUsinaNaoSimulada());
							
							const IdUsinaNaoSimulada idUsinaNaoSimuladaIni_MP = dados_MP.vetorSubmercado.at(idSubmercado).getMenorId(IdUsinaNaoSimulada());
							const IdUsinaNaoSimulada idUsinaNaoSimuladaOut_MP = dados_MP.vetorSubmercado.at(idSubmercado).getIdOut(IdUsinaNaoSimulada());

							///////////////////////////////////////////////////////////////////////////////
							//1. Zera a informação dos idsCP (para o periodo avaliado)
							///////////////////////////////////////////////////////////////////////////////

							for (IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimuladaIni; idUsinaNaoSimulada < idUsinaNaoSimuladaOut; a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada)) {

								//Zera a info do CP
								for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
									const double valor = 0.0;
									//////////////////////////////////////////
									//AttMatrizUsinaNaoSimulada_potencia_minima
									//////////////////////////////////////////
									a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_minima, periodo, idPatamarCarga, valor);

									//////////////////////////////////////////
									//AttMatrizUsinaNaoSimulada_potencia_maxima
									//////////////////////////////////////////
									a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, idPatamarCarga, valor);
								}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

							}//for (IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimuladaIni; idUsinaNaoSimulada < idUsinaNaoSimuladaOut; a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada)) {

							///////////////////////////////////////////////////////////////////////////////
							//2. Atualiza info do CP com o MP
							// Percorre os Ids_MP (se necessário cria novos Ids_CP) e atualiza a informação
							///////////////////////////////////////////////////////////////////////////////

							for (IdUsinaNaoSimulada idUsinaNaoSimulada_MP = idUsinaNaoSimuladaIni_MP; idUsinaNaoSimulada_MP < idUsinaNaoSimuladaOut_MP; dados_MP.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada_MP)) {

								const IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimulada_MP;

								//Instancia Ids_CP que não existem
								if (!a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.isInstanciado(idUsinaNaoSimulada)) {

									UsinaNaoSimulada usinaNaoSimulada;

									usinaNaoSimulada.setAtributo(AttComumUsinaNaoSimulada_idUsinaNaoSimulada, idUsinaNaoSimulada);

									a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.add(usinaNaoSimulada);

									SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

									for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
										matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

									}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									/////////////////////////////////////

									a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setMatriz(AttMatrizUsinaNaoSimulada_potencia_minima, matriz_zero);
									a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setMatriz(AttMatrizUsinaNaoSimulada_potencia_maxima, matriz_zero);


								}//if (!a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.isInstanciado(idUsinaNaoSimulada)) {

								//Atualiza info CP com MP
								for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

									//////////////////////////////////////////
									//AttMatrizUsinaNaoSimulada_potencia_minima
									//////////////////////////////////////////
									double valor = dados_MP.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_MP).getElementoMatriz(AttMatrizUsinaNaoSimulada_potencia_minima, periodo, idPatamarCarga, double());
									a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_minima, periodo, idPatamarCarga, valor);

									//////////////////////////////////////////
									//AttMatrizUsinaNaoSimulada_potencia_maxima
									//////////////////////////////////////////
									valor = dados_MP.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_MP).getElementoMatriz(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, idPatamarCarga, double());
									a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, idPatamarCarga, valor);

								}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

							}//for (IdUsinaNaoSimulada idUsinaNaoSimulada_MP = idUsinaNaoSimuladaIni_MP; idUsinaNaoSimulada_MP < idUsinaNaoSimuladaOut_MP; dados_MP.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada_MP)) {

						}//for (IdSubmercado idSubmercado = idSubmercadoIni; idSubmercado < idSubmercadoOut; a_dados.vetorSubmercado.incr(idSubmercado)) {

					}//if (periodo == periodo_MP) {

				}//for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

			}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

		}//if (dadosPreConfig_usina_nao_simulada) {

		/////////////////////////////////////////////////////////////////////////////
		//HIDRELETRICA_RESERVATORIO_AttVetorPremissa_PorPeriodo
		/////////////////////////////////////////////////////////////////////////////

		if (dadosPreConfig_reservatorio_premissa) {

			if (!dadosPreConfig_horizonte_estudo)
				throw std::invalid_argument("Deve ser instanciado o horizonte_estudo_MP com DADOS_AttVetorOperacional_PorPeriodo.csv em diretorio: " + a_diretorio);

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo_MP = dados_MP.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

					if (periodo < periodo_MP)//Evita percorrer todo o horizonte_estudo_MP
						break;

					/////////

					if (periodo == periodo_MP && periodo_MP > periodo_final_PE_DECOMP) {//Atualiza com info de pre-config do MP

						for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

							if (dados_MP.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(AttVetorReservatorio_volume_maximo) > 0) {
								double valor = dados_MP.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_maximo, periodo, double());
								a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(AttVetorReservatorio_volume_maximo, periodo, valor);
							}//if (dados_MP.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(AttVetorReservatorio_volume_maximo) > 0) {

						}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

					}//if (periodo == periodo_MP) {

				}//for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

			}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

		}//if (dadosPreConfig_reservatorio_premissa) {

		/////////////////////////////////////////////////////////////////////////////
		//HIDRELETRICA_RESERVATORIO_AttVetorOperacional_PorPeriodo
		/////////////////////////////////////////////////////////////////////////////

		if (dadosPreConfig_reservatorio_operacional) {

			if (!dadosPreConfig_horizonte_estudo)
				throw std::invalid_argument("Deve ser instanciado o horizonte_estudo_MP com DADOS_AttVetorOperacional_PorPeriodo.csv em diretorio: " + a_diretorio);

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo_MP = dados_MP.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

					if (periodo < periodo_MP)//Evita percorrer todo o horizonte_estudo_MP
						break;

					/////////

					if (periodo == periodo_MP && periodo_MP > periodo_final_PE_DECOMP) {//Atualiza com info de pre-config do MP

						for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

							if (dados_MP.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(AttVetorReservatorio_volume_minimo) > 0) {
								double valor = dados_MP.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getElementoVetor(AttVetorReservatorio_volume_minimo, periodo, double());
								a_dados.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).setElemento(AttVetorReservatorio_volume_minimo, periodo, valor);
							}//if (dados_MP.vetorHidreletrica.at(idHidreletrica).vetorReservatorio.at(IdReservatorio_1).getSizeVetor(AttVetorReservatorio_volume_minimo) > 0) {

						}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

					}//if (periodo == periodo_MP) {

				}//for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

			}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

		}//if (dadosPreConfig_reservatorio_operacional) {

		/////////////////////////////////////////////////////////////////////////////
		//HIDRELETRICA_AttVetorPremissa_PorPeriodo
		/////////////////////////////////////////////////////////////////////////////

		if (dadosPreConfig_hidreletrica_premissa) {

			if (!dadosPreConfig_horizonte_estudo)
				throw std::invalid_argument("Deve ser instanciado o horizonte_estudo_MP com DADOS_AttVetorOperacional_PorPeriodo.csv em diretorio: " + a_diretorio);

			const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
			const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

			const SmartEnupla<Periodo, IdEstagio> horizonte_estudo_MP = dados_MP.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());

			for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

					if (periodo < periodo_MP)//Evita percorrer todo o horizonte_estudo_MP
						break;

					/////////

					if (periodo == periodo_MP && periodo_MP > periodo_final_PE_DECOMP) {//Atualiza com info de pre-config do MP

						for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

							if (dados_MP.vetorHidreletrica.at(idHidreletrica).getSizeVetor(AttVetorHidreletrica_canal_fuga_medio) > 0) {
								double valor = dados_MP.vetorHidreletrica.at(idHidreletrica).getElementoVetor(AttVetorHidreletrica_canal_fuga_medio, periodo, double());
								a_dados.vetorHidreletrica.at(idHidreletrica).setElemento(AttVetorHidreletrica_canal_fuga_medio, periodo, valor);
							}//if (dados_MP.vetorHidreletrica.at(idHidreletrica).getSizeVetor(AttVetorHidreletrica_canal_fuga_medio) > 0) {

						}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

					}//if (periodo == periodo_MP) {

				}//for (Periodo periodo_MP = horizonte_estudo_MP.getIteradorInicial(); periodo_MP <= horizonte_estudo_MP.getIteradorFinal(); horizonte_estudo_MP.incrementarIterador(periodo_MP)) {

			}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

		}//if (dadosPreConfig_hidreletrica_premissa) {


	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_valores_periodos_horizonte_expandido_com_DadosEntradaMP_PRECONFIG: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_valores_com_DadosEntradaPD_PRECONFIG(Dados& a_dados, std::string a_diretorio) {

	try {

		//*************************************************************************************************************************************************
		// Premissa:
		//Informação Operacional pre-Config PD (valores absolutos) -> entra direito no Att do problema CP
		//Informação Premissa pre-Config PD (valores p.u) -> Aplica modulação PD na previsão CP
		// 
		// Condição: periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo() (e.g. um periodo_PD horário não sobreescreve informação a um periodo semanal)
		// 
		// *********************************
		// Restrições elétricas/hidráulicas
		// Nos períodos com informação PD -> Somente deixa as restrições PD (abre os limites das restrições do CP existentes que vem do DC)
		//*************************************************************************************************************************************************


		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());

		const Periodo periodo_final_PE_DECOMP = horizonte_otimizacao.at(horizonte_estudo.at(get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados)));

		Dados dados_PD;

		EntradaSaidaDados entradaSaidaDados;

		entradaSaidaDados.setDiretorioEntrada(a_diretorio);

		//****************************************
		//Arquivos Demanda e Usinas não Simuladas
		//****************************************
		
		//Arquivos operacional: Valor absoluto das variáveis
		bool dadosPreConfig_submercado_operacional         = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("SUBMERCADO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_usina_nao_simulada_operacional = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("SUBMERCADO_USINA_NAO_SIMULADA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m2);

		//Arquivos premissa: Modulação em p.u (shaped) das variáveis
		bool dadosPreConfig_submercado_premissa            = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("SUBMERCADO_AttMatrizPremissa_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_usina_nao_simulada_premissa    = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("SUBMERCADO_USINA_NAO_SIMULADA_AttMatrizPremissa_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m2);

		if(dadosPreConfig_submercado_operacional && dadosPreConfig_submercado_premissa){ throw std::invalid_argument("Encontrado arquivo operacional e arquivo premissa da demanda, selecionar apenas um deles em: " + a_diretorio);}
		if(dadosPreConfig_usina_nao_simulada_operacional && dadosPreConfig_usina_nao_simulada_premissa){ throw std::invalid_argument("Encontrado arquivo operacional e arquivo premissa das usinas nao simuladas, selecionar apenas um deles em: " + a_diretorio);}

		//****************************************
		//Arquivo Intercambio
		//****************************************
		bool dadosPreConfig_intercambio_attComum_operacional = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("INTERCAMBIO_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m1);

		//****************************************
		//Arquivos Restrições Elétricas
		//****************************************
		bool is_carregar_PD_restricoes_eletricas = false;
		bool dadosPreConfig_restricao_eletrica_attComum_operacional                   = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("RESTRICAO_ELETRICA_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_restricao_eletrica_attMatriz_operacional                  = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("RESTRICAO_ELETRICA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_restricao_eletrica_elemento_sistema_attComum_operacional  = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("RESTRICAO_ELETRICA_ELEMENTO_SISTEMA_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m2);
		bool dadosPreConfig_restricao_eletrica_elemento_sistema_attMatriz_operacional = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("RESTRICAO_ELETRICA_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m2);
		
		if(dadosPreConfig_restricao_eletrica_attComum_operacional && dadosPreConfig_restricao_eletrica_attMatriz_operacional && dadosPreConfig_restricao_eletrica_elemento_sistema_attComum_operacional && dadosPreConfig_restricao_eletrica_elemento_sistema_attMatriz_operacional)
			is_carregar_PD_restricoes_eletricas = true;
		else if(!dadosPreConfig_restricao_eletrica_attComum_operacional && !dadosPreConfig_restricao_eletrica_attMatriz_operacional && !dadosPreConfig_restricao_eletrica_elemento_sistema_attComum_operacional && !dadosPreConfig_restricao_eletrica_elemento_sistema_attMatriz_operacional)
			is_carregar_PD_restricoes_eletricas = false;
		else if (!dadosPreConfig_restricao_eletrica_attComum_operacional)
			throw std::invalid_argument("Tentativa de incluir restricoes_eletricas em dadosPreConfig_PD, falta arquivo: RESTRICAO_ELETRICA_AttComumOperacional");
		else if (!dadosPreConfig_restricao_eletrica_attComum_operacional)
			throw std::invalid_argument("Tentativa de incluir restricoes_eletricas em dadosPreConfig_PD, falta arquivo: RESTRICAO_ELETRICA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga");
		else if (!dadosPreConfig_restricao_eletrica_elemento_sistema_attComum_operacional)
			throw std::invalid_argument("Tentativa de incluir restricoes_eletricas em dadosPreConfig_PD, falta arquivo: RESTRICAO_ELETRICA_ELEMENTO_SISTEMA_AttComumOperacional");
		else if (!dadosPreConfig_restricao_eletrica_elemento_sistema_attMatriz_operacional)
			throw std::invalid_argument("Tentativa de incluir restricoes_eletricas em dadosPreConfig_PD, falta arquivo: RESTRICAO_ELETRICA_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga");

		//****************************************
		//Arquivos Restrições Hidráulicas
		//****************************************
		bool is_carregar_PD_restricoes_hidraulicas = false;
		bool dadosPreConfig_restricao_hidraulica_attComum_operacional                   = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("RESTRICAO_OPERATIVA_UHE_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_restricao_hidraulica_attMatriz_operacional                  = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("RESTRICAO_OPERATIVA_UHE_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_restricao_hidraulica_elemento_sistema_attComum_operacional  = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("RESTRICAO_OPERATIVA_UHE_ELEMENTO_SISTEMA_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m2);
		bool dadosPreConfig_restricao_hidraulica_elemento_sistema_attMatriz_operacional = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("RESTRICAO_OPERATIVA_UHE_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m2);

		if (dadosPreConfig_restricao_hidraulica_attComum_operacional && dadosPreConfig_restricao_hidraulica_attMatriz_operacional && dadosPreConfig_restricao_hidraulica_elemento_sistema_attComum_operacional && dadosPreConfig_restricao_hidraulica_elemento_sistema_attMatriz_operacional)
			is_carregar_PD_restricoes_hidraulicas = true;
		else if (!dadosPreConfig_restricao_hidraulica_attComum_operacional && !dadosPreConfig_restricao_hidraulica_attMatriz_operacional && !dadosPreConfig_restricao_hidraulica_elemento_sistema_attComum_operacional && !dadosPreConfig_restricao_hidraulica_elemento_sistema_attMatriz_operacional)
			is_carregar_PD_restricoes_hidraulicas = false;
		else if (!dadosPreConfig_restricao_hidraulica_attComum_operacional)
			throw std::invalid_argument("Tentativa de incluir restricoes_hidraulicas em dadosPreConfig_PD, falta arquivo: RESTRICAO_OPERATIVA_UHE_AttComumOperacional");
		else if (!dadosPreConfig_restricao_hidraulica_attComum_operacional)
			throw std::invalid_argument("Tentativa de incluir restricoes_hidraulicas em dadosPreConfig_PD, falta arquivo: RESTRICAO_OPERATIVA_UHE_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga");
		else if (!dadosPreConfig_restricao_hidraulica_elemento_sistema_attComum_operacional)
			throw std::invalid_argument("Tentativa de incluir restricoes_hidraulicas em dadosPreConfig_PD, falta arquivo: RESTRICAO_OPERATIVA_UHE_ELEMENTO_SISTEMA_AttComumOperacional");
		else if (!dadosPreConfig_restricao_hidraulica_elemento_sistema_attMatriz_operacional)
			throw std::invalid_argument("Tentativa de incluir restricoes_hidraulicas em dadosPreConfig_PD, falta arquivo: RESTRICAO_OPERATIVA_UHE_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga");

		//****************************************
		//Arquivos Contratos
		//****************************************
		bool is_carregar_PD_contratos = false;
		bool dadosPreConfig_contratos_attComum_operacional = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("CONTRATO_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_contratos_attMatriz_operacional = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("CONTRATO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m1);

		if (dadosPreConfig_contratos_attComum_operacional && dadosPreConfig_contratos_attMatriz_operacional)
			is_carregar_PD_contratos = true;

		//****************************************
		//Arquivos Demanda Especial
		//****************************************
		bool is_carregar_PD_demanda_especial = false;
		bool dadosPreConfig_demanda_especial_attComum_operacional = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("DEMANDA_ESPECIAL_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_demanda_especial_attMatriz_operacional = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("DEMANDA_ESPECIAL_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m1);

		if (dadosPreConfig_demanda_especial_attComum_operacional && dadosPreConfig_demanda_especial_attMatriz_operacional)
			is_carregar_PD_demanda_especial = true;

		//****************************************
		//Arquivos Reserva Potencia
		//****************************************
		bool is_carregar_PD_reserva_potencia = false;
		bool dadosPreConfig_reserva_potencia_attComum_operacional = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("RESERVA_POTENCIA_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_reserva_potencia_attMatriz_operacional = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("RESERVA_POTENCIA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_reserva_potencia_elemento_sistema_attComum_operacional = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("RESERVA_POTENCIA_ELEMENTO_SISTEMA_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m2);
		bool dadosPreConfig_reserva_potencia_elemento_sistema_attMatriz_operacional = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("RESERVA_POTENCIA_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m2);

		if (dadosPreConfig_reserva_potencia_attComum_operacional && dadosPreConfig_reserva_potencia_attMatriz_operacional && dadosPreConfig_reserva_potencia_elemento_sistema_attComum_operacional && dadosPreConfig_reserva_potencia_elemento_sistema_attMatriz_operacional)
			is_carregar_PD_reserva_potencia = true;

		/*
		//****************************************
		//Arquivos Cota R11
		//****************************************
		bool is_carregar_PD_cota_r11 = false;
		bool dadosPreConfig_cota_r11_attComum_operacional = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("COTAR11_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_cota_r11_attVetor_operacional = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("COTAR11_AttVetorOperacional_PorPeriodo.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_cota_r11_attVetor_polinomio = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("COTAR11_AttVetorPolinomio_PorPeriodo.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_cota_r11_attVetor_cota_passada = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("COTAR11_COTAPASSADA_AttVetorOperacional_PorPeriodo.csv", dados_PD, TipoAcessoInstancia_m1);

		if (dadosPreConfig_cota_r11_attComum_operacional && dadosPreConfig_cota_r11_attVetor_operacional && dadosPreConfig_cota_r11_attVetor_polinomio && dadosPreConfig_cota_r11_attVetor_cota_passada)
			is_carregar_PD_cota_r11 = true;
		*/

		//****************************************
		//Arquivos Termeletrica
		//****************************************
		bool is_carregar_PD_termeletricas = false;
		bool dadosPreConfig_termeletrica_attComum_operacional     = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("TERMELETRICA_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m1);
		
		bool dadosPreConfig_termeletrica_comando_attMatriz_operacional = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("TERMELETRICA_COMANDO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m1);

		bool dadosPreConfig_unidade_termeletrica_attComum_operacional = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("TERMELETRICA_UNIDADE_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m2);
		bool dadosPreConfig_unidade_termeletrica_attMatriz_operacional = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("TERMELETRICA_UNIDADE_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m2);
		bool dadosPreConfig_unidade_termeletrica_attVetor_operacional = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("TERMELETRICA_UNIDADE_AttVetorOperacional_PorPeriodo.csv", dados_PD, TipoAcessoInstancia_m2);
		bool dadosPreConfig_unidade_termeletrica_attVetor_operacional_int = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("TERMELETRICA_UNIDADE_AttVetorOperacional_PorInteiro.csv", dados_PD, TipoAcessoInstancia_m2);


		if (dadosPreConfig_termeletrica_attComum_operacional && dadosPreConfig_termeletrica_comando_attMatriz_operacional && dadosPreConfig_unidade_termeletrica_attComum_operacional \
			&& dadosPreConfig_unidade_termeletrica_attMatriz_operacional && dadosPreConfig_unidade_termeletrica_attVetor_operacional && dadosPreConfig_unidade_termeletrica_attVetor_operacional_int)
			is_carregar_PD_termeletricas = true;

		//****************************************
		//Arquivos Hidreletrica
		//****************************************
		bool is_carregar_PD_hidreletricas = false;

		//hidrelétrica
		bool dadosPreConfig_hidreletrica_attComum_operacional = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("HIDRELETRICA_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_hidreletrica_attMatriz_operacional = entradaSaidaDados.carregarArquivoCSV_AttMatriz_seExistir("HIDRELETRICA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv", dados_PD, TipoAcessoInstancia_m1);
		bool dadosPreConfig_hidreletrica_attVetor_operacional = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("HIDRELETRICA_AttVetorOperacional_PorPeriodo.csv", dados_PD, TipoAcessoInstancia_m1);

		//reservatório
		bool dadosPreConfig_hidreletrica_reservatorio_attComum_operacional = entradaSaidaDados.carregarArquivoCSV_AttComum_seExistir("HIDRELETRICA_RESERVATORIO_AttComumOperacional.csv", dados_PD, TipoAcessoInstancia_m2);
		bool dadosPreConfig_hidreletrica_reservatorio_attVetor_operacional = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("HIDRELETRICA_RESERVATORIO_AttVetorOperacional_PorPeriodo.csv", dados_PD, TipoAcessoInstancia_m2);

		//defluência
		bool dadosPreConfig_hidreletrica_defluencia_attVetor_operacional = entradaSaidaDados.carregarArquivoCSV_AttVetor_seExistir("HIDRELETRICA_DEFLUENCIA_AttVetorOperacional_PorPeriodo.csv", dados_PD, TipoAcessoInstancia_m2);

		if (dadosPreConfig_hidreletrica_attComum_operacional && dadosPreConfig_hidreletrica_attMatriz_operacional && dadosPreConfig_hidreletrica_attVetor_operacional \
			&& dadosPreConfig_hidreletrica_reservatorio_attComum_operacional && dadosPreConfig_hidreletrica_reservatorio_attVetor_operacional && dadosPreConfig_hidreletrica_defluencia_attVetor_operacional)
			is_carregar_PD_hidreletricas = true;


		//**********************************************************************

		//////////////////////////////////////////////////////////////
		//SUBMERCADO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//////////////////////////////////////////////////////////////

		if (dadosPreConfig_submercado_operacional) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: SUBMERCADO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;

				const IdSubmercado idSubmercadoIni_PD = dados_PD.getMenorId(IdSubmercado());
				const IdSubmercado idSubmercadoOut_PD = dados_PD.getIdOut(IdSubmercado());
				//const IdSubmercado maiorIdSubmercado_PD = dados_PD.getMaiorId(IdSubmercado());

				//Validação do horizonte_informacao_PD_pre_config

				for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

					std::vector<Periodo> periodos_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getMatriz(AttMatrizSubmercado_demanda, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

					const Periodo periodo_inicial_PD = periodos_PD.at(0);
					const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

					validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

				}//for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

				///////////////////////////////////

				std::vector<Periodo> periodos_PD = dados_PD.vetorSubmercado.at(idSubmercadoIni_PD).getMatriz(AttMatrizSubmercado_demanda, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

				SmartEnupla<Periodo, bool> horizonte_info_PD;

				for (int pos = 0; pos < int(periodos_PD.size()); pos++)
					horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

				const Periodo periodo_inicial_PD = horizonte_info_PD.getIteradorInicial();
				const Periodo periodo_final_PD = horizonte_info_PD.getIteradorFinal();

				///////////////////////////////////////
				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

						const double sobreposicao = periodo.sobreposicao(periodo_PD);

						if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

								const IdPatamarCarga maiorIdPatamarCarga_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getIterador2Final(AttMatrizSubmercado_demanda, periodo_PD, IdPatamarCarga());

								if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
									throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD ");

								const double demanda_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getElementoMatriz(AttMatrizSubmercado_demanda, periodo_PD, maiorIdPatamarCarga, double());
								a_dados.vetorSubmercado.at(idSubmercado_PD).setElemento(AttMatrizSubmercado_demanda, periodo, maiorIdPatamarCarga, demanda_PD);

							}//for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

						}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

					}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			}//try {
			catch (const std::exception& erro) { throw std::invalid_argument("Erro dadosPreConfig_submercado_operacional: \n" + std::string(erro.what())); }

		}//if (dadosPreConfig_submercado_operacional) {

		/////////////////////////////////////////////////////////////////////////////
		//SUBMERCADO_USINA_NAO_SIMULADA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		/////////////////////////////////////////////////////////////////////////////

		if (dadosPreConfig_usina_nao_simulada_operacional) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: SUBMERCADO_USINA_NAO_SIMULADA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;

				const IdSubmercado idSubmercadoIni_PD = dados_PD.getMenorId(IdSubmercado());
				const IdSubmercado idSubmercadoOut_PD = dados_PD.getIdOut(IdSubmercado());

				//Validação do horizonte_informacao_PD_pre_config

				for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

					const IdUsinaNaoSimulada idUsinaNaoSimuladaIni_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getMenorId(IdUsinaNaoSimulada());
					const IdUsinaNaoSimulada idUsinaNaoSimuladaOut_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getIdOut(IdUsinaNaoSimulada());

					for (IdUsinaNaoSimulada idUsinaNaoSimulada_PD = idUsinaNaoSimuladaIni_PD; idUsinaNaoSimulada_PD < idUsinaNaoSimuladaOut_PD; dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada_PD)) {

						std::vector<Periodo> periodos_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_PD).getMatriz(AttMatrizUsinaNaoSimulada_potencia_maxima, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

						const Periodo periodo_inicial_PD = periodos_PD.at(0);
						const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

						validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

					}//for (IdUsinaNaoSimulada idUsinaNaoSimulada_PD = idUsinaNaoSimuladaIni_PD; idUsinaNaoSimulada_PD < idUsinaNaoSimuladaOut_PD; dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada_PD)) {

				}//for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

				///////////////////////////////////

				std::vector<Periodo> periodos_PD = dados_PD.vetorSubmercado.at(idSubmercadoIni_PD).vetorUsinaNaoSimulada.at(dados_PD.vetorSubmercado.at(idSubmercadoIni_PD).getMenorId(IdUsinaNaoSimulada())).getMatriz(AttMatrizUsinaNaoSimulada_potencia_maxima, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

				SmartEnupla<Periodo, bool> horizonte_info_PD;

				for (int pos = 0; pos < int(periodos_PD.size()); pos++)
					horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

				const Periodo periodo_inicial_PD = horizonte_info_PD.getIteradorInicial();
				const Periodo periodo_final_PD = horizonte_info_PD.getIteradorFinal();

				/////////////////////////////////////////

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

						const double sobreposicao = periodo.sobreposicao(periodo_PD);

						if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

								//**********************************************************
								//IdsSubmercados_PD são um subconjunto do IdsSubmercados_CP
								//**********************************************************
								const IdUsinaNaoSimulada idUsinaNaoSimuladaIni = a_dados.vetorSubmercado.at(idSubmercado_PD).getMenorId(IdUsinaNaoSimulada());
								const IdUsinaNaoSimulada idUsinaNaoSimuladaOut = a_dados.vetorSubmercado.at(idSubmercado_PD).getIdOut(IdUsinaNaoSimulada());

								const IdUsinaNaoSimulada idUsinaNaoSimuladaIni_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getMenorId(IdUsinaNaoSimulada());
								const IdUsinaNaoSimulada idUsinaNaoSimuladaOut_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getIdOut(IdUsinaNaoSimulada());

								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Podem existir diferenças nos Ids entre o CP e o PD, portanto, vai ser realizada a seguinte lógica:
								//Zera para o período P a info de todos os Ids_CP, depois cria novos Ids_CP (se necessário) e atualiza a info com os Ids_PD
								/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								///////////////////////////////////////////////////////////////////////////////
								//1. Zera a informação dos idsCP (para o periodo avaliado)
								///////////////////////////////////////////////////////////////////////////////

								for (IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimuladaIni; idUsinaNaoSimulada < idUsinaNaoSimuladaOut; a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada)) {

									//Premissa: IdUsinaNaoSimulada_EOL vai ter constrained_off = true
									if (idUsinaNaoSimulada == IdUsinaNaoSimulada_EOL)
										a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setAtributo(AttComumUsinaNaoSimulada_constrained_off, true);

									//Zera a info do CP
									for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
										const double valor = 0.0;
										//////////////////////////////////////////
										//AttMatrizUsinaNaoSimulada_potencia_minima
										//////////////////////////////////////////
										a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_minima, periodo, idPatamarCarga, valor);

										//////////////////////////////////////////
										//AttMatrizUsinaNaoSimulada_potencia_maxima
										//////////////////////////////////////////
										a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, idPatamarCarga, valor);
									}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

								}//for (IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimuladaIni; idUsinaNaoSimulada < idUsinaNaoSimuladaOut; a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada)) {

								///////////////////////////////////////////////////////////////////////////////
								//2. Atualiza info do CP com o PD
								// Percorre os Ids_PD (se necessário cria novos Ids_CP) e atualiza a informação
								///////////////////////////////////////////////////////////////////////////////

								for (IdUsinaNaoSimulada idUsinaNaoSimulada_PD = idUsinaNaoSimuladaIni_PD; idUsinaNaoSimulada_PD < idUsinaNaoSimuladaOut_PD; dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada_PD)) {

									const IdPatamarCarga maiorIdPatamarCarga_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_PD).getIterador2Final(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo_PD, IdPatamarCarga());

									if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
										throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD ");

									//Instancia Ids_CP que não existem
									if (!a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.isInstanciado(idUsinaNaoSimulada_PD)) {

										UsinaNaoSimulada usinaNaoSimulada;

										usinaNaoSimulada.setAtributo(AttComumUsinaNaoSimulada_idUsinaNaoSimulada, idUsinaNaoSimulada_PD);

										a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.add(usinaNaoSimulada);

										SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

										for (Periodo periodo_aux = horizonte_estudo.getIteradorInicial(); periodo_aux <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo_aux)) {

											const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo_aux);
											matriz_zero.setElemento(periodo_aux, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

										}//for (Periodo periodo_aux = horizonte_estudo.getIteradorInicial(); periodo_aux <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo_aux)) {

										/////////////////////////////////////

										a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_PD).setMatriz(AttMatrizUsinaNaoSimulada_potencia_minima, matriz_zero);
										a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_PD).setMatriz(AttMatrizUsinaNaoSimulada_potencia_maxima, matriz_zero);


									}//if (!a_dados.vetorSubmercado.at(idSubmercado).vetorUsinaNaoSimulada.isInstanciado(idUsinaNaoSimulada)) {

									//Atualiza info CP com PD
									for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

										//////////////////////////////////////////
										//AttMatrizUsinaNaoSimulada_potencia_minima
										//////////////////////////////////////////
										double valor = dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_PD).getElementoMatriz(AttMatrizUsinaNaoSimulada_potencia_minima, periodo_PD, idPatamarCarga, double());
										a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_PD).setElemento(AttMatrizUsinaNaoSimulada_potencia_minima, periodo, idPatamarCarga, valor);

										//////////////////////////////////////////
										//AttMatrizUsinaNaoSimulada_potencia_maxima
										//////////////////////////////////////////
										valor = dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_PD).getElementoMatriz(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo_PD, idPatamarCarga, double());
										a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_PD).setElemento(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, idPatamarCarga, valor);

									}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

								}//for (IdUsinaNaoSimulada idUsinaNaoSimulada_PD = idUsinaNaoSimuladaIni_PD; idUsinaNaoSimulada_PD < idUsinaNaoSimuladaOut_PD; dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada_PD)) {

							}//for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

						}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

					}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			}//try {
			catch (const std::exception& erro) { throw std::invalid_argument("Erro dadosPreConfig_usina_nao_simulada_operacional: \n" + std::string(erro.what())); }

		}//if (dadosPreConfig_usina_nao_simulada_operacional) {

		//////////////////////////////////////////////////////////////
		//SUBMERCADO_AttMatrizPremissa_PorPeriodoPorIdPatamarCarga
		//////////////////////////////////////////////////////////////

		if (dadosPreConfig_submercado_premissa) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: SUBMERCADO_AttMatrizPremissa_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;

				const IdSubmercado idSubmercadoIni_PD = dados_PD.getMenorId(IdSubmercado());
				const IdSubmercado idSubmercadoOut_PD = dados_PD.getIdOut(IdSubmercado());

				//Validação do horizonte_informacao_PD_pre_config

				for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

					std::vector<Periodo> periodos_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getMatriz(AttMatrizSubmercado_percentual_variacao_patamar_carga, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

					const Periodo periodo_inicial_PD = periodos_PD.at(0);
					const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

					validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

				}//for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

				///////////////////////////////////

				std::vector<Periodo> periodos_PD = dados_PD.vetorSubmercado.at(idSubmercadoIni_PD).getMatriz(AttMatrizSubmercado_percentual_variacao_patamar_carga, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

				SmartEnupla<Periodo, bool> horizonte_info_PD;

				for (int pos = 0; pos < int(periodos_PD.size()); pos++)
					horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

				const Periodo periodo_inicial_PD = horizonte_info_PD.getIteradorInicial();
				const Periodo periodo_final_PD = horizonte_info_PD.getIteradorFinal();

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

						const double sobreposicao = periodo.sobreposicao(periodo_PD);

						if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

								//////////////////////////////////////////////////////////////
								//Identifica o periodo_deck para mapear o valor_medio_deck

								double valor_medio = -99999.0;

								for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

									const double sobreposicao_com_deck = periodo.sobreposicao(periodo_deck);

									if (sobreposicao_com_deck == 1.0) {
										valor_medio = demanda_media_deck.at(idSubmercado_PD).at(periodo_deck);
										break;
									}

								}//for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

								if (valor_medio == -99999.0)
									throw std::invalid_argument("dadosPreConfig_submercado_premissa - Nao encontrada sobreposicao com o horizonte do deck do periodo: " + getString(periodo));

								//////////////////////////////////////////////////////////////

								const IdPatamarCarga maiorIdPatamarCarga_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getIterador2Final(AttMatrizSubmercado_percentual_variacao_patamar_carga, periodo_PD, IdPatamarCarga());

								if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
									throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");

								const double pu_demanda = dados_PD.vetorSubmercado.at(idSubmercado_PD).getElementoMatriz(AttMatrizSubmercado_percentual_variacao_patamar_carga, periodo_PD, maiorIdPatamarCarga, double());
								a_dados.vetorSubmercado.at(idSubmercado_PD).setElemento(AttMatrizSubmercado_demanda, periodo, maiorIdPatamarCarga, pu_demanda * valor_medio);

							}//for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

						}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

					}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			}//try {
			catch (const std::exception& erro) { throw std::invalid_argument("Erro dadosPreConfig_submercado_premissa: \n" + std::string(erro.what())); }

		}//if (dadosPreConfig_submercado_premissa) {

		//////////////////////////////////////////////////////////////////////////////
		//SUBMERCADO_USINA_NAO_SIMULADA_AttMatrizPremissa_PorPeriodoPorIdPatamarCarga
		//////////////////////////////////////////////////////////////////////////////

		if (dadosPreConfig_usina_nao_simulada_premissa) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: SUBMERCADO_USINA_NAO_SIMULADA_AttMatrizPremissa_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;

				const IdSubmercado idSubmercadoIni_PD = dados_PD.getMenorId(IdSubmercado());
				const IdSubmercado idSubmercadoOut_PD = dados_PD.getIdOut(IdSubmercado());

				//Validação do horizonte_informacao_PD_pre_config

				for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

					const IdUsinaNaoSimulada idUsinaNaoSimuladaIni_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getMenorId(IdUsinaNaoSimulada());
					const IdUsinaNaoSimulada idUsinaNaoSimuladaOut_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getIdOut(IdUsinaNaoSimulada());

					for (IdUsinaNaoSimulada idUsinaNaoSimulada_PD = idUsinaNaoSimuladaIni_PD; idUsinaNaoSimulada_PD < idUsinaNaoSimuladaOut_PD; dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada_PD)) {

						std::vector<Periodo> periodos_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_PD).getMatriz(AttMatrizUsinaNaoSimulada_percentual_variacao_patamar_carga, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

						const Periodo periodo_inicial_PD = periodos_PD.at(0);
						const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

						validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

					}//for (IdUsinaNaoSimulada idUsinaNaoSimulada_PD = idUsinaNaoSimuladaIni_PD; idUsinaNaoSimulada_PD < idUsinaNaoSimuladaOut_PD; dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada_PD)) {

				}//for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

				///////////////////////////////////

				std::vector<Periodo> periodos_PD = dados_PD.vetorSubmercado.at(idSubmercadoIni_PD).vetorUsinaNaoSimulada.at(dados_PD.vetorSubmercado.at(idSubmercadoIni_PD).getMenorId(IdUsinaNaoSimulada())).getMatriz(AttMatrizUsinaNaoSimulada_percentual_variacao_patamar_carga, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

				SmartEnupla<Periodo, bool> horizonte_info_PD;

				for (int pos = 0; pos < int(periodos_PD.size()); pos++)
					horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

				const Periodo periodo_inicial_PD = horizonte_info_PD.getIteradorInicial();
				const Periodo periodo_final_PD = horizonte_info_PD.getIteradorFinal();

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

						const double sobreposicao = periodo.sobreposicao(periodo_PD);

						if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

								///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
								//Podem existir um grupo de IdsCP que vão ser modulados com um mesmo IdPD (ex: EOL e EOL_gd -> modulação da EOL)
								//1. Zerar as fontes do IdsCP
								//2. Atualiza o valor realizando um somatório

								///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

								const IdUsinaNaoSimulada idUsinaNaoSimuladaIni = a_dados.vetorSubmercado.at(idSubmercado_PD).getMenorId(IdUsinaNaoSimulada());
								const IdUsinaNaoSimulada idUsinaNaoSimuladaOut = a_dados.vetorSubmercado.at(idSubmercado_PD).getIdOut(IdUsinaNaoSimulada());

								const IdUsinaNaoSimulada idUsinaNaoSimuladaIni_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getMenorId(IdUsinaNaoSimulada());
								const IdUsinaNaoSimulada idUsinaNaoSimuladaOut_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).getIdOut(IdUsinaNaoSimulada());

								///////////////////////////////////////////////////////////////////////////////
								//1. Zera a informação dos idsCP (para o periodo avaliado)
								///////////////////////////////////////////////////////////////////////////////

								for (IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimuladaIni; idUsinaNaoSimulada < idUsinaNaoSimuladaOut; a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada)) {

									//Zera a info do CP
									for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
										const double valor = 0.0;
										//////////////////////////////////////////
										//AttMatrizUsinaNaoSimulada_potencia_minima
										//////////////////////////////////////////
										a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_minima, periodo, idPatamarCarga, valor);

										//////////////////////////////////////////
										//AttMatrizUsinaNaoSimulada_potencia_maxima
										//////////////////////////////////////////
										a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, idPatamarCarga, valor);
									}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

								}//for (IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimuladaIni; idUsinaNaoSimulada < idUsinaNaoSimuladaOut; a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada)) {

								///////////////////////////////////////////////////////////////////////////////
								//2. Atualiza info do CP com o PD
								// Se não existe a modulação PD para uma geração CP -> throw exceção
								// (exceto para EOL_MMGD / PCT_MMGD / PCH_MMGD 
								//  alocadas com a modulação da EOL / PCT / PCH respectivamente)
								///////////////////////////////////////////////////////////////////////////////

								for (IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimuladaIni; idUsinaNaoSimulada < idUsinaNaoSimuladaOut; a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada)) {

									//////////////////////////////////////////////////////////////
									//Identifica o periodo_deck para mapear o valor_medio_deck

									double valor_medio = -99999.0;

									for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

										const double sobreposicao_com_deck = periodo.sobreposicao(periodo_deck);

										if (sobreposicao_com_deck == 1.0) {
											valor_medio = geracao_usina_nao_simulada_media_deck.at(idSubmercado_PD).at(idUsinaNaoSimulada).at(periodo_deck);
											break;
										}

									}//for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

									if (valor_medio == -99999.0)
										throw std::invalid_argument("dadosPreConfig_usina_nao_simulada_premissa - Nao encontrada sobreposicao com o horizonte do deck do periodo: " + getString(periodo));

									//////////////////////////////////////////////////////////////

									const IdPatamarCarga maiorIdPatamarCarga_PD = dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimuladaIni_PD).getIterador2Final(AttMatrizUsinaNaoSimulada_percentual_variacao_patamar_carga, periodo_PD, IdPatamarCarga());

									if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
										throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");


									IdUsinaNaoSimulada idUsinaNaoSimulada_PD = IdUsinaNaoSimulada_Nenhum;

									if (dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.isInstanciado(idUsinaNaoSimulada))
										idUsinaNaoSimulada_PD = idUsinaNaoSimulada;
									else if (idUsinaNaoSimulada == IdUsinaNaoSimulada_EOL_MMGD && dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.isInstanciado(IdUsinaNaoSimulada_EOL))
										idUsinaNaoSimulada_PD = IdUsinaNaoSimulada_EOL;
									else if (idUsinaNaoSimulada == IdUsinaNaoSimulada_PCT_MMGD && dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.isInstanciado(IdUsinaNaoSimulada_PCT))
										idUsinaNaoSimulada_PD = IdUsinaNaoSimulada_PCT;
									else if (idUsinaNaoSimulada == IdUsinaNaoSimulada_PCH_MMGD && dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.isInstanciado(IdUsinaNaoSimulada_PCH))
										idUsinaNaoSimulada_PD = IdUsinaNaoSimulada_PCH;
									else
										throw std::invalid_argument("Nao carregada informacao PD da modulacao para o idUsinaNaoSimulada: " + getString(idUsinaNaoSimulada));

									const double pu_geracao = dados_PD.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada_PD).getElementoMatriz(AttMatrizUsinaNaoSimulada_percentual_variacao_patamar_carga, periodo_PD, maiorIdPatamarCarga, double());
									const double valor_anterior = a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).getElementoVetor(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, maiorIdPatamarCarga, double());
									const double valor_novo = valor_anterior + pu_geracao * valor_medio;

									a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_minima, periodo, maiorIdPatamarCarga, valor_novo);
									a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.at(idUsinaNaoSimulada).setElemento(AttMatrizUsinaNaoSimulada_potencia_maxima, periodo, maiorIdPatamarCarga, valor_novo);


								}//for (IdUsinaNaoSimulada idUsinaNaoSimulada = idUsinaNaoSimuladaIni; idUsinaNaoSimulada < idUsinaNaoSimuladaOut; a_dados.vetorSubmercado.at(idSubmercado_PD).vetorUsinaNaoSimulada.incr(idUsinaNaoSimulada)) {

							}//for (IdSubmercado idSubmercado_PD = idSubmercadoIni_PD; idSubmercado_PD < idSubmercadoOut_PD; dados_PD.vetorSubmercado.incr(idSubmercado_PD)) {

						}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

					}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			}//try {
			catch (const std::exception& erro) { throw std::invalid_argument("Erro dadosPreConfig_usina_nao_simulada_premissa: \n" + std::string(erro.what())); }

		}//if (dadosPreConfig_usina_nao_simulada_premissa) {

		//////////////////////////////////////////////////////////////////////////////
		//TERMELETRICA
		//////////////////////////////////////////////////////////////////////////////

		if (is_carregar_PD_termeletricas) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: TERMELETRICA_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: TERMELETRICA_COMANDO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: TERMELETRICA_UNIDADE_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: TERMELETRICA_UNIDADE_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: TERMELETRICA_UNIDADE_AttVetorOperacional_PorInteiro.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: TERMELETRICA_UNIDADE_AttVetorOperacional_PorPeriodo.csv..." << std::endl;

				//*******************************************************************
				//   Instancia termelétricas PD no CP
				//   Testa se a termelétrica existe no CP. Caso contrário, o instancia com valores default
				//   Depois atualiza estes valores com a sobreposição dos periodos_CP e periodos_PD
				//  No horizonte_CP mantém a informação da Termelétrica na idUnidadeUTE_1
				//*******************************************************************

				const IdTermeletrica idTermeletricaIni_CP = a_dados.getMenorId(IdTermeletrica());
				const IdTermeletrica idTermeletricaOut_CP = a_dados.getIdOut(IdTermeletrica());

				const IdTermeletrica idTermeletricaIni_PD = dados_PD.getMenorId(IdTermeletrica());
				const IdTermeletrica idTermeletricaOut_PD = dados_PD.getIdOut(IdTermeletrica());

				SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
				SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_menos_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
				SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
					matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));
					matriz_menos_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("min"))));
					matriz_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("max"))));

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				///////////////////////////////////////////////////////////////
				//1. Termelétricas CP que não existem no PD
				// Deixa a informação na idUnidadeUTEIni_CP (deixa vazio as matrizes das Termeletricas)
				// Zera informação da idUnidadeUTEIni_CP no periodo PD
				///////////////////////////////////////////////////////////////

				if (true) {
					//Validação do horizonte_informacao_PD_pre_config
					std::vector<Periodo> periodos_PD = dados_PD.vetorTermeletrica.at(idTermeletricaIni_PD).vetorUnidadeUTE.at(dados_PD.vetorTermeletrica.at(idTermeletricaIni_PD).getMenorId(IdUnidadeUTE())).getMatriz(AttMatrizUnidadeUTE_custo_de_operacao, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

					const Periodo periodo_inicial_PD = periodos_PD.at(0);
					const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

					validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

					SmartEnupla<Periodo, bool> horizonte_info_PD;

					for (int pos = 0; pos < int(periodos_PD.size()); pos++)
						horizonte_info_PD.addElemento(periodos_PD.at(pos), true);


					for (IdTermeletrica idTermeletrica_CP = idTermeletricaIni_CP; idTermeletrica_CP < idTermeletricaOut_CP; a_dados.vetorTermeletrica.incr(idTermeletrica_CP)) {

						if (!dados_PD.vetorTermeletrica.isInstanciado(idTermeletrica_CP)) {

							//AttComum
							a_dados.vetorTermeletrica.at(idTermeletrica_CP).setAtributo(AttComumTermeletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoTermeletrica_por_unidade);

							const IdUnidadeUTE idUnidadeUTEIni_CP = a_dados.vetorTermeletrica.at(idTermeletrica_CP).getMenorId(IdUnidadeUTE());
							const IdUnidadeUTE idUnidadeUTEOut_CP = a_dados.vetorTermeletrica.at(idTermeletrica_CP).getIdOut(IdUnidadeUTE());

							/////////////////////////////////////////////////////////////////////////////////////
							//1.0. Instancia AttVetor necessários para a validação Termelétrica
							/////////////////////////////////////////////////////////////////////////////////////

							for (IdUnidadeUTE idUnidade_CP = idUnidadeUTEIni_CP; idUnidade_CP < idUnidadeUTEOut_CP; a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.incr(idUnidade_CP)) {

								//AttComum
								a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).setAtributo(AttComumUnidadeUTE_nome, a_dados.vetorTermeletrica.at(idTermeletrica_CP).getAtributo(AttComumTermeletrica_nome, std::string()));

								//AttVetor
								if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).getSizeVetor(AttVetorUnidadeUTE_representacao_discreta_producao) == 0)
									a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).setVetor(AttVetorUnidadeUTE_representacao_discreta_producao, SmartEnupla<Periodo, int>(horizonte_estudo, 0));

								//disponibilidade
								if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).getSizeVetor(AttVetorUnidadeUTE_disponibilidade) == 0)
									a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).setVetor(AttVetorUnidadeUTE_disponibilidade, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));


								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									double indisponibilidade_forcada = 0.0;
									double indisponibilidade_programada = 0.0;

									if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeVetor(AttVetorTermeletrica_indisponibilidade_forcada) > 0)
										indisponibilidade_forcada = a_dados.vetorTermeletrica.at(idTermeletrica_CP).getElementoVetor(AttVetorTermeletrica_indisponibilidade_forcada, periodo, double());

									if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeVetor(AttVetorTermeletrica_indisponibilidade_programada) > 0)
										indisponibilidade_programada = a_dados.vetorTermeletrica.at(idTermeletrica_CP).getElementoVetor(AttVetorTermeletrica_indisponibilidade_programada, periodo, double());

									double disponibilidade = (1.0 - indisponibilidade_forcada) * (1.0 - indisponibilidade_programada);

									if (disponibilidade < 0)
										disponibilidade = -disponibilidade;

									if (doubleCompara(0.0, disponibilidade))
										disponibilidade = 0.0;
									else if (doubleCompara(1.0, disponibilidade))
										disponibilidade = 1.0;

									a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).setElemento(AttVetorUnidadeUTE_disponibilidade, periodo, disponibilidade);

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//for (IdUnidadeUTE idUnidade_CP = idUnidadeUTEIni_CP; idUnidade_CP < idUnidadeUTEOut_CP; a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.incr(idUnidade_CP)) {

							/////////////////////////////////////////////////////////////////////////////////////
							//1.1. Zera os atributos em UnidadeUTE no período PD
							/////////////////////////////////////////////////////////////////////////////////////

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

									const double sobreposicao = periodo.sobreposicao(periodo_PD);

									if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

										const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

										if (maiorIdPatamarCarga != IdPatamarCarga_1)
											throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");

										//Unidades
										for (IdUnidadeUTE idUnidade_CP = idUnidadeUTEIni_CP; idUnidade_CP < idUnidadeUTEOut_CP; a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.incr(idUnidade_CP)) {

											//AttMatriz
											a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).setElemento(AttMatrizUnidadeUTE_custo_de_operacao, periodo, IdPatamarCarga_1, 0.0);
											a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).setElemento(AttMatrizUnidadeUTE_potencia_minima, periodo, IdPatamarCarga_1, 0.0);
											a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).setElemento(AttMatrizUnidadeUTE_potencia_util, periodo, IdPatamarCarga_1, 0.0);

											//AttVetor
											a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).setElemento(AttVetorUnidadeUTE_disponibilidade, periodo, 0.0);
											a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.at(idUnidade_CP).setElemento(AttVetorUnidadeUTE_representacao_discreta_producao, periodo, 0);

										}//for (IdUnidadeUTE idUnidade_CP = idUnidadeUTEIni_CP; idUnidade_CP < idUnidadeUTEOut_CP; a_dados.vetorTermeletrica.at(idTermeletrica_CP).vetorUnidadeUTE.incr(idUnidade_CP)) {

									}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

								}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							/////////////////////////////////////////////////////////////////////////////////////
							//1.2. Vazia as matrizes/vetores em Termeletrica (tudo fica em UnidadeUTE)
							/////////////////////////////////////////////////////////////////////////////////////
							if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeMatriz(AttMatrizTermeletrica_custo_de_operacao) > 0)
								a_dados.vetorTermeletrica.at(idTermeletrica_CP).setMatriz(AttMatrizTermeletrica_custo_de_operacao, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>());

							if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeMatriz(AttMatrizTermeletrica_potencia_minima) > 0)
								a_dados.vetorTermeletrica.at(idTermeletrica_CP).setMatriz(AttMatrizTermeletrica_potencia_minima, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>());

							if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeMatriz(AttMatrizTermeletrica_potencia_maxima) > 0)
								a_dados.vetorTermeletrica.at(idTermeletrica_CP).setMatriz(AttMatrizTermeletrica_potencia_maxima, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>());

							if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeMatriz(AttMatrizTermeletrica_potencia_util) > 0)
								a_dados.vetorTermeletrica.at(idTermeletrica_CP).setMatriz(AttMatrizTermeletrica_potencia_util, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>());

							if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeVetor(AttVetorTermeletrica_indisponibilidade_forcada) > 0)
								a_dados.vetorTermeletrica.at(idTermeletrica_CP).setVetor(AttVetorTermeletrica_indisponibilidade_forcada, SmartEnupla<Periodo, double>());

							if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeVetor(AttVetorTermeletrica_indisponibilidade_programada) > 0)
								a_dados.vetorTermeletrica.at(idTermeletrica_CP).setVetor(AttVetorTermeletrica_indisponibilidade_programada, SmartEnupla<Periodo, double>());

							if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeVetor(AttVetorTermeletrica_disponibilidade) > 0)
								a_dados.vetorTermeletrica.at(idTermeletrica_CP).setVetor(AttVetorTermeletrica_disponibilidade, SmartEnupla<Periodo, double>());

						}//if (!dados_PD.vetorTermeletrica.isInstanciado(idTermeletrica_CP)) {

					}//for (IdTermeletrica idTermeletrica_CP = idTermeletricaIni_CP; idTermeletrica_CP < idTermeletricaOut_CP; a_dados.vetorTermeletrica.incr(idTermeletrica_CP)) {
				
				}//if (true) {

				///////////////////////////////////////////////////////////////
				//2. Termelétricas PD in CP (instancia as unidades do PD no CP)
				///////////////////////////////////////////////////////////////

				if (true) {

					for (IdTermeletrica idTermeletrica_PD = idTermeletricaIni_PD; idTermeletrica_PD < idTermeletricaOut_PD; dados_PD.vetorTermeletrica.incr(idTermeletrica_PD)) {

						const IdUnidadeUTE idUnidadeUTEIni_PD = dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getMenorId(IdUnidadeUTE());
						const IdUnidadeUTE idUnidadeUTEOut_PD = dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getIdOut(IdUnidadeUTE());

						//Validação do horizonte_informacao_PD_pre_config
						std::vector<Periodo> periodos_PD = dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidadeUTEIni_PD).getMatriz(AttMatrizUnidadeUTE_custo_de_operacao, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

						const Periodo periodo_inicial_PD = periodos_PD.at(0);
						const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

						validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

						////////////////////////////////////////
						//Instancia novas termelétricas PD no CP
						////////////////////////////////////////

						bool is_new_termeletrica_in_CP = false;

						if (!a_dados.vetorTermeletrica.isInstanciado(idTermeletrica_PD)) {

							is_new_termeletrica_in_CP = true;

							Termeletrica termeletrica;

							termeletrica.setAtributo(AttComumTermeletrica_idTermeletrica, idTermeletrica_PD);

							termeletrica.setAtributo(AttComumTermeletrica_nome, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getAtributo(AttComumTermeletrica_nome, std::string()));
							termeletrica.setAtributo(AttComumTermeletrica_codigo_usina, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getAtributo(AttComumTermeletrica_codigo_usina, int()));
							termeletrica.setAtributo(AttComumTermeletrica_submercado, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getAtributo(AttComumTermeletrica_submercado, IdSubmercado()));

							a_dados.vetorTermeletrica.add(termeletrica);

						}//if (!a_dados.vetorTermeletrica.isInstanciado(idTermeletrica_PD)) {

						//Atualiza AttComum
						a_dados.vetorTermeletrica.at(idTermeletrica_PD).setAtributo(AttComumTermeletrica_penalidade_violacao_potencia, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getAtributo(AttComumTermeletrica_penalidade_violacao_potencia, double()));
						a_dados.vetorTermeletrica.at(idTermeletrica_PD).setAtributo(AttComumTermeletrica_unidades_simultaneas, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getAtributo(AttComumTermeletrica_unidades_simultaneas, bool()));
						a_dados.vetorTermeletrica.at(idTermeletrica_PD).setAtributo(AttComumTermeletrica_rampa_transicao, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getAtributo(AttComumTermeletrica_rampa_transicao, double()));
						a_dados.vetorTermeletrica.at(idTermeletrica_PD).setAtributo(AttComumTermeletrica_tipo_detalhamento_producao, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getAtributo(AttComumTermeletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoTermeletrica()));

						//potencia_disponivel_comandada

						if (a_dados.vetorTermeletrica.at(idTermeletrica_PD).getAtributo(AttComumTermeletrica_lag_mensal_potencia_disponivel_comandada, int()) > 0 && a_dados.vetorTermeletrica.at(idTermeletrica_PD).getSizeMatriz(AttMatrizTermeletrica_potencia_disponivel_comandada) == 0)
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).setMatriz(AttMatrizTermeletrica_potencia_disponivel_comandada, matriz_zero);

						////////////////////////////////////////
						//Instancia UNIDADES termelétricas no CP
						////////////////////////////////////////

						////////////////////////////////
						//Mapeia o idUnidadeUTEIni_PD na única unidade instanciada no CP (todas por default = IdUnidadeUTE_1). Porém na PD se tem o número da unidade que pode ser diferente de IdUnidadeUTE_1
						//Seta para a unidade do CP o idUnidadeUTE = idUnidadeUTEIni_PD
						const IdUnidadeUTE idUnidadeUTEIni_CP = a_dados.vetorTermeletrica.at(idTermeletrica_PD).getMenorId(IdUnidadeUTE());

						if (!is_new_termeletrica_in_CP && idUnidadeUTEIni_PD != idUnidadeUTEIni_CP) {

							const SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> custo_de_operacao = a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidadeUTEIni_CP).getMatriz(AttMatrizUnidadeUTE_custo_de_operacao, Periodo(), IdPatamarCarga(), double());
							const SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> potencia_minima = a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidadeUTEIni_CP).getMatriz(AttMatrizUnidadeUTE_potencia_minima, Periodo(), IdPatamarCarga(), double());
							const SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> potencia_util = a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidadeUTEIni_CP).getMatriz(AttMatrizUnidadeUTE_potencia_util, Periodo(), IdPatamarCarga(), double());

							const std::string nome = dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidadeUTEIni_PD).getAtributo(AttComumUnidadeUTE_nome, std::string());

							//Remove o idUnidadeUTEIni_CP
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.rem(idUnidadeUTEIni_CP);

							//Cria uma cópia da unidade do CP com o idUnidadeUTE = idUnidadeUTEIni_PD
							UnidadeUTE unidadeUTE;

							unidadeUTE.setAtributo(AttComumUnidadeUTE_idUnidadeUTE, idUnidadeUTEIni_PD);
							unidadeUTE.setAtributo(AttComumUnidadeUTE_nome, nome);

							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.add(unidadeUTE);

							//AttMatriz
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidadeUTEIni_PD).setMatriz(AttMatrizUnidadeUTE_custo_de_operacao, custo_de_operacao);
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidadeUTEIni_PD).setMatriz(AttMatrizUnidadeUTE_potencia_minima, potencia_minima);
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidadeUTEIni_PD).setMatriz(AttMatrizUnidadeUTE_potencia_util, potencia_util);

						}//if (!is_new_termeletrica_in_CP && idUnidadeUTEIni_PD != idUnidadeUTEIni_CP) {

						///////////////////////////////

						for (IdUnidadeUTE idUnidade_PD = idUnidadeUTEIni_PD; idUnidade_PD < idUnidadeUTEOut_PD; dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.incr(idUnidade_PD)) {

							if (!a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.isInstanciado(idUnidade_PD)) {

								UnidadeUTE unidadeUTE;

								unidadeUTE.setAtributo(AttComumUnidadeUTE_idUnidadeUTE, idUnidade_PD);
								a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.add(unidadeUTE);

								//AttMatriz
								a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setMatriz(AttMatrizUnidadeUTE_custo_de_operacao, matriz_zero);
								a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setMatriz(AttMatrizUnidadeUTE_potencia_minima, matriz_zero);
								a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setMatriz(AttMatrizUnidadeUTE_potencia_util, matriz_zero);

							}//if (!a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.isInstanciado(idUnidade_PD)) {

							//AttComum
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setAtributo(AttComumUnidadeUTE_nome, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getAtributo(AttComumUnidadeUTE_nome, std::string()));
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setAtributo(AttComumUnidadeUTE_ramp_up, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getAtributo(AttComumUnidadeUTE_ramp_up, double()));
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setAtributo(AttComumUnidadeUTE_ramp_down, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getAtributo(AttComumUnidadeUTE_ramp_down, double()));
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setAtributo(AttComumUnidadeUTE_min_time_up, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getAtributo(AttComumUnidadeUTE_min_time_up, double()));
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setAtributo(AttComumUnidadeUTE_min_time_down, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getAtributo(AttComumUnidadeUTE_min_time_down, double()));
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setAtributo(AttComumUnidadeUTE_timi_ini, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getAtributo(AttComumUnidadeUTE_timi_ini, double()));
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setAtributo(AttComumUnidadeUTE_power_ini, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getAtributo(AttComumUnidadeUTE_power_ini, double()));

							//Atualiza AttVetor x int				
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setVetor(AttVetorUnidadeUTE_ramp_shutdown, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getVetor(AttVetorUnidadeUTE_ramp_shutdown, int(), double()));
							a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setVetor(AttVetorUnidadeUTE_ramp_turnon, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getVetor(AttVetorUnidadeUTE_ramp_turnon, int(), double()));

							//AttVetor
							if (a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getSizeVetor(AttVetorUnidadeUTE_representacao_discreta_producao) == 0)
								a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setVetor(AttVetorUnidadeUTE_representacao_discreta_producao, SmartEnupla<Periodo, int>(horizonte_estudo, 0));

							//disponibilidade
							//Garante para as idUnidade!= idUnidadeUTEIni_PD que a disponibilidade = 0.0 no horizonte da info DC (dentro do horizonte PD atualiza este vetor para todas as unidades)
							if (a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getSizeVetor(AttVetorUnidadeUTE_disponibilidade) == 0)
								a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setVetor(AttVetorUnidadeUTE_disponibilidade, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));

							if (idUnidade_PD == idUnidadeUTEIni_PD) {//Instancia disponibilidade da UnidadeUTE_1 com a info DC de indisponibilidade_programada e indisponibilidade_forcada da Termelétrica

								for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

									double indisponibilidade_forcada = 0.0;
									double indisponibilidade_programada = 0.0;

									if (a_dados.vetorTermeletrica.at(idTermeletrica_PD).getSizeVetor(AttVetorTermeletrica_indisponibilidade_forcada) > 0)
										indisponibilidade_forcada = a_dados.vetorTermeletrica.at(idTermeletrica_PD).getElementoVetor(AttVetorTermeletrica_indisponibilidade_forcada, periodo, double());

									if (a_dados.vetorTermeletrica.at(idTermeletrica_PD).getSizeVetor(AttVetorTermeletrica_indisponibilidade_programada) > 0)
										indisponibilidade_programada = a_dados.vetorTermeletrica.at(idTermeletrica_PD).getElementoVetor(AttVetorTermeletrica_indisponibilidade_programada, periodo, double());

									double disponibilidade = (1.0 - indisponibilidade_forcada) * (1.0 - indisponibilidade_programada);

									if (disponibilidade < 0)
										disponibilidade = -disponibilidade;

									if (doubleCompara(0.0, disponibilidade))
										disponibilidade = 0.0;
									else if (doubleCompara(1.0, disponibilidade))
										disponibilidade = 1.0;

									a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setElemento(AttVetorUnidadeUTE_disponibilidade, periodo, disponibilidade);

								}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							}//if (idUnidade_PD == idUnidadeUTEIni_PD) {

							//Para usinas GNLs
							//AttMatrizUnidadeUTE_potencia_disponivel_minima/maxima
							if (a_dados.vetorTermeletrica.at(idTermeletrica_PD).getAtributo(AttComumTermeletrica_lag_mensal_potencia_disponivel_comandada, int()) > 0) {

								if (a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getSizeMatriz(AttMatrizUnidadeUTE_potencia_disponivel_minima) == 0)
									a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setMatriz(AttMatrizUnidadeUTE_potencia_disponivel_minima, matriz_zero);

								if (a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getSizeMatriz(AttMatrizUnidadeUTE_potencia_disponivel_maxima) == 0)
									a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setMatriz(AttMatrizUnidadeUTE_potencia_disponivel_maxima, matriz_zero);

							}//if (a_dados.vetorTermeletrica.at(idTermeletrica_PD).getAtributo(AttComumTermeletrica_lag_mensal_potencia_disponivel_comandada, int()) > 0) {

						}//for (IdUnidadeUTE idUnidade_PD = idUnidadeUTEIni_PD; idUnidade_PD < idUnidadeUTEOut_PD; dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.incr(idUnidade_PD)) {


						/////////////////////////////////////////////////////////////////////////////////////
						//2.1. Atualiza matrizes dentro do horizonte PD
						/////////////////////////////////////////////////////////////////////////////////////

						SmartEnupla<Periodo, bool> horizonte_info_PD;

						for (int pos = 0; pos < int(periodos_PD.size()); pos++)
							horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

								const double sobreposicao = periodo.sobreposicao(periodo_PD);

								if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									const IdPatamarCarga maiorIdPatamarCarga_PD = dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidadeUTEIni_PD).getIterador2Final(AttMatrizUnidadeUTE_custo_de_operacao, periodo_PD, IdPatamarCarga());

									if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
										throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");

									//Termelétrica
									//potencia_disponivel_comandada
									if (dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getSizeMatriz(AttMatrizTermeletrica_potencia_disponivel_comandada) > 0)
										a_dados.vetorTermeletrica.at(idTermeletrica_PD).setElemento(AttMatrizTermeletrica_potencia_disponivel_comandada, periodo, IdPatamarCarga_1, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).getElementoMatriz(AttMatrizTermeletrica_potencia_disponivel_comandada, periodo_PD, IdPatamarCarga_1, double()));

									
									//Unidades
									for (IdUnidadeUTE idUnidade_PD = idUnidadeUTEIni_PD; idUnidade_PD < idUnidadeUTEOut_PD; dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.incr(idUnidade_PD)) {

										//AttMatriz
										a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setElemento(AttMatrizUnidadeUTE_custo_de_operacao, periodo, IdPatamarCarga_1, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getElementoMatriz(AttMatrizUnidadeUTE_custo_de_operacao, periodo_PD, IdPatamarCarga_1, double()));
										a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setElemento(AttMatrizUnidadeUTE_potencia_minima, periodo, IdPatamarCarga_1, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getElementoMatriz(AttMatrizUnidadeUTE_potencia_minima, periodo_PD, IdPatamarCarga_1, double()));
										a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setElemento(AttMatrizUnidadeUTE_potencia_util, periodo, IdPatamarCarga_1, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getElementoMatriz(AttMatrizUnidadeUTE_potencia_util, periodo_PD, IdPatamarCarga_1, double()));

										if (dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getSizeMatriz(AttMatrizUnidadeUTE_potencia_disponivel_minima) > 0)
											a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setElemento(AttMatrizUnidadeUTE_potencia_disponivel_minima, periodo, IdPatamarCarga_1, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getElementoMatriz(AttMatrizUnidadeUTE_potencia_disponivel_minima, periodo_PD, IdPatamarCarga_1, double()));

										if (dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getSizeMatriz(AttMatrizUnidadeUTE_potencia_disponivel_maxima) > 0)
											a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setElemento(AttMatrizUnidadeUTE_potencia_disponivel_maxima, periodo, IdPatamarCarga_1, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getElementoMatriz(AttMatrizUnidadeUTE_potencia_disponivel_maxima, periodo_PD, IdPatamarCarga_1, double()));

										//AttVetor
										a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setElemento(AttVetorUnidadeUTE_disponibilidade, periodo, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getElementoVetor(AttVetorUnidadeUTE_disponibilidade, periodo_PD, double()));
										a_dados.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).setElemento(AttVetorUnidadeUTE_representacao_discreta_producao, periodo, dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.at(idUnidade_PD).getElementoVetor(AttVetorUnidadeUTE_representacao_discreta_producao, periodo_PD, int()));

									}//for (IdUnidadeUTE idUnidade_PD = idUnidadeUTEIni_PD; idUnidade_PD < idUnidadeUTEOut_PD; dados_PD.vetorTermeletrica.at(idTermeletrica_PD).vetorUnidadeUTE.incr(idUnidade_PD)) {

								}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

							}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {


					}//for (IdTermeletrica idTermeletrica_PD = idTermeletricaIni_PD; idTermeletrica_PD < idTermeletricaOut_PD; dados_PD.vetorTermeletrica.incr(idTermeletrica_PD)) {

				}//if (true) {

				/////////////////////////////////////////////////////////////////////////////////////
				//3. Esvazia as matrizes/vetores em Termeletrica (tudo fica em UnidadeUTE)
				/////////////////////////////////////////////////////////////////////////////////////

				if (true) {

					for (IdTermeletrica idTermeletrica_CP = idTermeletricaIni_CP; idTermeletrica_CP < idTermeletricaOut_CP; a_dados.vetorTermeletrica.incr(idTermeletrica_CP)) {

						if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeMatriz(AttMatrizTermeletrica_custo_de_operacao) > 0)
							a_dados.vetorTermeletrica.at(idTermeletrica_CP).setMatriz(AttMatrizTermeletrica_custo_de_operacao, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>());

						if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeMatriz(AttMatrizTermeletrica_potencia_minima) > 0)
							a_dados.vetorTermeletrica.at(idTermeletrica_CP).setMatriz(AttMatrizTermeletrica_potencia_minima, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>());

						if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeMatriz(AttMatrizTermeletrica_potencia_maxima) > 0)
							a_dados.vetorTermeletrica.at(idTermeletrica_CP).setMatriz(AttMatrizTermeletrica_potencia_maxima, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>());

						if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeMatriz(AttMatrizTermeletrica_potencia_disponivel_maxima) > 0)
							a_dados.vetorTermeletrica.at(idTermeletrica_CP).setMatriz(AttMatrizTermeletrica_potencia_disponivel_maxima, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>());

						if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeMatriz(AttMatrizTermeletrica_potencia_disponivel_minima) > 0)
							a_dados.vetorTermeletrica.at(idTermeletrica_CP).setMatriz(AttMatrizTermeletrica_potencia_disponivel_minima, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>());

						if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeMatriz(AttMatrizTermeletrica_potencia_util) > 0)
							a_dados.vetorTermeletrica.at(idTermeletrica_CP).setMatriz(AttMatrizTermeletrica_potencia_util, SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>>());

						if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeVetor(AttVetorTermeletrica_indisponibilidade_forcada) > 0)
							a_dados.vetorTermeletrica.at(idTermeletrica_CP).setVetor(AttVetorTermeletrica_indisponibilidade_forcada, SmartEnupla<Periodo, double>());

						if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeVetor(AttVetorTermeletrica_indisponibilidade_programada) > 0)
							a_dados.vetorTermeletrica.at(idTermeletrica_CP).setVetor(AttVetorTermeletrica_indisponibilidade_programada, SmartEnupla<Periodo, double>());

						if (a_dados.vetorTermeletrica.at(idTermeletrica_CP).getSizeVetor(AttVetorTermeletrica_disponibilidade) > 0)
							a_dados.vetorTermeletrica.at(idTermeletrica_CP).setVetor(AttVetorTermeletrica_disponibilidade, SmartEnupla<Periodo, double>());

					}//for (IdTermeletrica idTermeletrica_CP = idTermeletricaIni_CP; idTermeletrica_CP < idTermeletricaOut_CP; a_dados.vetorTermeletrica.incr(idTermeletrica_CP)) {

				}//if (true) {


			}//try
			catch (const std::exception& erro) { throw std::invalid_argument("Erro is_carregar_PD_termeletricas: \n" + std::string(erro.what())); }


		}//if (is_carregar_PD_termeletricas) {

		//////////////////////////////////////////////////////////////////////////////
		//HIDRELETRICA
		//////////////////////////////////////////////////////////////////////////////

		if (is_carregar_PD_hidreletricas) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: HIDRELETRICA_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: HIDRELETRICA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: HIDRELETRICA_AttVetorOperacional_PorPeriodo.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: HIDRELETRICA_DEFLUENCIA_AttVetorOperacional_PorPeriodo.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: HIDRELETRICA_RESERVATORIO_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: HIDRELETRICA_RESERVATORIO_AttVetorOperacional_PorPeriodo.csv..." << std::endl;

				//*******************************************************************
				//   Instancia termelétricas PD no CP
				//   Testa se a termelétrica existe no CP. Caso contrário, o instancia com valores default
				//   Depois atualiza estes valores com a sobreposição dos periodos_CP e periodos_PD
				//*******************************************************************

				const IdHidreletrica idHidreletricaIni_CP = a_dados.getMenorId(IdHidreletrica());
				const IdHidreletrica idHidreletricaOut_CP = a_dados.getIdOut(IdHidreletrica());

				const IdHidreletrica idHidreletricaIni_PD = dados_PD.getMenorId(IdHidreletrica());
				const IdHidreletrica idHidreletricaOut_PD = dados_PD.getIdOut(IdHidreletrica());

				SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
				SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_menos_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
				SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

				for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
					matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));
					matriz_menos_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("min"))));
					matriz_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("max"))));

				}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				///////////////////////////////////////////////////////////////
				//1.Testa se existe uma hidrelétrica PD que não existe no CP
				///////////////////////////////////////////////////////////////

				for (IdHidreletrica idHidreletrica_CP = idHidreletricaIni_CP; idHidreletrica_CP < idHidreletricaOut_CP; a_dados.vetorHidreletrica.incr(idHidreletrica_CP)) {
					if (!dados_PD.vetorHidreletrica.isInstanciado(idHidreletrica_CP)) {
						//throw std::invalid_argument("Nao instanciada informacao na pre-Config PD da usina: " + getString(idHidreletrica_CP));
						std::cout << "Nao encontrada na pre-Config PD a usina: " << getString(idHidreletrica_CP) << std::endl;

					}
				}//for (IdHidreletrica idHidreletrica_CP = idHidreletricaIni_CP; idHidreletrica_CP < idHidreletricaOut_CP; a_dados.vetorHidreletrica.incr(idHidreletrica_CP)) {

				///////////////////////////////////////////////////////////////
				//2. Coloca insformação PD no CP
				///////////////////////////////////////////////////////////////

				for (IdHidreletrica idHidreletrica_CP = idHidreletricaIni_CP; idHidreletrica_CP < idHidreletricaOut_CP; a_dados.vetorHidreletrica.incr(idHidreletrica_CP)) {

					if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina) {
						
						//Precisa instanciar AttMatrizHidreletrica_potencia_minima e AttMatrizHidreletrica_potencia_minima para evitar conflito na validação com a disponibilidade

						double potencia_minima_hidreletrica = 0.0;
						double potencia_maxima_hidreletrica = 0.0;

						const IdConjuntoHidraulico idConjuntoHidraulicoIni_CP = a_dados.vetorHidreletrica.at(idHidreletrica_CP).getMenorId(IdConjuntoHidraulico());
						const IdConjuntoHidraulico idConjuntoHidraulicoOut_CP = a_dados.vetorHidreletrica.at(idHidreletrica_CP).getIdOut(IdConjuntoHidraulico());

						for (IdConjuntoHidraulico idConjuntoHidraulico_CP = idConjuntoHidraulicoIni_CP; idConjuntoHidraulico_CP < idConjuntoHidraulicoOut_CP; a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorConjuntoHidraulico.incr(idConjuntoHidraulico_CP)) {

							const IdUnidadeUHE idUnidadeUHEIni_CP = a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorConjuntoHidraulico.at(idConjuntoHidraulico_CP).getMenorId(IdUnidadeUHE());
							const IdUnidadeUHE idUnidadeUHEOut_CP = a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorConjuntoHidraulico.at(idConjuntoHidraulico_CP).getIdOut(IdUnidadeUHE());

							for (IdUnidadeUHE idUnidadeUHE_CP = idUnidadeUHEIni_CP; idUnidadeUHE_CP < idUnidadeUHEOut_CP; a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorConjuntoHidraulico.at(idConjuntoHidraulico_CP).vetorUnidadeUHE.incr(idUnidadeUHE_CP)) {

								potencia_minima_hidreletrica += a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorConjuntoHidraulico.at(idConjuntoHidraulico_CP).vetorUnidadeUHE.at(idUnidadeUHE_CP).getAtributo(AttComumUnidadeUHE_potencia_minima, double());
								potencia_maxima_hidreletrica += a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorConjuntoHidraulico.at(idConjuntoHidraulico_CP).vetorUnidadeUHE.at(idUnidadeUHE_CP).getAtributo(AttComumUnidadeUHE_potencia_maxima, double());

							}//for (IdUnidadeUHE idUnidadeUHE_CP = idUnidadeUHEIni_CP; idUnidadeUHE_CP < idUnidadeUHEOut_CP; a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorConjuntoHidraulico.at(idConjuntoHidraulico_CP).vetorUnidadeUHE.incr(idUnidadeUHE_CP)) {

						}//for (IdConjuntoHidraulico idConjuntoHidraulico_CP = idConjuntoHidraulicoIni_CP; idConjuntoHidraulico_CP < idConjuntoHidraulicoOut_CP; a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorConjuntoHidraulico.incr(idConjuntoHidraulico_CP)) {

						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> potencia_minima(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> potencia_maxima(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
							potencia_minima.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, potencia_minima_hidreletrica)));
							potencia_maxima.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, potencia_maxima_hidreletrica)));

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						a_dados.vetorHidreletrica.at(idHidreletrica_CP).setMatriz(AttMatrizHidreletrica_potencia_minima, potencia_minima);
						a_dados.vetorHidreletrica.at(idHidreletrica_CP).setMatriz(AttMatrizHidreletrica_potencia_maxima, potencia_maxima);
						a_dados.vetorHidreletrica.at(idHidreletrica_CP).setMatriz(AttMatrizHidreletrica_potencia_disponivel_minima, matriz_zero);
						a_dados.vetorHidreletrica.at(idHidreletrica_CP).setMatriz(AttMatrizHidreletrica_potencia_disponivel_maxima, matriz_zero);
						a_dados.vetorHidreletrica.at(idHidreletrica_CP).setMatriz(AttMatrizHidreletrica_vazao_turbinada_disponivel_minima, matriz_zero);
						a_dados.vetorHidreletrica.at(idHidreletrica_CP).setMatriz(AttMatrizHidreletrica_vazao_turbinada_disponivel_maxima, matriz_zero);

					}//if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina) {



					if (dados_PD.vetorHidreletrica.isInstanciado(idHidreletrica_CP)) {

						//Validação do horizonte_informacao_PD_pre_config
						std::vector<Periodo> periodos_PD = dados_PD.vetorHidreletrica.at(idHidreletrica_CP).getVetor(AttVetorHidreletrica_disponibilidade, Periodo(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

						const Periodo periodo_inicial_PD = periodos_PD.at(0);
						const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

						validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

						//////////////////////////////////
						//hidrelétrica
						//AttComum
						a_dados.vetorHidreletrica.at(idHidreletrica_CP).setAtributo(AttComumHidreletrica_representacao_discreta_producao, dados_PD.vetorHidreletrica.at(idHidreletrica_CP).getAtributo(AttComumHidreletrica_representacao_discreta_producao, bool()));
						a_dados.vetorHidreletrica.at(idHidreletrica_CP).setAtributo(AttComumHidreletrica_tempo_viagem_agua, dados_PD.vetorHidreletrica.at(idHidreletrica_CP).getAtributo(AttComumHidreletrica_tempo_viagem_agua, int()));

						//AttVetor
						
						if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina) {

							if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getSizeVetor(AttVetorHidreletrica_vazao_turbinada_maxima) == 0)
								throw std::invalid_argument("Deve ser informado o AttVetorHidreletrica_vazao_turbinada_maxima da usina: " + getString(idHidreletrica_CP));

							if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getSizeVetor(AttVetorHidreletrica_vazao_turbinada_minima) == 0)
								a_dados.vetorHidreletrica.at(idHidreletrica_CP).setVetor(AttVetorHidreletrica_vazao_turbinada_minima, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));

							if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getSizeVetor(AttVetorHidreletrica_disponibilidade) == 0)
								a_dados.vetorHidreletrica.at(idHidreletrica_CP).setVetor(AttVetorHidreletrica_disponibilidade, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								double indisponibilidade_forcada = 0.0;
								double indisponibilidade_programada = 0.0;

								if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getSizeVetor(AttVetorHidreletrica_indisponibilidade_forcada) > 0)
									indisponibilidade_forcada = a_dados.vetorHidreletrica.at(idHidreletrica_CP).getElementoVetor(AttVetorHidreletrica_indisponibilidade_forcada, periodo, double());

								if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getSizeVetor(AttVetorHidreletrica_indisponibilidade_programada) > 0)
									indisponibilidade_programada = a_dados.vetorHidreletrica.at(idHidreletrica_CP).getElementoVetor(AttVetorHidreletrica_indisponibilidade_programada, periodo, double());

								double disponibilidade = (1.0 - indisponibilidade_forcada) * (1.0 - indisponibilidade_programada);

								if (disponibilidade < 0)
									disponibilidade = -disponibilidade;

								if (doubleCompara(0.0, disponibilidade))
									disponibilidade = 0.0;
								else if (doubleCompara(1.0, disponibilidade))
									disponibilidade = 1.0;

								a_dados.vetorHidreletrica.at(idHidreletrica_CP).setElemento(AttVetorHidreletrica_disponibilidade, periodo, disponibilidade);

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						}//if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina) {

						if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getSizeVetor(AttVetorHidreletrica_tipo_detalhamento_producao) == 0)
							a_dados.vetorHidreletrica.at(idHidreletrica_CP).setVetor(AttVetorHidreletrica_tipo_detalhamento_producao, SmartEnupla<Periodo, TipoDetalhamentoProducaoHidreletrica>(horizonte_estudo, TipoDetalhamentoProducaoHidreletrica_por_usina));


						if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getSizeVetor(AttVetorHidreletrica_vazao_retirada) == 0)
							a_dados.vetorHidreletrica.at(idHidreletrica_CP).setVetor(AttVetorHidreletrica_vazao_retirada, SmartEnupla<Periodo, double>(horizonte_estudo, 0.0));

						//AttMatriz
						//não estão sendo usadas info matriz do PD por enquanto....


						//defluencia
						if (dados_PD.vetorHidreletrica.at(idHidreletrica_CP).vetorDefluencia.isInstanciado(IdDefluencia_passada)) {

							if (dados_PD.vetorHidreletrica.at(idHidreletrica_CP).vetorDefluencia.at(IdDefluencia_passada).getSizeVetor(AttVetorDefluencia_vazao_defluencia) > 0) {


								if (!a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorDefluencia.isInstanciado(IdDefluencia_passada)) {
									Defluencia defluencia;
									defluencia.setAtributo(AttComumDefluencia_idDefluencia, IdDefluencia_passada);
									a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorDefluencia.add(defluencia);
								}//if (!a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorDefluencia.isInstanciado(IdDefluencia_passada)) {

								a_dados.vetorHidreletrica.at(idHidreletrica_CP).vetorDefluencia.at(IdDefluencia_passada).setVetor(AttVetorDefluencia_vazao_defluencia, dados_PD.vetorHidreletrica.at(idHidreletrica_CP).vetorDefluencia.at(IdDefluencia_passada).getVetor(AttVetorDefluencia_vazao_defluencia, Periodo(), double()));

							}//if (dados_PD.vetorHidreletrica.at(idHidreletrica_CP).vetorDefluencia.at(IdDefluencia_passada).getSizeVetor(AttVetorDefluencia_vazao_defluencia) > 0) {

						}//if (dados_PD.vetorHidreletrica.at(idHidreletrica_CP).vetorDefluencia.isInstanciado(IdDefluencia_passada)) {

						/////////////////////////////////////////////////////////////////////////////////////
						//2.1. Atualiza matrizes dentro do horizonte PD
						/////////////////////////////////////////////////////////////////////////////////////

						SmartEnupla<Periodo, bool> horizonte_info_PD;

						for (int pos = 0; pos < int(periodos_PD.size()); pos++)
							horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

								const double sobreposicao = periodo.sobreposicao(periodo_PD);

								if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									const IdPatamarCarga maiorIdPatamarCarga_PD = dados_PD.vetorHidreletrica.at(idHidreletrica_CP).getIterador2Final(AttMatrizHidreletrica_potencia_maxima, periodo_PD, IdPatamarCarga());

									if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
										throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");

									//AttVetor
									if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina)
										a_dados.vetorHidreletrica.at(idHidreletrica_CP).setElemento(AttVetorHidreletrica_disponibilidade, periodo, dados_PD.vetorHidreletrica.at(idHidreletrica_CP).getElementoVetor(AttVetorHidreletrica_disponibilidade, periodo_PD, double()));
									
									a_dados.vetorHidreletrica.at(idHidreletrica_CP).setElemento(AttVetorHidreletrica_vazao_retirada, periodo, dados_PD.vetorHidreletrica.at(idHidreletrica_CP).getElementoVetor(AttVetorHidreletrica_vazao_retirada, periodo_PD, double()));
									//a_dados.vetorHidreletrica.at(idHidreletrica_CP).setElemento(AttVetorHidreletrica_tipo_detalhamento_producao, periodo, dados_PD.vetorHidreletrica.at(idHidreletrica_CP).getElementoVetor(AttVetorHidreletrica_tipo_detalhamento_producao, periodo_PD, double()));

								}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

							}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						//Calcula potencia_disponivel_minima / potencia_disponivel_maxima

						if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina) {

							for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

								const double disponibilidade = a_dados.vetorHidreletrica.at(idHidreletrica_CP).getElementoVetor(AttVetorHidreletrica_disponibilidade, periodo, double());

								const double vazao_turbinada_minima = a_dados.vetorHidreletrica.at(idHidreletrica_CP).getElementoVetor(AttVetorHidreletrica_vazao_turbinada_minima, periodo, double());
								const double vazao_turbinada_maxima = a_dados.vetorHidreletrica.at(idHidreletrica_CP).getElementoVetor(AttVetorHidreletrica_vazao_turbinada_maxima, periodo, double());

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

								for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

									const double potencia_minima = a_dados.vetorHidreletrica.at(idHidreletrica_CP).getElementoMatriz(AttMatrizHidreletrica_potencia_minima, periodo, idPatamarCarga, double());
									const double potencia_maxima = a_dados.vetorHidreletrica.at(idHidreletrica_CP).getElementoMatriz(AttMatrizHidreletrica_potencia_maxima, periodo, idPatamarCarga, double());

									a_dados.vetorHidreletrica.at(idHidreletrica_CP).setElemento(AttMatrizHidreletrica_potencia_disponivel_minima, periodo, idPatamarCarga, potencia_minima * disponibilidade);
									a_dados.vetorHidreletrica.at(idHidreletrica_CP).setElemento(AttMatrizHidreletrica_potencia_disponivel_maxima, periodo, idPatamarCarga, potencia_maxima * disponibilidade);

									////

									a_dados.vetorHidreletrica.at(idHidreletrica_CP).setElemento(AttMatrizHidreletrica_vazao_turbinada_disponivel_minima, periodo, idPatamarCarga, vazao_turbinada_minima * disponibilidade);
									a_dados.vetorHidreletrica.at(idHidreletrica_CP).setElemento(AttMatrizHidreletrica_vazao_turbinada_disponivel_maxima, periodo, idPatamarCarga, vazao_turbinada_maxima * disponibilidade);

								}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

							}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						}//if (a_dados.vetorHidreletrica.at(idHidreletrica_CP).getAtributo(AttComumHidreletrica_tipo_detalhamento_producao, TipoDetalhamentoProducaoHidreletrica()) == TipoDetalhamentoProducaoHidreletrica_por_usina) {

					}//if (dados_PD.vetorHidreletrica.isInstanciado(idHidreletrica_CP)) {

				}//for (IdHidreletrica idHidreletrica_CP = idHidreletricaIni_CP; idHidreletrica_CP < idHidreletricaOut_CP; a_dados.vetorHidreletrica.incr(idHidreletrica_CP)) {

			}//try
			catch (const std::exception& erro) { throw std::invalid_argument("Erro is_carregar_PD_hidreletricas: \n" + std::string(erro.what())); }


		}//if (is_carregar_PD_hidreletricas) {


		//////////////////////////////////////////////////////////////////////////////
		//CONTRATO_AttComumOperacional
		//CONTRATO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//////////////////////////////////////////////////////////////////////////////

		if (is_carregar_PD_contratos) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: CONTRATO_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: CONTRATO_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;

				//*******************************************************************
				//   Instancia contratos PD no CP
				//   Testa se o contrato existe no CP. Caso contrário, o instancia com valores default
				//   Depois atualiza estes valores com a sobreposição dos periodos_CP e periodos_PD
				//*******************************************************************

				const IdContrato idContratoIni_PD = dados_PD.getMenorId(IdContrato());
				const IdContrato idContratoOut_PD = dados_PD.getIdOut(IdContrato());

				for (IdContrato idContrato_PD = idContratoIni_PD; idContrato_PD < idContratoOut_PD; dados_PD.vetorContrato.incr(idContrato_PD)) {

					//Validação do horizonte_informacao_PD_pre_config
					std::vector<Periodo> periodos_PD = dados_PD.vetorContrato.at(idContrato_PD).getMatriz(AttMatrizContrato_lim_inf, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

					const Periodo periodo_inicial_PD = periodos_PD.at(0);
					const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

					validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

					////////////////////////////////////////
					//Instancia novos contratos PD no CP
					////////////////////////////////////////

					if (!a_dados.vetorContrato.isInstanciado(idContrato_PD)) {

						Contrato contrato;

						contrato.setAtributo(AttComumContrato_idContrato, idContrato_PD);

						contrato.setAtributo(AttComumContrato_nome, dados_PD.vetorContrato.at(idContrato_PD).getAtributo(AttComumContrato_nome, std::string()));
						contrato.setAtributo(AttComumContrato_submercado, dados_PD.vetorContrato.at(idContrato_PD).getAtributo(AttComumContrato_submercado, IdSubmercado()));
						contrato.setAtributo(AttComumContrato_tipo_contrato, dados_PD.vetorContrato.at(idContrato_PD).getAtributo(AttComumContrato_tipo_contrato, TipoContrato()));
						contrato.setAtributo(AttComumContrato_titulacao_contrato, dados_PD.vetorContrato.at(idContrato_PD).getAtributo(AttComumContrato_titulacao_contrato, int()));
						contrato.setAtributo(AttComumContrato_vlr_ini, dados_PD.vetorContrato.at(idContrato_PD).getAtributo(AttComumContrato_vlr_ini, double()));
						a_dados.vetorContrato.add(contrato);

						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_menos_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
							matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));
							matriz_menos_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("min"))));
							matriz_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("max"))));

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						a_dados.vetorContrato.at(idContrato_PD).setMatriz(AttMatrizContrato_custo, matriz_zero);
						a_dados.vetorContrato.at(idContrato_PD).setMatriz(AttMatrizContrato_lim_inf, matriz_zero);
						a_dados.vetorContrato.at(idContrato_PD).setMatriz(AttMatrizContrato_lim_sup, matriz_zero);

					}//if (!a_dados.vetorContrato.isInstanciado(idContrato_PD)) {

					/////////////////////////////////////////////////////////////////////////////////////
					//Atualiza lim_inf lim_sup custo
					/////////////////////////////////////////////////////////////////////////////////////

					SmartEnupla<Periodo, bool> horizonte_info_PD;

					for (int pos = 0; pos < int(periodos_PD.size()); pos++)
						horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

					for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

							const double sobreposicao = periodo.sobreposicao(periodo_PD);

							if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
								const IdPatamarCarga maiorIdPatamarCarga_PD = dados_PD.vetorContrato.at(idContrato_PD).getIterador2Final(AttMatrizContrato_lim_inf, periodo_PD, IdPatamarCarga());

								if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
									throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");

								for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

									a_dados.vetorContrato.at(idContrato_PD).setElemento(AttMatrizContrato_custo, periodo, idPatamarCarga, dados_PD.vetorContrato.at(idContrato_PD).getElementoMatriz(AttMatrizContrato_custo, periodo_PD, idPatamarCarga, double()));
									a_dados.vetorContrato.at(idContrato_PD).setElemento(AttMatrizContrato_lim_inf, periodo, idPatamarCarga, dados_PD.vetorContrato.at(idContrato_PD).getElementoMatriz(AttMatrizContrato_lim_inf, periodo_PD, idPatamarCarga, double()));
									a_dados.vetorContrato.at(idContrato_PD).setElemento(AttMatrizContrato_lim_sup, periodo, idPatamarCarga, dados_PD.vetorContrato.at(idContrato_PD).getElementoMatriz(AttMatrizContrato_lim_sup, periodo_PD, idPatamarCarga, double()));

								}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

							}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

						}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

					}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				}//for (IdContrato idContrato_PD = idContratoIni_PD; idContrato_PD < idContratoOut_PD; dados_PD.vetorContrato.incr(idContrato_PD)) {

			}//try {
			catch (const std::exception& erro) { throw std::invalid_argument("Erro is_carregar_PD_contratos: \n" + std::string(erro.what())); }

		}//is_carregar_PD_contratos

		//////////////////////////////////////////////////////////////////////////////
		//DEMANDA_ESPECIAL_AttComumOperacional
		//DEMANDA_ESPECIAL_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//////////////////////////////////////////////////////////////////////////////

		if (is_carregar_PD_demanda_especial) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: DEMANDA_ESPECIAL_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: DEMANDA_ESPECIAL_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;

				//*******************************************************************
				//   Instancia demanda_especial PD no CP
				//   Testa se a demanda_especial existe no CP. Caso contrário, o instancia com valores default
				//   Depois atualiza estes valores com a sobreposição dos periodos_CP e periodos_PD
				//*******************************************************************

				const IdDemandaEspecial idDemandaEspecialIni_PD = dados_PD.getMenorId(IdDemandaEspecial());
				const IdDemandaEspecial idDemandaEspecialOut_PD = dados_PD.getIdOut(IdDemandaEspecial());

				for (IdDemandaEspecial idDemandaEspecial_PD = idDemandaEspecialIni_PD; idDemandaEspecial_PD < idDemandaEspecialOut_PD; dados_PD.vetorDemandaEspecial.incr(idDemandaEspecial_PD)) {

					//Validação do horizonte_informacao_PD_pre_config
					std::vector<Periodo> periodos_PD = dados_PD.vetorDemandaEspecial.at(idDemandaEspecial_PD).getMatriz(AttMatrizDemandaEspecial_demanda, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

					const Periodo periodo_inicial_PD = periodos_PD.at(0);
					const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

					validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

					////////////////////////////////////////
					//Instancia novas demanda_especial PD no CP
					////////////////////////////////////////

					if (!a_dados.vetorDemandaEspecial.isInstanciado(idDemandaEspecial_PD)) {

						DemandaEspecial demandaEspecial;

						demandaEspecial.setAtributo(AttComumDemandaEspecial_idDemandaEspecial, idDemandaEspecial_PD);
						demandaEspecial.setAtributo(AttComumDemandaEspecial_nome, dados_PD.vetorDemandaEspecial.at(idDemandaEspecial_PD).getAtributo(AttComumDemandaEspecial_nome, std::string()));
						a_dados.vetorDemandaEspecial.add(demandaEspecial);

						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_menos_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
							matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));
							matriz_menos_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("min"))));
							matriz_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("max"))));

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						a_dados.vetorDemandaEspecial.at(idDemandaEspecial_PD).setMatriz(AttMatrizDemandaEspecial_demanda, matriz_zero);


					}//if (!a_dados.vetorDemandaEspecial.isInstanciado(idDemandaEspecial_PD)) {

					/////////////////////////////////////////////////////////////////////////////////////
					//Atualiza demanda
					/////////////////////////////////////////////////////////////////////////////////////

					SmartEnupla<Periodo, bool> horizonte_info_PD;

					for (int pos = 0; pos < int(periodos_PD.size()); pos++)
						horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

					for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

							const double sobreposicao = periodo.sobreposicao(periodo_PD);

							if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
								const IdPatamarCarga maiorIdPatamarCarga_PD = dados_PD.vetorDemandaEspecial.at(idDemandaEspecial_PD).getIterador2Final(AttMatrizDemandaEspecial_demanda, periodo_PD, IdPatamarCarga());

								if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
									throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");

								for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

									a_dados.vetorDemandaEspecial.at(idDemandaEspecial_PD).setElemento(AttMatrizDemandaEspecial_demanda, periodo, idPatamarCarga, dados_PD.vetorDemandaEspecial.at(idDemandaEspecial_PD).getElementoMatriz(AttMatrizDemandaEspecial_demanda, periodo_PD, idPatamarCarga, double()));

								}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

							}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

						}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

					}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				}//for (IdDemandaEspecial idDemandaEspecial_PD = idDemandaEspecialIni_PD; idDemandaEspecial_PD < idDemandaEspecialOut_PD; dados_PD.vetorDemandaEspecial.incr(idDemandaEspecial_PD)) {

			}//try {
			catch (const std::exception& erro) { throw std::invalid_argument("Erro is_carregar_PD_demanda_especial: \n" + std::string(erro.what())); }

		}//is_carregar_PD_demanda_especial

		//////////////////////////////////////////////////////////////////////////////
		//RESERVA_POTENCIA_AttComumOperacional
		//RESERVA_POTENCIA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//RESERVA_POTENCIA_ELEMENTO_SISTEMA_AttComumOperacional
		//RESERVA_POTENCIA_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//////////////////////////////////////////////////////////////////////////////

		if (is_carregar_PD_reserva_potencia) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: RESERVA_POTENCIA_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: RESERVA_POTENCIA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: RESERVA_POTENCIA_ELEMENTO_SISTEMA_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: RESERVA_POTENCIA_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;

				//*******************************************************************
				//   Instancia reserva_potencia PD no CP
				//   Testa se a reserva_potencia existe no CP. Caso contrário, o instancia com valores default
				//   Depois atualiza estes valores com a sobreposição dos periodos_CP e periodos_PD
				//*******************************************************************

				const IdReservaPotencia idReservaPotenciaIni_PD = dados_PD.getMenorId(IdReservaPotencia());
				const IdReservaPotencia idReservaPotenciaOut_PD = dados_PD.getIdOut(IdReservaPotencia());

				for (IdReservaPotencia idReservaPotencia_PD = idReservaPotenciaIni_PD; idReservaPotencia_PD < idReservaPotenciaOut_PD; dados_PD.vetorReservaPotencia.incr(idReservaPotencia_PD)) {

					//Validação do horizonte_informacao_PD_pre_config
					std::vector<Periodo> periodos_PD = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getMatriz(AttMatrizReservaPotencia_reserva_minima, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

					const Periodo periodo_inicial_PD = periodos_PD.at(0);
					const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

					validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

					////////////////////////////////////////
					//Instancia novas reserva_potencia PD no CP
					////////////////////////////////////////

					if (!a_dados.vetorReservaPotencia.isInstanciado(idReservaPotencia_PD)) {

						ReservaPotencia reservaPotencia;

						reservaPotencia.setAtributo(AttComumReservaPotencia_idReservaPotencia, idReservaPotencia_PD);
						reservaPotencia.setAtributo(AttComumReservaPotencia_nome, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getAtributo(AttComumReservaPotencia_nome, std::string()));
						reservaPotencia.setAtributo(AttComumReservaPotencia_area, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getAtributo(AttComumReservaPotencia_area, IdArea()));
						a_dados.vetorReservaPotencia.add(reservaPotencia);

						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_menos_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
							matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));
							matriz_menos_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("min"))));
							matriz_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("max"))));

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						a_dados.vetorReservaPotencia.at(idReservaPotencia_PD).setMatriz(AttMatrizReservaPotencia_reserva_minima, matriz_zero);

						//Instanciar os elementos

						const IdElementoSistema idElementoSistemaIni = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getMenorId(IdElementoSistema());
						const IdElementoSistema idElementoSistemaOut = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getIdOut(IdElementoSistema());

						for (IdElementoSistema idElementoSistema = idElementoSistemaIni; idElementoSistema < idElementoSistemaOut; dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.incr(idElementoSistema)) {

							ElementoSistema elementoSistema;
							elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);

							elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa()));
							elementoSistema.setAtributo(AttComumElementoSistema_termeletrica, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_termeletrica, IdTermeletrica()));
							elementoSistema.setAtributo(AttComumElementoSistema_hidreletrica, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_hidreletrica, IdHidreletrica()));
							elementoSistema.setAtributo(AttComumElementoSistema_demanda, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_demanda, IdSubmercado()));

							elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_zero);
							a_dados.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.add(elementoSistema);

						}//for (IdElementoSistema idElementoSistema = idElementoSistemaIni; idElementoSistema < idElementoSistemaOut; dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.incr(idElementoSistema)) {

					}//if (!a_dados.vetorReservaPotencia.isInstanciado(idReservaPotencia_PD)) {

					/////////////////////////////////////////////////////////////////////////////////////
					//Atualiza reserva_minima
					// fator_participacao
					/////////////////////////////////////////////////////////////////////////////////////

					SmartEnupla<Periodo, bool> horizonte_info_PD;

					for (int pos = 0; pos < int(periodos_PD.size()); pos++)
						horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

					for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

							const double sobreposicao = periodo.sobreposicao(periodo_PD);

							if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
								const IdPatamarCarga maiorIdPatamarCarga_PD = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getIterador2Final(AttMatrizReservaPotencia_reserva_minima, periodo_PD, IdPatamarCarga());

								if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
									throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");

								//AttMatriz Reserva
								a_dados.vetorReservaPotencia.at(idReservaPotencia_PD).setElemento(AttMatrizReservaPotencia_reserva_minima, periodo, IdPatamarCarga_1, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getElementoMatriz(AttMatrizReservaPotencia_reserva_minima, periodo_PD, IdPatamarCarga_1, double()));

								//AttMatriz ElementoSistema
								const IdElementoSistema idElementoSistemaIni = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getMenorId(IdElementoSistema());
								const IdElementoSistema idElementoSistemaOut = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getIdOut(IdElementoSistema());
				
								for (IdElementoSistema idElementoSistema = idElementoSistemaIni; idElementoSistema < idElementoSistemaOut; dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.incr(idElementoSistema)) {
									a_dados.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, IdPatamarCarga_1, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).getElementoMatriz(AttMatrizElementoSistema_fator_participacao, periodo_PD, IdPatamarCarga_1, double()));
								}//for (IdElementoSistema idElementoSistema = idElementoSistemaIni; idElementoSistema < idElementoSistemaOut; dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.incr(idElementoSistema)) {

							}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

						}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

					}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				}//for (IdReservaPotencia idReservaPotencia_PD = idReservaPotenciaIni_PD; idReservaPotencia_PD < idReservaPotenciaOut_PD; dados_PD.vetorReservaPotencia.incr(idReservaPotencia_PD)) {

			}//try {
			catch (const std::exception& erro) { throw std::invalid_argument("Erro is_carregar_PD_reserva_potencia: \n" + std::string(erro.what())); }

		}//is_carregar_PD_reserva_potencia

		//////////////////////////////////////////////////////////////////////////////
		//COTAR11_AttComumOperacional
		//COTAR11_AttVetorOperacional_PorPeriodo
		//COTAR11_AttVetorPolinomio_PorPeriodo
		//COTAR11_COTAPASSADA_AttVetorOperacional_PorPeriodo
		//////////////////////////////////////////////////////////////////////////////
		/*
		if (is_carregar_PD_cota_r11) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: COTAR11_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: COTAR11_AttVetorOperacional_PorPeriodo.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: COTAR11_AttVetorPolinomio_PorPeriodo.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: COTAR11_COTAPASSADA_AttVetorOperacional_PorPeriodo.csv..." << std::endl;

				//*******************************************************************
				//   Instancia cota_r11 PD no CP
				//   Testa se a cota_r11 existe no CP. Caso contrário, o instancia com valores default
				//   Depois atualiza estes valores com a sobreposição dos periodos_CP e periodos_PD
				//*******************************************************************

				const IdControleCotaVazao idControleCotaVazaoIni_PD = dados_PD.getMenorId(IdControleCotaVazao());
				const IdControleCotaVazao idControleCotaVazaoOut_PD = dados_PD.getIdOut(IdControleCotaVazao());

				for (IdControleCotaVazao idControleCotaVazao_PD = idControleCotaVazaoIni_PD; idControleCotaVazao_PD < idControleCotaVazaoOut_PD; dados_PD.vetorControleCotaVazao.incr(idControleCotaVazao_PD)) {

					//Validação do horizonte_informacao_PD_pre_config
					std::vector<Periodo> periodos_PD = dados_PD.vetorControleCotaVazao.at(idControleCotaVazao_PD).getVetor(AttVetorControleCotaVazao_var_abs_sup_1hora, Periodo(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());

					const Periodo periodo_inicial_PD = periodos_PD.at(0);
					const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

					validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

					////////////////////////////////////////
					//Instancia novas reserva_potencia PD no CP
					////////////////////////////////////////

					if (!a_dados.vetorControleCotaVazao.isInstanciado(idControleCotaVazao_PD)) {

						ControleCotaVazao controleCotaVazao;

						controleCotaVazao.setAtributo(AttComumControleCotaVazao_idControleCotaVazao, idControleCotaVazao_PD);
						controleCotaVazao.setAtributo(AttComumControleCotaVazao_vlr_ini, dados_PD.vetorControleCotaVazao.at(idControleCotaVazao_PD).getAtributo(AttComumControleCotaVazao_vlr_ini, double()));

						a_dados.vetorControleCotaVazao.add(controleCotaVazao);

						//AQUI!!!!

						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_menos_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_inf(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
							matriz_zero.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));
							matriz_menos_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("min"))));
							matriz_inf.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("max"))));

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						a_dados.vetorReservaPotencia.at(idReservaPotencia_PD).setMatriz(AttMatrizReservaPotencia_reserva_minima, matriz_zero);

						//Instanciar os elementos

						const IdElementoSistema idElementoSistemaIni = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getMenorId(IdElementoSistema());
						const IdElementoSistema idElementoSistemaOut = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getIdOut(IdElementoSistema());

						for (IdElementoSistema idElementoSistema = idElementoSistemaIni; idElementoSistema < idElementoSistemaOut; dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.incr(idElementoSistema)) {

							ElementoSistema elementoSistema;
							elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);

							elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa()));
							elementoSistema.setAtributo(AttComumElementoSistema_termeletrica, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_termeletrica, IdTermeletrica()));
							elementoSistema.setAtributo(AttComumElementoSistema_hidreletrica, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_hidreletrica, IdHidreletrica()));
							elementoSistema.setAtributo(AttComumElementoSistema_demanda, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_demanda, IdSubmercado()));

							elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_zero);
							a_dados.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.add(elementoSistema);

						}//for (IdElementoSistema idElementoSistema = idElementoSistemaIni; idElementoSistema < idElementoSistemaOut; dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.incr(idElementoSistema)) {

					}//if (!a_dados.vetorReservaPotencia.isInstanciado(idReservaPotencia_PD)) {

					/////////////////////////////////////////////////////////////////////////////////////
					//Atualiza reserva_minima
					// fator_participacao
					/////////////////////////////////////////////////////////////////////////////////////

					SmartEnupla<Periodo, bool> horizonte_info_PD;

					for (int pos = 0; pos < int(periodos_PD.size()); pos++)
						horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

					for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

							const double sobreposicao = periodo.sobreposicao(periodo_PD);

							if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
								const IdPatamarCarga maiorIdPatamarCarga_PD = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getIterador2Final(AttMatrizReservaPotencia_reserva_minima, periodo_PD, IdPatamarCarga());

								if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
									throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");

								//AttMatriz Reserva
								a_dados.vetorReservaPotencia.at(idReservaPotencia_PD).setElemento(AttMatrizReservaPotencia_reserva_minima, periodo, IdPatamarCarga_1, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getElementoMatriz(AttMatrizReservaPotencia_reserva_minima, periodo_PD, IdPatamarCarga_1, double()));

								//AttMatriz ElementoSistema
								const IdElementoSistema idElementoSistemaIni = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getMenorId(IdElementoSistema());
								const IdElementoSistema idElementoSistemaOut = dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).getIdOut(IdElementoSistema());

								for (IdElementoSistema idElementoSistema = idElementoSistemaIni; idElementoSistema < idElementoSistemaOut; dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.incr(idElementoSistema)) {
									a_dados.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, IdPatamarCarga_1, dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.at(idElementoSistema).getElementoMatriz(AttMatrizElementoSistema_fator_participacao, periodo_PD, IdPatamarCarga_1, double()));
								}//for (IdElementoSistema idElementoSistema = idElementoSistemaIni; idElementoSistema < idElementoSistemaOut; dados_PD.vetorReservaPotencia.at(idReservaPotencia_PD).vetorElementoSistema.incr(idElementoSistema)) {

							}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

						}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

					}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				}//for (IdControleCotaVazao idControleCotaVazao_PD = idControleCotaVazaoIni_PD; idControleCotaVazao_PD < idControleCotaVazaoOut_PD; dados_PD.vetorControleCotaVazao.incr(idControleCotaVazao_PD)) {

			}//try {
			catch (const std::exception& erro) { throw std::invalid_argument("Erro is_carregar_PD_cota_r11: \n" + std::string(erro.what())); }

		}//is_carregar_PD_cota_r11
		*/
		//////////////////////////////////////////////////////////////////////////////
		//RESTRICAO_ELETRICA_AttComumOperacional
		//RESTRICAO_ELETRICA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//RESTRICAO_ELETRICA_ELEMENTO_SISTEMA_AttComumOperacional
		//RESTRICAO_ELETRICA_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//////////////////////////////////////////////////////////////////////////////

		if (is_carregar_PD_restricoes_eletricas) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: RESTRICAO_ELETRICA_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: RESTRICAO_ELETRICA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: RESTRICAO_ELETRICA_ELEMENTO_SISTEMA_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: RESTRICAO_ELETRICA_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;

				//Informação para atualizar os limites das restrições originais: Seus limites vão ser "liberados" nos períodos do horizonte das restrições PD
				const IdRestricaoEletrica maiorIdRestricaoEletrica_REF = a_dados.getMaiorId(IdRestricaoEletrica()); //maior idRestricaoEletrica do conjunto de restrições originais
				Periodo periodo_REF = horizonte_estudo.getIteradorInicial(); //Período a partir do qual vão ser consideradas as restrições originais (atualiza-se a partir do periodo_final_PD)

				//*******************************************************************
				//1. Instancia as restrições PD no CP
				//   Deixa os limites abertos para os períodos fora do horizonte_PD
				//*******************************************************************
				const IdRestricaoEletrica maiorIdRestricaoEletrica_PD = dados_PD.getMaiorId(IdRestricaoEletrica());

				for (IdRestricaoEletrica idRestricaoEletrica_PD = IdRestricaoEletrica_1; idRestricaoEletrica_PD <= maiorIdRestricaoEletrica_PD; idRestricaoEletrica_PD++) {

					bool is_all_elementos_restricao_in_CP = true;

					if (true) {//Testa se todos os elementos de uma restrição são objetos instanciados no CP. Caso contrário, não inclui a restrição

						const IdElementoSistema maiorIdElementoSistema_PD = dados_PD.getMaiorId(idRestricaoEletrica_PD, IdElementoSistema());

						for (IdElementoSistema idElementoSistema = IdElementoSistema_1; idElementoSistema <= maiorIdElementoSistema_PD; idElementoSistema++) {

							const IdConjuntoHidraulico idConjuntoHidraulico_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_conjuntohidraulico, IdConjuntoHidraulico());
							const IdHidreletrica       idHidreletrica_PD       = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_hidreletrica, IdHidreletrica());
							const IdTermeletrica       idTermeletrica_PD       = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_termeletrica, IdTermeletrica());
							const IdDemandaEspecial    idDemandaEspecial_PD    = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_demandaEspecial, IdDemandaEspecial());
							const IdUnidadeUTE         idUnidadeUTE_PD         = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_unidadeTermeletrica, IdUnidadeUTE());
							const IdContrato           idContrato_PD           = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_contrato, IdContrato());
							const IdRenovavel          idRenovavel_PD          = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_renovavel, IdRenovavel());
							const IdUsinaElevatoria    idUsinaElevatoria_PD    = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_usina_elevatoria, IdUsinaElevatoria());
							const IdIntercambio        idIntercambio_PD        = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_intercambio, IdIntercambio());


							if (idConjuntoHidraulico_PD != IdConjuntoHidraulico_Nenhum) {
								is_all_elementos_restricao_in_CP = false;
								break;
							}//if (idHidreletrica_PD != IdHidreletrica_Nenhum) {

							if (idHidreletrica_PD != IdHidreletrica_Nenhum) {
								if (!a_dados.vetorHidreletrica.isInstanciado(idHidreletrica_PD)) {
									is_all_elementos_restricao_in_CP = false;
									break;
								}//if (!a_dados.vetorHidreletrica.isInstanciado(idHidreletrica_PD)) {
							}//if (idHidreletrica_PD != IdHidreletrica_Nenhum) {

							if (idTermeletrica_PD != IdTermeletrica_Nenhum) {
								if (!a_dados.vetorTermeletrica.isInstanciado(idTermeletrica_PD)) {
									is_all_elementos_restricao_in_CP = false;
									break;
								}//if (!a_dados.vetorTermeletrica.isInstanciado(idTermeletrica_PD)) {
							}//if (idTermeletrica_PD != IdTermeletrica_Nenhum) {

							if (idDemandaEspecial_PD != IdDemandaEspecial_Nenhum) {
								if (!a_dados.vetorDemandaEspecial.isInstanciado(idDemandaEspecial_PD)) {
									is_all_elementos_restricao_in_CP = false;
									break;
								}//if (!a_dados.vetorDemandaEspecial.isInstanciado(idDemandaEspecial_PD)) {
							}//if (idDemandaEspecial_PD != IdDemandaEspecial_Nenhum) {

							if (idUnidadeUTE_PD != IdUnidadeUTE_Nenhum) {
								is_all_elementos_restricao_in_CP = false;
								break;
							}//if (idHidreletrica_PD != IdHidreletrica_Nenhum) {


							if (idContrato_PD != IdContrato_Nenhum) {
								if (!a_dados.vetorContrato.isInstanciado(idContrato_PD)) {
									is_all_elementos_restricao_in_CP = false;
									break;
								}//if (!a_dados.vetorContrato.isInstanciado(idContrato_PD)) {
							}//if (idContrato_PD != IdContrato_Nenhum) {

							if (idRenovavel_PD != IdRenovavel_Nenhum) {
								if (!a_dados.vetorRenovavel.isInstanciado(idRenovavel_PD)) {
									is_all_elementos_restricao_in_CP = false;
									break;
								}//if (!a_dados.vetorRenovavel.isInstanciado(idRenovavel_PD)) {
							}//if (idRenovavel_PD != IdRenovavel_Nenhum) {

							if (idUsinaElevatoria_PD != IdUsinaElevatoria_Nenhum) {
								if (!a_dados.vetorUsinaElevatoria.isInstanciado(idUsinaElevatoria_PD)) {
									is_all_elementos_restricao_in_CP = false;
									break;
								}//if (!a_dados.vetorUsinaElevatoria.isInstanciado(idUsinaElevatoria_PD)) {
							}//if (idUsinaElevatoria_PD != IdUsinaElevatoria_Nenhum) {

							if (idIntercambio_PD != IdIntercambio_Nenhum) {//Encontra o idIntercambio no CP que tenha o mesmo de->para

								if (!dadosPreConfig_intercambio_attComum_operacional)
									throw std::invalid_argument("Precisa instanciar na pre-config o arquivo: INTERCAMBIO_AttComumOperacional.csv");

								const IdSubmercado submercado_origem_PD = dados_PD.vetorIntercambio.at(idIntercambio_PD).getAtributo(AttComumIntercambio_submercado_origem, IdSubmercado());
								const IdSubmercado submercado_destino_PD = dados_PD.vetorIntercambio.at(idIntercambio_PD).getAtributo(AttComumIntercambio_submercado_destino, IdSubmercado());

								IdIntercambio idIntercambio_CP = IdIntercambio_Nenhum;

								const IdIntercambio maiorIdIntercambio = a_dados.getMaiorId(IdIntercambio());
								for (IdIntercambio idIntercambio = IdIntercambio_1; idIntercambio <= maiorIdIntercambio; idIntercambio++) {

									const IdSubmercado submercado_origem = a_dados.vetorIntercambio.at(idIntercambio).getAtributo(AttComumIntercambio_submercado_origem, IdSubmercado());
									const IdSubmercado submercado_destino = a_dados.vetorIntercambio.at(idIntercambio).getAtributo(AttComumIntercambio_submercado_destino, IdSubmercado());

									if (submercado_origem == submercado_origem_PD && submercado_destino == submercado_destino_PD) {
										idIntercambio_CP = idIntercambio;
										break;

									}//if (submercado_origem == submercado_origem_PD && submercado_destino == submercado_destino_PD) {

								}//for (IdIntercambio idIntercambio = IdIntercambio_1; idIntercambio <= maiorIdIntercambio; idIntercambio++) {

								if (idIntercambio_CP == IdIntercambio_Nenhum) {
									is_all_elementos_restricao_in_CP = false;
									break;
								}//if (idIntercambio_CP == IdIntercambio_Nenhum) {

							}//if (idIntercambio_PD != IdIntercambio_Nenhum) {

						}//for (IdElementoSistema idElementoSistema = IdElementoSistema_1; idElementoSistema <= maiorIdElementoSistema_PD; idElementoSistema++) {

					}//if (true) {

					/////////

					if (is_all_elementos_restricao_in_CP) {

						//Validação do horizonte_informacao_PD_pre_config
						std::vector<Periodo> periodos_PD;

						if(dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_lim_inf) > 0)
							periodos_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getMatriz(AttMatrizRestricaoEletrica_lim_inf, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());
						else if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_lim_sup) > 0)
							periodos_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getMatriz(AttMatrizRestricaoEletrica_lim_sup, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());
						else if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_abs_inf) > 0)
							periodos_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getMatriz(AttMatrizRestricaoEletrica_var_abs_inf, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());
						else if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_abs_sup) > 0)
							periodos_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getMatriz(AttMatrizRestricaoEletrica_var_abs_sup, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());
						else if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_rel_inf) > 0)
							periodos_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getMatriz(AttMatrizRestricaoEletrica_var_rel_inf, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());
						else if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_rel_sup) > 0)
							periodos_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getMatriz(AttMatrizRestricaoEletrica_var_rel_sup, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());


						const Periodo periodo_inicial_PD = periodos_PD.at(0);
						const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

						validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

						////////////////////////////////////////
						//Instancia as novas restrições PD no CP
						////////////////////////////////////////

						RestricaoEletrica restricaoEletrica;

						const IdRestricaoEletrica idRestricaoEletrica = IdRestricaoEletrica(a_dados.getMaiorId(IdRestricaoEletrica()) + 1);

						restricaoEletrica.setAtributo(AttComumRestricaoEletrica_idRestricaoEletrica, idRestricaoEletrica);

						restricaoEletrica.setAtributo(AttComumRestricaoEletrica_nome, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getAtributo(AttComumRestricaoEletrica_nome, std::string()));
						restricaoEletrica.setAtributo(AttComumRestricaoEletrica_penalidade, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getAtributo(AttComumRestricaoEletrica_penalidade, double()));
						a_dados.vetorRestricaoEletrica.add(restricaoEletrica);

						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero_lim(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_menos_inf_lim(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_inf_lim(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

						//Os atributos de variação só tem por construção IdPatamarCarga_1
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero_var(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(IdPatamarCarga_1, 0.0)));
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_menos_inf_var(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(IdPatamarCarga_1, getdoubleFromChar("min"))));
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_inf_var(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(IdPatamarCarga_1, getdoubleFromChar("max"))));

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
							matriz_zero_lim.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));
							matriz_menos_inf_lim.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("min"))));
							matriz_inf_lim.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("max"))));

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_lim_inf) > 0)
							a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setMatriz(AttMatrizRestricaoEletrica_lim_inf, matriz_menos_inf_lim);
						
						if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_lim_sup) > 0)
							a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setMatriz(AttMatrizRestricaoEletrica_lim_sup, matriz_inf_lim);
						
						if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_abs_inf) > 0)
							a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setMatriz(AttMatrizRestricaoEletrica_var_abs_inf, matriz_inf_var);
						
						if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_abs_sup) > 0)
							a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setMatriz(AttMatrizRestricaoEletrica_var_abs_sup, matriz_inf_var);
						
						if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_rel_inf) > 0)
							a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setMatriz(AttMatrizRestricaoEletrica_var_rel_inf, matriz_inf_var);
						
						if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_rel_sup) > 0)
							a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setMatriz(AttMatrizRestricaoEletrica_var_rel_sup, matriz_inf_var);

						////////////////////////////////
						//Elementos Restrição
						////////////////////////////////

						const IdElementoSistema maiorIdElementoSistema_PD = dados_PD.getMaiorId(idRestricaoEletrica_PD, IdElementoSistema());

						for (IdElementoSistema idElementoSistema = IdElementoSistema_1; idElementoSistema <= maiorIdElementoSistema_PD; idElementoSistema++) {

							ElementoSistema elementoSistema;
							elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);

							elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema()));
							elementoSistema.setAtributo(AttComumElementoSistema_conjuntohidraulico, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_conjuntohidraulico, IdConjuntoHidraulico()));
							elementoSistema.setAtributo(AttComumElementoSistema_hidreletrica, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_hidreletrica, IdHidreletrica()));
							elementoSistema.setAtributo(AttComumElementoSistema_termeletrica, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_termeletrica, IdTermeletrica()));
							elementoSistema.setAtributo(AttComumElementoSistema_demandaEspecial, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_demandaEspecial, IdDemandaEspecial()));
							elementoSistema.setAtributo(AttComumElementoSistema_unidadeTermeletrica, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_unidadeTermeletrica, IdUnidadeUTE()));
							elementoSistema.setAtributo(AttComumElementoSistema_contrato, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_contrato, IdContrato()));
							elementoSistema.setAtributo(AttComumElementoSistema_renovavel, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_renovavel, IdRenovavel()));
							elementoSistema.setAtributo(AttComumElementoSistema_usina_elevatoria, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_usina_elevatoria, IdUsinaElevatoria()));
							elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa()));

							//Mapea o idIntercambio
							IdIntercambio idIntercambio_CP = IdIntercambio_Nenhum;
							const IdIntercambio idIntercambio_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_intercambio, IdIntercambio());

							if (idIntercambio_PD != IdIntercambio_Nenhum) {//Encontra o idIntercambio no CP que tenha o mesmo de->para

								if (!dadosPreConfig_intercambio_attComum_operacional)
									throw std::invalid_argument("Precisa instanciar na pre-config o arquivo: INTERCAMBIO_AttComumOperacional.csv");

								const IdSubmercado submercado_origem_PD = dados_PD.vetorIntercambio.at(idIntercambio_PD).getAtributo(AttComumIntercambio_submercado_origem, IdSubmercado());
								const IdSubmercado submercado_destino_PD = dados_PD.vetorIntercambio.at(idIntercambio_PD).getAtributo(AttComumIntercambio_submercado_destino, IdSubmercado());

								const IdIntercambio maiorIdIntercambio = a_dados.getMaiorId(IdIntercambio());
								for (IdIntercambio idIntercambio = IdIntercambio_1; idIntercambio <= maiorIdIntercambio; idIntercambio++) {

									const IdSubmercado submercado_origem = a_dados.vetorIntercambio.at(idIntercambio).getAtributo(AttComumIntercambio_submercado_origem, IdSubmercado());
									const IdSubmercado submercado_destino = a_dados.vetorIntercambio.at(idIntercambio).getAtributo(AttComumIntercambio_submercado_destino, IdSubmercado());

									if (submercado_origem == submercado_origem_PD && submercado_destino == submercado_destino_PD) {
										idIntercambio_CP = idIntercambio;
										break;

									}//if (submercado_origem == submercado_origem_PD && submercado_destino == submercado_destino_PD) {

								}//for (IdIntercambio idIntercambio = IdIntercambio_1; idIntercambio <= maiorIdIntercambio; idIntercambio++) {

								if (idIntercambio_CP == IdIntercambio_Nenhum)
									throw std::invalid_argument("Nao identificado o idIntercambio_PD com submercado_origem: " + getString(submercado_origem_PD) + " e submercado_destino: " + getString(submercado_destino_PD));

							}//if (idIntercambio_PD != IdIntercambio_Nenhum) {

							elementoSistema.setAtributo(AttComumElementoSistema_intercambio, idIntercambio_CP);

							////

							elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_zero_lim); //Para restrições var pode ter a estrutura das restrições lim
							a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.add(elementoSistema);

						}//for (IdElementoSistema idElementoSistema = IdElementoSistema_1; idElementoSistema <= maiorIdElementoSistema_PD; idElementoSistema++) {

						/////////////////////////////////////////////////////////////////////////////////////
						//Atualiza limites das restrições e fator de participação dos elementos da restrição
						/////////////////////////////////////////////////////////////////////////////////////

						SmartEnupla<Periodo, bool> horizonte_info_PD;

						for (int pos = 0; pos < int(periodos_PD.size()); pos++)
							horizonte_info_PD.addElemento(periodos_PD.at(pos), true);


						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

								const double sobreposicao = periodo.sobreposicao(periodo_PD);

								if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

									if (periodo > periodo_REF)//Atualiza o periodo_REF para depois atualizar os limites do conjunto de restrições originais
										periodo_REF = periodo;

									////

									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
									IdPatamarCarga maiorIdPatamarCarga_PD = IdPatamarCarga_Nenhum;

									if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_lim_inf) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getIterador2Final(AttMatrizRestricaoEletrica_lim_inf, periodo_PD, IdPatamarCarga());
									else if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_lim_sup) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getIterador2Final(AttMatrizRestricaoEletrica_lim_sup, periodo_PD, IdPatamarCarga());
									else if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_abs_inf) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getIterador2Final(AttMatrizRestricaoEletrica_var_abs_inf, periodo_PD, IdPatamarCarga());
									else if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_abs_sup) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getIterador2Final(AttMatrizRestricaoEletrica_var_abs_sup, periodo_PD, IdPatamarCarga());
									else if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_rel_inf) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getIterador2Final(AttMatrizRestricaoEletrica_var_rel_inf, periodo_PD, IdPatamarCarga());
									else if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_rel_sup) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getIterador2Final(AttMatrizRestricaoEletrica_var_rel_sup, periodo_PD, IdPatamarCarga());

									if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
										throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");

									////

									//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

									if(dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_lim_inf) > 0)
										a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_inf, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getElementoMatriz(AttMatrizRestricaoEletrica_lim_inf, periodo_PD, IdPatamarCarga_1, double()));
										
									if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_lim_sup) > 0)
										a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_sup, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getElementoMatriz(AttMatrizRestricaoEletrica_lim_sup, periodo_PD, IdPatamarCarga_1, double()));

									if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_abs_inf) > 0)
										a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_var_abs_inf, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getElementoMatriz(AttMatrizRestricaoEletrica_var_abs_inf, periodo_PD, IdPatamarCarga_1, double()));

									if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_abs_sup) > 0)
										a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_var_abs_sup, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getElementoMatriz(AttMatrizRestricaoEletrica_var_abs_sup, periodo_PD, IdPatamarCarga_1, double()));

									if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_rel_inf) > 0)
										a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_var_rel_inf, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getElementoMatriz(AttMatrizRestricaoEletrica_var_rel_inf, periodo_PD, IdPatamarCarga_1, double()));

									if (dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getSizeMatriz(AttMatrizRestricaoEletrica_var_rel_sup) > 0)
										a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_var_rel_sup, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).getElementoMatriz(AttMatrizRestricaoEletrica_var_rel_sup, periodo_PD, IdPatamarCarga_1, double()));


									for (IdElementoSistema idElementoSistema = IdElementoSistema_1; idElementoSistema <= maiorIdElementoSistema_PD; idElementoSistema++) {
										a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).vetorElementoSistema.at(idElementoSistema).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoEletrica.at(idRestricaoEletrica_PD).vetorElementoSistema.at(idElementoSistema).getElementoMatriz(AttMatrizElementoSistema_fator_participacao, periodo_PD, IdPatamarCarga_1, double()));
									}//for (IdElementoSistema idElementoSistema = IdElementoSistema_1; idElementoSistema <= maiorIdElementoSistema_PD; idElementoSistema++) {

									//}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

								}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

							}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					}//is_all_elementos_restricao_in_CP

				}//for (IdRestricaoEletrica idRestricaoEletrica_PD = IdRestricaoEletrica_1; idRestricaoEletrica_PD <= maiorIdRestricaoEletrica_PD; idRestricaoEletrica_PD++) {

				//*******************************************************************
				//2. Atualiza restrições originais no CP
				//   Deixa os limites abertos para os períodos dentro do horizonte_PD
				//*******************************************************************
				for (IdRestricaoEletrica idRestricaoEletrica = IdRestricaoEletrica_1; idRestricaoEletrica <= maiorIdRestricaoEletrica_REF; idRestricaoEletrica++) {

					for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						if (periodo <= periodo_REF) {//Abre os limites da restrição para os periodos anteriores ao último periodo_REF (perioodo_final do horizonte_PD)

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
								a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_inf, periodo, idPatamarCarga, getdoubleFromChar("min"));
								a_dados.vetorRestricaoEletrica.at(idRestricaoEletrica).setElemento(AttMatrizRestricaoEletrica_lim_sup, periodo, idPatamarCarga, getdoubleFromChar("max"));
							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//if (periodo <= periodo_REF) {
						else
							break; //Evita percorrer o horizonte todo

					}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				}//for (IdRestricaoEletrica idRestricaoEletrica = IdRestricaoEletrica_1; idRestricaoEletrica <= maiorIdRestricaoEletrica_REF; idRestricaoEletrica++) {

				//*******************************************************************
				//3. Atualiza INTERCAMBIOS no CP (a exceção de Itaipu e Ande)
				//   Deixa o lim_sup aberto para os períodos dentro do horizonte_PD
				//*******************************************************************

				const IdIntercambio maiorIdIntercambio = a_dados.getMaiorId(IdIntercambio());
				for (IdIntercambio idIntercambio = IdIntercambio_1; idIntercambio <= maiorIdIntercambio; idIntercambio++) {

					const IdSubmercado submercado_origem = a_dados.vetorIntercambio.at(idIntercambio).getAtributo(AttComumIntercambio_submercado_origem, IdSubmercado());
					const IdSubmercado submercado_destino = a_dados.vetorIntercambio.at(idIntercambio).getAtributo(AttComumIntercambio_submercado_destino, IdSubmercado());

					if (submercado_origem != IdSubmercado_ITAIPU && submercado_destino != IdSubmercado_ITAIPU && submercado_origem != IdSubmercado_ANDE && submercado_destino != IdSubmercado_ANDE) {

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							if (periodo <= periodo_REF) {//Abre os limites da restrição para os periodos anteriores ao último periodo_REF (perioodo_final do horizonte_PD)

								const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

								for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
									a_dados.vetorIntercambio.at(idIntercambio).setElemento(AttMatrizIntercambio_potencia_maxima, periodo, idPatamarCarga, getdoubleFromChar("max"));
								}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

							}//if (periodo <= periodo_REF) {
							else
								break; //Evita percorrer o horizonte todo

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					}//if (submercado_origem != IdSubmercado_ITAIPU && submercado_destino != IdSubmercado_ITAIPU && submercado_origem != IdSubmercado_ANDE && submercado_destino != IdSubmercado_ANDE) {

				}//for (IdIntercambio idIntercambio = IdIntercambio_1; idIntercambio <= maiorIdIntercambio; idIntercambio++) {


			}//try {
			catch (const std::exception& erro) { throw std::invalid_argument("Erro is_carregar_PD_restricoes_eletricas: \n" + std::string(erro.what())); }

		}//if (is_carregar_PD_restricoes_eletricas) {

		//////////////////////////////////////////////////////////////////////////////
		//RESTRICAO_OPERATIVA_UHE_AttComumOperacional
		//RESTRICAO_OPERATIVA_UHE_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//RESTRICAO_OPERATIVA_UHE_ELEMENTO_SISTEMA_AttComumOperacional
		//RESTRICAO_OPERATIVA_UHE_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga
		//////////////////////////////////////////////////////////////////////////////

		if (is_carregar_PD_restricoes_hidraulicas) {

			try {

				std::cout << "Carregando arquivo de preConfiguracao: RESTRICAO_OPERATIVA_UHE_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: RESTRICAO_OPERATIVA_UHE_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: RESTRICAO_OPERATIVA_UHE_ELEMENTO_SISTEMA_AttComumOperacional.csv..." << std::endl;
				std::cout << "Carregando arquivo de preConfiguracao: RESTRICAO_OPERATIVA_UHE_ELEMENTO_SISTEMA_AttMatrizOperacional_PorPeriodoPorIdPatamarCarga.csv..." << std::endl;

				//Informação para atualizar os limites das restrições originais: Seus limites vão ser "liberados" nos períodos do horizonte das restrições PD
				const IdRestricaoOperativaUHE maiorIdRestricaoOperativaUHE_REF = a_dados.getMaiorId(IdRestricaoOperativaUHE()); //maior idRestricaoOperativaUHE do conjunto de restrições originais
				Periodo periodo_REF = horizonte_estudo.getIteradorInicial(); //Período a partir do qual vão ser consideradas as restrições originais (atualiza-se a partir do periodo_final_PD)

				//*******************************************************************
				//1. Instancia as restrições PD no CP
				//   Deixa os limites abertos para os períodos fora do horizonte_PD
				//*******************************************************************
				const IdRestricaoOperativaUHE maiorIdRestricaoOperativaUHE_PD = dados_PD.getMaiorId(IdRestricaoOperativaUHE());

				for (IdRestricaoOperativaUHE idRestricaoOperativaUHE_PD = IdRestricaoOperativaUHE_1; idRestricaoOperativaUHE_PD <= maiorIdRestricaoOperativaUHE_PD; idRestricaoOperativaUHE_PD++) {

					bool is_considerar_restricao_in_CP = true;

					if (true) {

						const TipoVariavelRestricaoOperativa tipoVariavelRestricaoOperativa = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(IdElementoSistema_1).getAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa());

						if (tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_nivel_final || tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_final) {

							if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_abs_inf) > 0 || dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_abs_sup) > 0 \
								|| dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_rel_inf) > 0 || dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_rel_sup) > 0) {

								is_considerar_restricao_in_CP = false;
							}

						}//if (tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_nivel_final || tipoVariavelRestricaoOperativa == TipoVariavelRestricaoOperativa_volume_final) {

					}//if (true) {

					if (is_considerar_restricao_in_CP) {
						//Validação do horizonte_informacao_PD_pre_config
						std::vector<Periodo> periodos_PD;

						if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_lim_inf) > 0)
							periodos_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getMatriz(AttMatrizRestricaoOperativaUHE_lim_inf, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());
						else if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_lim_sup) > 0)
							periodos_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getMatriz(AttMatrizRestricaoOperativaUHE_lim_sup, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());
						else if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_abs_inf) > 0)
							periodos_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getMatriz(AttMatrizRestricaoOperativaUHE_var_abs_inf, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());
						else if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_abs_sup) > 0)
							periodos_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getMatriz(AttMatrizRestricaoOperativaUHE_var_abs_sup, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());
						else if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_rel_inf) > 0)
							periodos_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getMatriz(AttMatrizRestricaoOperativaUHE_var_rel_inf, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());
						else if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_rel_sup) > 0)
							periodos_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getMatriz(AttMatrizRestricaoOperativaUHE_var_rel_sup, Periodo(), IdPatamarCarga(), double()).getIteradores(horizonte_estudo.getIteradorInicial(), horizonte_estudo.getIteradorFinal());


						const Periodo periodo_inicial_PD = periodos_PD.at(0);
						const Periodo periodo_final_PD = periodos_PD.at(int(periodos_PD.size()) - 1);

						validar_horizonte_informacao_PD_pre_config(periodo_inicial_PD, periodo_final_PD);

						////////////////////////////////////////
						//Instancia as novas restrições PD no CP
						////////////////////////////////////////

						RestricaoOperativaUHE restricaoOperativaUHE;

						const IdRestricaoOperativaUHE idRestricaoOperativaUHE = IdRestricaoOperativaUHE(a_dados.getMaiorId(IdRestricaoOperativaUHE()) + 1);

						restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_idRestricaoOperativaUHE, idRestricaoOperativaUHE);

						restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_nome, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getAtributo(AttComumRestricaoOperativaUHE_nome, std::string()));
						restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoHidraulica, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoHidraulica, TipoRestricaoHidraulica()));
						restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_penalidade, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getAtributo(AttComumRestricaoOperativaUHE_penalidade, double()));
						restricaoOperativaUHE.setAtributo(AttComumRestricaoOperativaUHE_vlr_ini, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getAtributo(AttComumRestricaoOperativaUHE_vlr_ini, double()));
						a_dados.vetorRestricaoOperativaUHE.add(restricaoOperativaUHE);

						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero_lim(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_menos_inf_lim(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_inf_lim(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

						//Os atributos de variação só tem por construção IdPatamarCarga_1
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_zero_var(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(IdPatamarCarga_1, 0.0)));
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_menos_inf_var(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(IdPatamarCarga_1, getdoubleFromChar("min"))));
						SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> matriz_inf_var(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(IdPatamarCarga_1, getdoubleFromChar("max"))));

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);
							matriz_zero_lim.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));
							matriz_menos_inf_lim.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("min"))));
							matriz_inf_lim.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, getdoubleFromChar("max"))));

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_lim_inf) > 0)
							a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setMatriz(AttMatrizRestricaoOperativaUHE_lim_inf, matriz_menos_inf_lim);

						if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_lim_sup) > 0)
							a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setMatriz(AttMatrizRestricaoOperativaUHE_lim_sup, matriz_inf_lim);

						if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_abs_inf) > 0)
							a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setMatriz(AttMatrizRestricaoOperativaUHE_var_abs_inf, matriz_inf_var);

						if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_abs_sup) > 0)
							a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setMatriz(AttMatrizRestricaoOperativaUHE_var_abs_sup, matriz_inf_var);

						if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_rel_inf) > 0)
							a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setMatriz(AttMatrizRestricaoOperativaUHE_var_rel_inf, matriz_inf_var);

						if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_rel_sup) > 0)
							a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setMatriz(AttMatrizRestricaoOperativaUHE_var_rel_sup, matriz_inf_var);

						////////////////////////////////
						//Elementos Restrição
						////////////////////////////////

						const IdElementoSistema maiorIdElementoSistema_PD = dados_PD.getMaiorId(idRestricaoOperativaUHE_PD, IdElementoSistema());

						for (IdElementoSistema idElementoSistema = IdElementoSistema_1; idElementoSistema <= maiorIdElementoSistema_PD; idElementoSistema++) {

							ElementoSistema elementoSistema;
							elementoSistema.setAtributo(AttComumElementoSistema_idElementoSistema, idElementoSistema);

							elementoSistema.setAtributo(AttComumElementoSistema_tipo_elemento, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_tipo_elemento, TipoElementoSistema()));
							elementoSistema.setAtributo(AttComumElementoSistema_conjuntohidraulico, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_conjuntohidraulico, IdConjuntoHidraulico()));
							elementoSistema.setAtributo(AttComumElementoSistema_hidreletrica, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_hidreletrica, IdHidreletrica()));
							elementoSistema.setAtributo(AttComumElementoSistema_termeletrica, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_termeletrica, IdTermeletrica()));
							elementoSistema.setAtributo(AttComumElementoSistema_demandaEspecial, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_demandaEspecial, IdDemandaEspecial()));
							elementoSistema.setAtributo(AttComumElementoSistema_unidadeTermeletrica, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_unidadeTermeletrica, IdUnidadeUTE()));
							elementoSistema.setAtributo(AttComumElementoSistema_contrato, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_contrato, IdContrato()));
							elementoSistema.setAtributo(AttComumElementoSistema_intercambio, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_intercambio, IdIntercambio()));
							elementoSistema.setAtributo(AttComumElementoSistema_renovavel, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_renovavel, IdRenovavel()));
							elementoSistema.setAtributo(AttComumElementoSistema_usina_elevatoria, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_usina_elevatoria, IdUsinaElevatoria()));
							elementoSistema.setAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getAtributo(AttComumElementoSistema_tipoVariavelRestricaoOperativa, TipoVariavelRestricaoOperativa()));

							////

							elementoSistema.setMatriz(AttMatrizElementoSistema_fator_participacao, matriz_zero_lim);//Para restrições var pode ter a estrutura das restrições lim
							a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.add(elementoSistema);

						}//for (IdElementoSistema idElementoSistema = IdElementoSistema_1; idElementoSistema <= maiorIdElementoSistema_PD; idElementoSistema++) {

						/////////////////////////////////////////////////////////////////////////////////////
						//Atualiza limites das restrições e fator de participação dos elementos da restrição
						/////////////////////////////////////////////////////////////////////////////////////

						SmartEnupla<Periodo, bool> horizonte_info_PD;

						for (int pos = 0; pos < int(periodos_PD.size()); pos++)
							horizonte_info_PD.addElemento(periodos_PD.at(pos), true);

						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

							for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

								const double sobreposicao = periodo.sobreposicao(periodo_PD);

								if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

									if (periodo > periodo_REF)//Atualiza o periodo_REF para depois atualizar os limites do conjunto de restrições originais
										periodo_REF = periodo;

									//////
									const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

									IdPatamarCarga maiorIdPatamarCarga_PD = IdPatamarCarga_Nenhum;

									if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_lim_inf) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getIterador2Final(AttMatrizRestricaoOperativaUHE_lim_inf, periodo_PD, IdPatamarCarga());

									else if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_lim_sup) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getIterador2Final(AttMatrizRestricaoOperativaUHE_lim_sup, periodo_PD, IdPatamarCarga());

									else if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_abs_inf) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getIterador2Final(AttMatrizRestricaoOperativaUHE_var_abs_inf, periodo_PD, IdPatamarCarga());

									else if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_abs_sup) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getIterador2Final(AttMatrizRestricaoOperativaUHE_var_abs_sup, periodo_PD, IdPatamarCarga());

									else if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_rel_inf) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getIterador2Final(AttMatrizRestricaoOperativaUHE_var_rel_inf, periodo_PD, IdPatamarCarga());

									else if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_rel_sup) > 0)
										maiorIdPatamarCarga_PD = dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getIterador2Final(AttMatrizRestricaoOperativaUHE_var_rel_sup, periodo_PD, IdPatamarCarga());


									if (maiorIdPatamarCarga != maiorIdPatamarCarga_PD || maiorIdPatamarCarga != IdPatamarCarga_1)
										throw std::invalid_argument("Nao compativel o maiorIdPatamarCarga entre o estudo CP e os dadosPreConfig_PD");

									//////

									//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

									if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_lim_inf) > 0)
										a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_inf, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getElementoMatriz(AttMatrizRestricaoOperativaUHE_lim_inf, periodo_PD, IdPatamarCarga_1, double()));

									if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_lim_sup) > 0)
										a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_sup, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getElementoMatriz(AttMatrizRestricaoOperativaUHE_lim_sup, periodo_PD, IdPatamarCarga_1, double()));

									if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_abs_inf) > 0)
										a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_var_abs_inf, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getElementoMatriz(AttMatrizRestricaoOperativaUHE_var_abs_inf, periodo_PD, IdPatamarCarga_1, double()));

									if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_abs_sup) > 0)
										a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_var_abs_sup, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getElementoMatriz(AttMatrizRestricaoOperativaUHE_var_abs_sup, periodo_PD, IdPatamarCarga_1, double()));

									if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_rel_inf) > 0)
										a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_var_rel_inf, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getElementoMatriz(AttMatrizRestricaoOperativaUHE_var_rel_inf, periodo_PD, IdPatamarCarga_1, double()));

									if (dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getSizeMatriz(AttMatrizRestricaoOperativaUHE_var_rel_sup) > 0)
										a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_var_rel_sup, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).getElementoMatriz(AttMatrizRestricaoOperativaUHE_var_rel_sup, periodo_PD, IdPatamarCarga_1, double()));

									for (IdElementoSistema idElementoSistema = IdElementoSistema_1; idElementoSistema <= maiorIdElementoSistema_PD; idElementoSistema++) {
										a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).vetorElementoSistema.at(idElementoSistema).setElemento(AttMatrizElementoSistema_fator_participacao, periodo, IdPatamarCarga_1, dados_PD.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE_PD).vetorElementoSistema.at(idElementoSistema).getElementoMatriz(AttMatrizElementoSistema_fator_participacao, periodo_PD, IdPatamarCarga_1, double()));
									}//for (IdElementoSistema idElementoSistema = IdElementoSistema_1; idElementoSistema <= maiorIdElementoSistema_PD; idElementoSistema++) {

									//}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

								}//if (sobreposicao == 1.0 && periodo.getTipoPeriodo() >= periodo_PD.getTipoPeriodo()) {

							}//for (Periodo periodo_PD = periodo_inicial_PD; periodo_PD <= periodo_final_PD; horizonte_info_PD.incrementarIterador(periodo_PD)) {

						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

					}//if (is_considerar_restricao_in_CP) {

				}//for (IdRestricaoOperativaUHE idRestricaoOperativaUHE_PD = IdRestricaoOperativaUHE_1; idRestricaoOperativaUHE_PD <= maiorIdRestricaoOperativaUHE_PD; idRestricaoOperativaUHE_PD++) {

				//*******************************************************************
				//2. Atualiza restrições originais no CP
				//   Deixa os limites abertos para os períodos dentro do horizonte_PD
				//*******************************************************************
				for (IdRestricaoOperativaUHE idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1; idRestricaoOperativaUHE <= maiorIdRestricaoOperativaUHE_REF; idRestricaoOperativaUHE++) {

					for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

						if (periodo <= periodo_REF) {//Abre os limites da restrição para os periodos anteriores ao último periodo_REF (perioodo_final do horizonte_PD)

							const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

							for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {
								a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_inf, periodo, idPatamarCarga, getdoubleFromChar("min"));
								a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttMatrizRestricaoOperativaUHE_lim_sup, periodo, idPatamarCarga, getdoubleFromChar("max"));
							}//for (IdPatamarCarga idPatamarCarga = IdPatamarCarga_1; idPatamarCarga <= maiorIdPatamarCarga; idPatamarCarga++) {

						}//if (periodo <= periodo_REF) {
						else
							break; //Evita percorrer o horizonte todo

					}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

				}//for (IdRestricaoOperativaUHE idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1; idRestricaoOperativaUHE <= maiorIdRestricaoOperativaUHE_REF; idRestricaoOperativaUHE++) {

				//*******************************************************************
				//3. Atualiza AttVetorRestricaoOperativaUHE_lim_sup_folga_inf
				// a partir do horizonte CP deixa lim_sup_folga_inf = inf
				//*******************************************************************
				for (IdRestricaoOperativaUHE idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1; idRestricaoOperativaUHE <= maiorIdRestricaoOperativaUHE_REF; idRestricaoOperativaUHE++) {
					if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getSizeVetor(AttVetorRestricaoOperativaUHE_lim_sup_folga_inf) > 0) {
						for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {
							if (periodo >= periodo_REF)
								a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).setElemento(AttVetorRestricaoOperativaUHE_lim_sup_folga_inf, periodo, getdoubleFromChar("max"));
						}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {
					}//if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getSizeVetor(AttVetorRestricaoOperativaUHE_lim_sup_folga_inf) > 0) {
				}//for (IdRestricaoOperativaUHE idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1; idRestricaoOperativaUHE <= maiorIdRestricaoOperativaUHE_REF; idRestricaoOperativaUHE++) {

			}//try {
			catch (const std::exception& erro) { throw std::invalid_argument("Erro is_carregar_PD_restricoes_hidraulicas: \n" + std::string(erro.what())); }

		}//if (is_carregar_PD_restricoes_hidraulicas) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_valores_com_DadosEntradaPD_PRECONFIG: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::validar_horizonte_informacao_PD_pre_config(const Periodo a_periodo_inicial_PD, const Periodo a_periodo_final_PD) {

	try {

		//*********************************************************************************************************
		//Validação do período da info da PD (Não é aceita informação do PD sem ser uma semana operativa completa):
		//(i)  o período inicial da info PD deve coincidir com a algum período inicial deck
		//(ii) o período final da info PD deve coincidir com a algum período final deck
		//*********************************************************************************************************

		bool is_periodo_inicial_PD_valido = false;
		bool is_periodo_final_PD_valido = false;

		const Periodo periodo_inicial_PD_TESTE = Periodo(TipoPeriodo_minuto, a_periodo_inicial_PD);
		const Periodo periodo_final_PD_TESTE = Periodo(TipoPeriodo_minuto, a_periodo_final_PD + 1);

		for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

			if (Periodo(TipoPeriodo_minuto, periodo_deck) == periodo_inicial_PD_TESTE)
				is_periodo_inicial_PD_valido = true;

			if (Periodo(TipoPeriodo_minuto, periodo_deck + 1) == periodo_final_PD_TESTE)
				is_periodo_final_PD_valido = true;

			if (is_periodo_inicial_PD_valido && is_periodo_final_PD_valido)
				break;

		}//for (Periodo periodo_deck = horizonte_estudo_DECK.getIteradorInicial(); periodo_deck <= horizonte_estudo_DECK.getIteradorFinal(); horizonte_estudo_DECK.incrementarIterador(periodo_deck)) {

		if (!is_periodo_inicial_PD_valido)
			throw std::invalid_argument("Periodo inicial dos dados dadosPreConfig_PD deve coincidir com o inicio de uma semana operativa");

		if (!is_periodo_final_PD_valido)
			throw std::invalid_argument("Periodo final dos dados dadosPreConfig_PD deve coincidir com o fim de uma semana operativa");

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::validar_horizonte_informacao_PD_pre_config: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualizar_codigo_posto_acoplamento_ENA_das_hidreletricas_instanciadas(Dados& a_dados) {

	try {

		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			if (idHidreletrica != IdHidreletrica_176_COMPPAFMOX && idHidreletrica != IdHidreletrica_168_ENA_SOBRADINHO && idHidreletrica != IdHidreletrica_172_ENA_ITAPARICA && idHidreletrica != IdHidreletrica_178_ENA_XINGO) {//Estas usinas já tem o codigo_posto_acoplamento_ENA instanciado

				/////////////////////////////////
				bool is_registro_NPOSNW = false;

				if (lista_modificacaoUHE.size() > int(idHidreletrica)) {//Pode ter usinas do MP que não existem no CP

					for (int idModificacaoUHE = 0; idModificacaoUHE < lista_modificacaoUHE.at(idHidreletrica).size(); idModificacaoUHE++) {

						if (lista_modificacaoUHE.at(idHidreletrica).at(idModificacaoUHE).tipo_de_modificacao == TipoModificacaoUHE_NPOSNW) {
							is_registro_NPOSNW = true;
							break;
						}//if (lista_modificacaoUHE.at(idHidreletrica).at(idModificacaoUHE).tipo_de_modificacao == TipoModificacaoUHE_NPOSNW) {

					}//for (int idModificacaoUHE = 0; idModificacaoUHE < lista_modificacaoUHE.at(idHidreletrica).size(); idModificacaoUHE++) {

				}//if (lista_modificacaoUHE.size() > int(idHidreletrica)) {


				if (!is_registro_NPOSNW) //Somente atualiza usinas que NÃO tenham tido registro NPOSNW
					a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_codigo_posto_acoplamento_ENA, a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_codigo_posto, int()));

			}//if 

		}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualizar_codigo_posto_acoplamento_ENA_das_hidreletricas_instanciadas: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::atualiza_codigo_posto_acoplamento_ENA_regras_especiais(Dados& a_dados) {

	try {

		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			const int codigo_usina = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_codigo_usina, int());

			if (codigo_usina == 172)//172-Itaparica com posto de acoplamento para cálculo das ENAs = 172
				a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_codigo_posto_acoplamento_ENA, 172);
			else if (codigo_usina == 178) //178-Xingó com posto de acoplamento para cálculo das ENAs = 178
				a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_codigo_posto_acoplamento_ENA, 178);
			else if (codigo_usina == 173) //173-Moxotó com posto de acoplamento para cálculo das ENAs = 0 (afluência = 0)
				a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_codigo_posto_acoplamento_ENA, 0);
			else if (codigo_usina == 174) //174-P.Afonso123 com posto de acoplamento para cálculo das ENAs = 0 (afluência = 0)
				a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_codigo_posto_acoplamento_ENA, 0);
			else if (codigo_usina == 175) //175-P.Afonso4 com posto de acoplamento para cálculo das ENAs = 0 (afluência = 0)
				a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_codigo_posto_acoplamento_ENA, 0);

		} // for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

	} // try{
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::atualiza_codigo_posto_acoplamento_ENA_regras_especiais: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::instanciar_jusante_JUSENA(Dados& a_dados)
{
	try {

		const IdHidreletrica idHidreletricaIni = a_dados.getMenorId(IdHidreletrica());
		const IdHidreletrica idHidreletricaOut = a_dados.getIdOut(IdHidreletrica());

		for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

			/////////////////////////////////
			bool is_registro_JUSENA = false;

			if (lista_modificacaoUHE.size() > int(idHidreletrica)) {//Pode ter usinas do MP que não existem no CP

				for (int idModificacaoUHE = 0; idModificacaoUHE < lista_modificacaoUHE.at(idHidreletrica).size(); idModificacaoUHE++) {

					if (lista_modificacaoUHE.at(idHidreletrica).at(idModificacaoUHE).tipo_de_modificacao == TipoModificacaoUHE_JUSENA) {
						is_registro_JUSENA = true;
						break;
					}//if (lista_modificacaoUHE.at(idHidreletrica).at(idModificacaoUHE).tipo_de_modificacao == TipoModificacaoUHE_JUSENA) {

				}//for (int idModificacaoUHE = 0; idModificacaoUHE < lista_modificacaoUHE.at(idHidreletrica).size(); idModificacaoUHE++) {

			}//if (lista_modificacaoUHE.size() > int(idHidreletrica)) {

			/////////////////////////////////

			if (!is_registro_JUSENA && idHidreletrica != IdHidreletrica_176_COMPPAFMOX) {//Somente atualiza para usinas que não tem registro JUSENA (já o jusante_JUSENA foi atualizado previamente)

				const IdHidreletrica idHidreletrica_jusante = a_dados.vetorHidreletrica.at(idHidreletrica).getAtributo(AttComumHidreletrica_jusante, IdHidreletrica());
				a_dados.vetorHidreletrica.at(idHidreletrica).setAtributo(AttComumHidreletrica_jusante_JUSENA, idHidreletrica_jusante);
			}//if (!is_registro_JUSENA) {

		}//for (IdHidreletrica idHidreletrica = idHidreletricaIni; idHidreletrica < idHidreletricaOut; a_dados.vetorHidreletrica.incr(idHidreletrica)) {

	}//	try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::instanciar_jusante_JUSENA: \n" + std::string(erro.what())); }

}

void LeituraCEPEL::validacoes_DC(Dados& a_dados, const std::string a_diretorio, const std::string a_revisao) {

	try {

		const SmartEnupla<Periodo, IdEstagio> horizonte_estudo = a_dados.getVetor(AttVetorDados_horizonte_estudo, Periodo(), IdEstagio());
		const SmartEnupla<IdEstagio, Periodo> horizonte_otimizacao = a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo());


		////////////////////////////////////////////////////
		// Detecta se existe arquivo de cortes NEWAVE
		////////////////////////////////////////////////////
		std::string nomeArquivo_cortes_NW = "nenhum";

		const std::string nomeArquivo_fcfnwn = a_diretorio + "//DadosAdicionais//Cortes_NEWAVE//fcfnwn." + a_revisao;
		const std::string nomeArquivo_nwlistcf = a_diretorio + "//DadosAdicionais//Cortes_NEWAVE//nwlistcf.rel";

		std::ifstream leituraArquivo_fcfnwn(nomeArquivo_fcfnwn);
		std::ifstream leituraArquivo_nwlistcf(nomeArquivo_nwlistcf);

		if (leituraArquivo_fcfnwn.is_open()) {
			nomeArquivo_cortes_NW = nomeArquivo_fcfnwn;
			leituraArquivo_fcfnwn.close();
		}//if (leituraArquivo_fcfnwn.is_open()) {


		if (leituraArquivo_nwlistcf.is_open()) {
			nomeArquivo_cortes_NW = nomeArquivo_nwlistcf;
			leituraArquivo_nwlistcf.close();
		}//if (leituraArquivo_nwlistcf.is_open()){
		
		///////////////////////////////////////////////////////////////////////////////////////////////
		//Instancia hidreletricas sem produção para acoplamento cortes NW
		///////////////////////////////////////////////////////////////////////////////////////////////

		if (nomeArquivo_cortes_NW != "nenhum") {

			for (int pos = 0; pos < int(idHidreletricas_sem_producao.size()); pos++)
				instanciar_hidreletricas_sem_producao_para_acoplamento_cortes_NW(a_dados, idHidreletricas_sem_producao.at(pos), codigo_usina_idHidreletricas_sem_producao.at(pos), codigo_posto_idHidreletricas_sem_producao.at(pos), codigo_posto_acoplamento_ENA_idHidreletricas_sem_producao.at(pos), codigo_ONS_REE_idHidreletricas_sem_producao.at(pos));

			leitura_CADUSIH_201904_NW25_DC29_DES16(a_dados, a_diretorio + "//HIDR.DAT", hidreletricasPreConfig_instanciadas, false, false, true, 176);//Carrega informação da IdHidreletrica_176_COMPPAFMOX

		}//if (nomeArquivo_cortes_NW != "nenhum") {

		aplicarModificacoesUHE(a_dados);

		valida_bacia_sao_francisco(a_dados);
		modifica_lista_jusante_hidreletrica_com_casos_validados_CP(a_dados);
		instanciar_jusante_JUSENA(a_dados); //Para desacoplamento do corte NEWAVE (caso necessário)-> Atributo que foi atualizado em aplicarModificacoesUHE(a_dados) para usinas com registro JUSENA

		atualizar_codigo_posto_acoplamento_ENA_das_hidreletricas_instanciadas(a_dados); //Atualiza codigo_posto_acoplamento_ENA para ser compatível com as regras de cálculo da ENA de acoplamento
		atualiza_codigo_posto_acoplamento_ENA_regras_especiais(a_dados);//Para as usinas do REE 3 - Nordeste (Itaparica e Xingó setadas na otimização com posto 300, i.e., aflu incremental = 0) -> Define o NPOSNW = posto_hidr_dat para cálculo das ENAs

		///////////////////////////////////////////////////////////////////////////////////////////////
		//Instancia hidreletricas sem produção para TipoRestricaoHidraulica_energia_armazenada
		// (caso não tenha sido instanciada).
		//  Basicamente 176-COMP MOX-PAF é necessário para o cálculo da produtibilidade_acumulada_EAR 
		///////////////////////////////////////////////////////////////////////////////////////////////

		if (true) {

			const IdRestricaoOperativaUHE maiorIdRestricaoOperativaUHE = a_dados.getMaiorId(IdRestricaoOperativaUHE());

			for (IdRestricaoOperativaUHE idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1; idRestricaoOperativaUHE <= maiorIdRestricaoOperativaUHE; idRestricaoOperativaUHE++) {

				if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoHidraulica, TipoRestricaoHidraulica()) == TipoRestricaoHidraulica_energia_armazenada) {

					const IdHidreletrica idHidreletrica = IdHidreletrica_176_COMPPAFMOX;

					if (!a_dados.vetorHidreletrica.isInstanciado(idHidreletrica)) {

						const int codigo_usina_COMP_MOX = 176;
						const int codigo_posto = 176;
						const int codigo_posto_acoplamento_ENA = 976;
						const int codigo_ONS_REE = 3;

						instanciar_hidreletricas_sem_producao_para_acoplamento_cortes_NW(a_dados, idHidreletrica, codigo_usina_COMP_MOX, codigo_posto, codigo_posto_acoplamento_ENA, codigo_ONS_REE);
						leitura_CADUSIH_201904_NW25_DC29_DES16(a_dados, a_diretorio + "//HIDR.DAT", hidreletricasPreConfig_instanciadas, false, false, true, 176);//Carrega informação da IdHidreletrica_176_COMPPAFMOX

					}//if (!a_dados.vetorHidreletrica.isInstanciado(idHidreletrica)) {

					break;
				}//if (a_dados.vetorRestricaoOperativaUHE.at(idRestricaoOperativaUHE).getAtributo(AttComumRestricaoOperativaUHE_tipoRestricaoHidraulica, TipoRestricaoHidraulica()) == TipoRestricaoHidraulica_energia_armazenada) {
			}//for (IdRestricaoOperativaUHE idRestricaoOperativaUHE = IdRestricaoOperativaUHE_1; idRestricaoOperativaUHE <= maiorIdRestricaoOperativaUHE; idRestricaoOperativaUHE++) {

		}//if (true) {

		////////////////////////////////////
		//Extensão do horizonte
		////////////////////////////////////
		atualizar_valores_periodos_horizonte_expandido(a_dados);//Atualiza valores dos vetores que tenham periodos > periodo_final_DECK (caso de extensão do horizonte CP)
		atualizar_valores_periodos_horizonte_expandido_com_DadosEntradaMP_PRECONFIG(a_dados, a_dados.getAtributo(AttComumDados_diretorio_entrada_dados, std::string()) + "_PRECONFIG" + "//DadosEntradaMP_PRECONFIG");

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Lê volumes metas (se existir relato.rvX e relato2.rvX) e turbinamento_maximo (se existir relato.rvX)

		const bool lido_turbinamento_maximo_from_relato_e_avl_turb_max_DC = leitura_turbinamento_maximo_from_avl_turb_max_DC(a_dados, a_diretorio + "//DadosAdicionais" + "//avl_turb_max.csv");

		if (teste_hidreletrica_volume_meta)
			leitura_volumes_meta_from_dec_oper_usih_DC(a_dados, a_diretorio + "//DadosAdicionais" + "//dec_oper_usih.csv", somente_volume_meta_no_ultimo_estagio);

		leitura_fph_from_avl_cortesfpha_dec_DC(a_dados, a_diretorio + "//DadosAdicionais" + "//avl_cortesfpha_dec." + a_revisao);//Precisa da extensão do horizonte para ter as cotas modificadas com o último período DC

		leitura_range_volume_from_eco_fpha_DC(a_dados, a_diretorio + "//DadosAdicionais" + "//eco_fpha_." + a_revisao);

		if (leitura_vazao_evaporada_meta)
			leitura_vazao_evaporada_meta_from_dec_oper_usih_DC(a_dados, a_diretorio + "//DadosAdicionais" + "//dec_oper_usih.csv");

		if (teste_hidreletrica_potencia_disponivel_meta)
			set_hidreletrica_potencia_disponivel_meta_from_dec_oper_usih_DC(a_dados, a_diretorio + "//DadosAdicionais" + "//dec_oper_usih.csv");

		if (teste_termeletrica_potencia_disponivel_meta)
			set_termeletrica_potencia_disponivel_meta(a_dados);

		if (teste_hidreletrica_vazao_turbinada_disponivel_meta)
			set_hidreletrica_vazao_turbinada_disponivel_meta(a_dados);


		//////////////////////////////////////////////////////////////////////////////////////////////////////////////
		if (!dadosPreConfig_instanciados) {
			a_dados.setAtributo(AttComumDados_tipo_estudo, TipoEstudo_otimizacao_e_simulacao);

			//////////////////////////////////
			//Dados padrao do CP modo DC
			a_dados.setAtributo(AttComumDados_representar_producao_hidreletrica_com_turbinamento_disponivel, false);
			a_dados.setAtributo(AttComumDados_representar_todos_balancos_hidricos_por_volume, true);
			a_dados.setAtributo(AttComumDados_representar_defluencia_disponivel_em_restricoes_hidraulicas, false);
			a_dados.setAtributo(AttComumDados_representar_turbinamento_disponivel_em_restricoes_hidraulicas, false);
			a_dados.setAtributo(AttComumDados_representar_potencia_hidro_disponivel_em_restricoes_hidraulicas, false);
			a_dados.setAtributo(AttComumDados_representar_potencia_termo_disponivel_em_restricoes_hidraulicas, false);
			//////////////////////////////////

			a_dados.setAtributo(AttComumDados_ordem_maxima_auto_correlacao_geracao_cenario_hidrologico, 0);
			a_dados.setAtributo(AttComumDados_tipo_coeficiente_auto_correlacao_geracao_cenario_hidrologico, TipoValor_positivo_e_negativo);
			a_dados.setAtributo(AttComumDados_relaxar_afluencia_incremental_com_viabilidade_hidraulica, false);
			a_dados.setAtributo(AttComumDados_tipo_correlacao_geracao_cenario_hidrologico, TipoCorrelacaoVariaveisAleatorias_sem_correlacao);

			a_dados.setAtributo(AttComumDados_tipo_processamento_paralelo, TipoProcessamentoParalelo_por_abertura);
			a_dados.setAtributo(AttComumDados_numero_maximo_iteracoes, 20);
			a_dados.setAtributo(AttComumDados_iteracao_inicial, IdIteracao_1);

			a_dados.setAtributo(AttComumDados_coficiente_evaporacao_regra_especial, true);

			a_dados.setAtributo(AttComumDados_diretorio_importacao_pos_estudo, std::string("DadosSaidaMP//Otimizacao//AcoplamentoPreEstudo"));
			a_dados.setAtributo(AttComumDados_tipo_aversao_a_risco, TipoAversaoRisco_CVAR);
			a_dados.setAtributo(AttComumDados_selecao_cortes_nivel_dominancia, 0);

		}//if (!dadosPreConfig_instanciados) {

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////

		if (a_dados.getSize1Matriz(a_dados.getMenorId(IdHidreletrica()), IdReservatorio_1, AttMatrizReservatorio_volume_meta) > 0) {

			if (a_dados.getElementoMatriz(a_dados.getMenorId(IdHidreletrica()), IdReservatorio_1, AttMatrizReservatorio_volume_meta, IdCenario_1, horizonte_estudo.getIteradorInicial(), double()) != getdoubleFromChar("max"))
				a_dados.setAtributo(AttComumDados_tipo_estudo, TipoEstudo_simulacao);

		}//if ((a_dados.getSize1Matriz(a_dados.getMenorId(IdHidreletrica()), IdReservatorio_1, AttMatrizReservatorio_volume_meta) > 0)) {

		if (a_dados.getSize1Matriz(a_dados.getMenorId(IdHidreletrica()), AttMatrizHidreletrica_potencia_disponivel_meta) > 0)
			a_dados.setAtributo(AttComumDados_tipo_estudo, TipoEstudo_simulacao);

		////////////////////////////////////////

		EntradaSaidaDados entradaSaidaDados;

		entradaSaidaDados.setDiretorioEntrada(a_dados.getAtributo(AttComumDados_diretorio_entrada_dados, std::string()));
		entradaSaidaDados.setDiretorioSaida(a_dados.getAtributo(AttComumDados_diretorio_saida_dados, std::string()));

		entradaSaidaDados.setImprimirNaTela(false);

		const std::string diretorio_att_operacionais = entradaSaidaDados.getDiretorioEntrada() + "";

		std::string diretorio_att_premissas = "";
		std::string diretorio_exportacao_pos_estudo = "";


		if (a_dados.getAtributo(AttComumDados_tipo_estudo, TipoEstudo()) == TipoEstudo_simulacao) {
			diretorio_att_premissas = entradaSaidaDados.getDiretorioEntrada() + "//Simulacao//AtributosPremissasDECOMP//";
			diretorio_exportacao_pos_estudo = entradaSaidaDados.getDiretorioSaida() + "//Simulacao//AcoplamentoPosEstudo";
		}
		else {
			diretorio_att_premissas = entradaSaidaDados.getDiretorioEntrada() + "//Otimizacao//AtributosPremissasDECOMP";
			diretorio_exportacao_pos_estudo = entradaSaidaDados.getDiretorioSaida() + "//Otimizacao//AcoplamentoPosEstudo";
		}

		if (strCompara(a_dados.getAtributo(AttComumDados_diretorio_importacao_pos_estudo, std::string()), "Nenhum"))
			diretorio_exportacao_pos_estudo = "nenhum";

		const bool imprimir_att_operacionais_sem_recarregar = true;

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Instancia parâmetros do CVaR no CP

		if (a_dados.getSizeVetor(AttVetorDados_lambda_CVAR) == 0) {

			SmartEnupla<IdEstagio, double> vetor_lambda_CVAR(IdEstagio_1, std::vector<double>(int(a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo()).getIteradorFinal()), 0.0));
			vetor_lambda_CVAR.setElemento(a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo()).getIteradorFinal(), 0.0);

			a_dados.setVetor(AttVetorDados_lambda_CVAR, vetor_lambda_CVAR);
		}//if (a_dados.getSizeVetor(AttVetorDados_lambda_CVAR) == 0) {

		////
		if (a_dados.getSizeVetor(AttVetorDados_alpha_CVAR) == 0) {
			SmartEnupla<IdEstagio, double> vetor_alpha_CVAR(IdEstagio_1, std::vector<double>(int(a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo()).getIteradorFinal()), 0.0));
			vetor_alpha_CVAR.setElemento(a_dados.getVetor(AttVetorDados_horizonte_otimizacao, IdEstagio(), Periodo()).getIteradorFinal(), 0.0);

			a_dados.setVetor(AttVetorDados_alpha_CVAR, vetor_alpha_CVAR);

		}//if (a_dados.getSizeVetor(AttVetorDados_alpha_CVAR) == 0) {

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//Atualiza AttMatrizDados_percentual_duracao_patamar_carga
		//Premissa: só instancia idPatamarCarga se o percentual_duracao_patamar_carga > 0
		
		SmartEnupla<Periodo, SmartEnupla<IdPatamarCarga, double>> percentual_duracao_patamar_carga(horizonte_estudo, SmartEnupla<IdPatamarCarga, double>());

		for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

			const IdPatamarCarga maiorIdPatamarCarga = get_maiorIdPatamarCarga_periodo_from_percentual_duracao_patamar_carga(a_dados, periodo);

			percentual_duracao_patamar_carga.setElemento(periodo, SmartEnupla<IdPatamarCarga, double>(IdPatamarCarga_1, std::vector<double>(maiorIdPatamarCarga, 0.0)));

			int numero_patamares_x_periodo = 0;

			for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

				if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
					numero_patamares_x_periodo++;
					const IdPatamarCarga idPatamarCarga = IdPatamarCarga(numero_patamares_x_periodo);
					percentual_duracao_patamar_carga.at(periodo).setElemento(idPatamarCarga, a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()));
				}//if (a_dados.getElementoMatriz(AttMatrizDados_percentual_duracao_patamar_carga, periodo, idPatamarCarga_DECK, double()) > 0.0) {
			}//for (IdPatamarCarga idPatamarCarga_DECK = IdPatamarCarga_1; idPatamarCarga_DECK <= a_dados.getIterador2Final(AttMatrizDados_percentual_duracao_patamar_carga, periodo, IdPatamarCarga()); idPatamarCarga_DECK++) {

		}//for (Periodo periodo = horizonte_estudo.getIteradorInicial(); periodo <= horizonte_estudo.getIteradorFinal(); horizonte_estudo.incrementarIterador(periodo)) {

		a_dados.setMatriz_forced(AttMatrizDados_percentual_duracao_patamar_carga, percentual_duracao_patamar_carga);

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////

		a_dados.validacaoDadosAttComum();

		if (!dadosPreConfig_instanciados) {
			a_dados.setAtributo(AttComumDados_diretorio_entrada_dados, entradaSaidaDados.getDiretorioEntrada());
			a_dados.setAtributo(AttComumDados_diretorio_saida_dados, entradaSaidaDados.getDiretorioSaida());
		}

		////////////////////////////////////////
		// INICIO DEV NOVO PROC ESTOCASTICO

		const Periodo periodo_final_PE_DECOMP = horizonte_otimizacao.at(horizonte_estudo.at(get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados)));

		if (periodo_final_PE_DECOMP < horizonte_otimizacao.at(horizonte_otimizacao.getIteradorFinal())){
			
			if (!dadosPreConfig_instanciados) {
				a_dados.setAtributo(AttComumDados_visitar_todos_cenarios_por_iteracao, false);
				a_dados.setAtributo(AttComumDados_imprimir_geracao_cenario_hidrologico, true);
				a_dados.setAtributo(AttComumDados_ordem_maxima_auto_correlacao_geracao_cenario_hidrologico, 6);
				a_dados.setAtributo(AttComumDados_tipo_correlacao_geracao_cenario_hidrologico, TipoCorrelacaoVariaveisAleatorias_matriz_carga);
				a_dados.setAtributo(AttComumDados_correlacao_dominante_geracao_cenario_hidrologico, 0.85);
			}//if (!dadosPreConfig_instanciados) {
			else {
				if (a_dados.getAtributo(AttComumDados_visitar_todos_cenarios_por_iteracao, bool()))
					throw std::invalid_argument("Pre-config deve ter visitar_todos_cenarios_por_iteracao igual a False | Caso com expansao de horizonte");

			}//	else {
			
		}//if (periodo_final_PE_DECOMP < horizonte_otimizacao.at(horizonte_otimizacao.getIteradorFinal())){
		else {
			if (!dadosPreConfig_instanciados)
				a_dados.setAtributo(AttComumDados_visitar_todos_cenarios_por_iteracao, true);
			else {
				if (!a_dados.getAtributo(AttComumDados_visitar_todos_cenarios_por_iteracao, bool()))
					throw std::invalid_argument("Pre-config deve ter visitar_todos_cenarios_por_iteracao igual a True | Caso sem expansao de horizonte");

			}

		}

		const bool imprimir_exportacao_pos_estudo = a_dados.getAtributo(AttComumDados_imprimir_exportacao_pos_estudo, bool());
		a_dados.setAtributo(AttComumDados_imprimir_exportacao_pos_estudo, false); //Precisa para a lógica de expansão do horizonte de estudo com geração de cenários

		//Define variavel_aleatoria_interna para cada Processo (é realizado logo de estabelecer os cenários resolvidos por cada processo) e das modificaçõesUHE dos postos
		
		if (!processoEstocasticoHidrologicoPreConfig_instanciado)
			define_afluencia_arvore_de_cenarios_postos_CP(a_dados);

		a_dados.adicionaHidreletricasMontante();
		inicializa_vazao_defluente_CP(a_dados);

		define_variavel_aleatoria_interna_CP(a_dados);

		a_dados.validacao_operacional_Dados(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);

		a_dados.definirCenariosPorProcessosEmArranjoResolucao();

		const IdProcesso idProcesso = a_dados.arranjoResolucao.getAtributo(AttComumArranjoResolucao_idProcesso, IdProcesso());
	
		const IdCenario menor_cenario = a_dados.arranjoResolucao.getAtributo(idProcesso, AttComumProcesso_menor_cenario, IdCenario());
		const IdCenario maior_cenario = a_dados.arranjoResolucao.getAtributo(idProcesso, AttComumProcesso_maior_cenario, IdCenario());

		if (!processoEstocasticoHidrologicoPreConfig_instanciado) {
						
			if (!a_dados.processoEstocastico_hidrologico.mapearCenariosEspacoAmostralCompletoPorPeriodo(periodo_final_PE_DECOMP, a_dados.getAtributo(AttComumDados_numero_cenarios, int()), menor_cenario, maior_cenario)) {

				int semente = a_dados.getAtributo(AttComumDados_semente_geracao_cenario_hidrologico, int());

				const Periodo periodo_inicial_PE = a_dados.processoEstocastico_hidrologico.getMatriz(IdVariavelAleatoria_1, AttMatrizVariavelAleatoria_residuo_espaco_amostral, Periodo(), IdRealizacao(), double()).getIteradorInicial();
				const Periodo periodo_final_PE = a_dados.processoEstocastico_hidrologico.getMatriz(IdVariavelAleatoria_1, AttMatrizVariavelAleatoria_residuo_espaco_amostral, Periodo(), IdRealizacao(), double()).getIteradorFinal();

				a_dados.processoEstocastico_hidrologico.mapearCenariosEspacoAmostralPorSorteio(TipoSorteio_uniforme, a_dados.getAtributo(AttComumDados_numero_cenarios, int()), menor_cenario, maior_cenario, semente, periodo_inicial_PE, periodo_final_PE);

			}//if (!a_dados.processoEstocastico_hidrologico.mapearCenariosEspacoAmostralCompletoPorPeriodo(periodo_final_PE_DECOMP, a_dados.getAtributo(AttComumDados_numero_cenarios, int()), menor_cenario, maior_cenario)) {

		}//if (!processoEstocasticoHidrologicoPreConfig_instanciado) {

		// Verifica se existem afluencias na árvore de cenários e aplica relaxação
		//+ Calcula serieTemporal da variavelAleatoria
		if (true) {
			SmartEnupla<Periodo, bool> horizonte_processo_estocastico(a_dados.processoEstocastico_hidrologico.getMatriz(IdVariavelAleatoria_1, AttMatrizVariavelAleatoria_residuo_espaco_amostral, Periodo(), IdRealizacao(), double()), true);
			
			for (IdVariavelAleatoria idVar = IdVariavelAleatoria_1; idVar <= a_dados.processoEstocastico_hidrologico.getMaiorId(IdVariavelAleatoria()); idVar++) {

				if (periodo_final_PE_DECOMP < horizonte_otimizacao.at(horizonte_otimizacao.getIteradorFinal())) {
					a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVar).setAtributo(AttComumVariavelAleatoria_idVariavelAleatoria_determinacao, idVar);
					a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVar).calcularSerieTemporal();
					a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVar).calcularTendenciaTemporal();
				}//if (periodo_final_PE_DECOMP < horizonte_otimizacao.at(horizonte_otimizacao.getIteradorFinal())) {


				for (Periodo periodo = horizonte_processo_estocastico.getIteradorInicial(); periodo <= horizonte_processo_estocastico.getIteradorFinal(); horizonte_processo_estocastico.incrementarIterador(periodo)) {
					for (IdRealizacao idRealizacao = IdRealizacao_1; idRealizacao <= a_dados.processoEstocastico_hidrologico.getIterador2Final(idVar, AttMatrizVariavelAleatoria_residuo_espaco_amostral, periodo, IdRealizacao()); idRealizacao++) {
						if (a_dados.processoEstocastico_hidrologico.getElementoMatriz(idVar, AttMatrizVariavelAleatoria_residuo_espaco_amostral, periodo, idRealizacao, double()) < 0.0)
							a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.at(idVar).setElemento(AttVetorVariavelAleatoria_tipo_relaxacao, periodo, TipoRelaxacaoVariavelAleatoria_truncamento_penalizacao);
					}
				}
			}
		}


		a_dados.validacao_operacional_ProcessoEstocasticoHidrologico(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, diretorio_exportacao_pos_estudo, imprimir_att_operacionais_sem_recarregar);
		
		if (a_dados.processoEstocastico_hidrologico.getSize1Matriz(IdVariavelAleatoria_1, IdVariavelAleatoriaInterna_1, AttMatrizVariavelAleatoriaInterna_cenarios_realizacao_espaco_amostral) == 0) {
			entradaSaidaDados.setDiretorioSaida(diretorio_att_premissas + "//ProcessoEstocasticoHidrologico");
			int semente = 1; //Precisa de qualquer valor (Nao vai realizar sorteio, só alocar valores já sorteados)
			a_dados.processoEstocastico_hidrologico.gerarCenariosPorSorteio(entradaSaidaDados, a_dados.getAtributo(AttComumDados_imprimir_geracao_cenario_hidrologico, bool()), true, true, a_dados.getAtributo(AttComumDados_numero_cenarios, int()), menor_cenario, maior_cenario, TipoSorteio_uniforme, semente);
		}// if (a_dados.processoEstocastico_hidrologico.getSize1Matriz(IdVariavelAleatoria_1, IdVariavelAleatoriaInterna_1, AttMatrizVariavelAleatoriaInterna_cenarios_realizacao_espaco_amostral) == 0) {
		
		if(imprimir_exportacao_pos_estudo)
			a_dados.setAtributo(AttComumDados_imprimir_exportacao_pos_estudo, true);

		//Para imprimir arquivos de AcoplamentoPosEstudo
		if (a_dados.getAtributo(AttComumDados_imprimir_exportacao_pos_estudo, bool()))
			a_dados.imprimir_ProcessoEstocasticoHidrologico_exportacao_pos_estudo(entradaSaidaDados, diretorio_exportacao_pos_estudo, 0, menor_cenario, maior_cenario, idProcesso);
		

		if (processoEstocasticoHidrologicoPreConfig_instanciado)
			horizonte_processo_estocastico = SmartEnupla<Periodo, bool>(a_dados.processoEstocastico_hidrologico.getElementosMatriz(AttMatrizProcessoEstocastico_mapeamento_espaco_amostral, IdCenario_1, Periodo(), IdRealizacao()), true);

		// Esvazia todos atributos do proc. estocástico hidrológico exceto AttMatrizVariavelAleatoriaInterna_cenarios_realizacao_espaco_amostral
		if (true) {
			ProcessoEstocastico processoEstocastico_hidrologico_buffer;
			processoEstocastico_hidrologico_buffer.vetorVariavelAleatoria.alocar(a_dados.processoEstocastico_hidrologico.vetorVariavelAleatoria.numObjetos());
			processoEstocastico_hidrologico_buffer.setMatriz_forced(AttMatrizProcessoEstocastico_mapeamento_espaco_amostral, a_dados.processoEstocastico_hidrologico.getMatriz(AttMatrizProcessoEstocastico_mapeamento_espaco_amostral, IdCenario(), Periodo(), IdRealizacao()));
			for (IdVariavelAleatoria idVar = IdVariavelAleatoria_1; idVar <= a_dados.processoEstocastico_hidrologico.getMaiorId(IdVariavelAleatoria()); idVar++) {
				VariavelAleatoria var;
				var.setAtributo(AttComumVariavelAleatoria_idVariavelAleatoria, idVar);
				var.setAtributo(AttComumVariavelAleatoria_nome, a_dados.processoEstocastico_hidrologico.getAtributo(idVar, AttComumVariavelAleatoria_nome, std::string()));
				processoEstocastico_hidrologico_buffer.vetorVariavelAleatoria.add(var);
				for (IdVariavelAleatoriaInterna idVarInterna = IdVariavelAleatoriaInterna_1; idVarInterna <= a_dados.processoEstocastico_hidrologico.getMaiorId(idVar, IdVariavelAleatoriaInterna()); idVarInterna++) {
					VariavelAleatoriaInterna varInterna;
					varInterna.setAtributo(AttComumVariavelAleatoriaInterna_idVariavelAleatoriaInterna, idVarInterna);
					varInterna.setAtributo(AttComumVariavelAleatoriaInterna_nome, a_dados.processoEstocastico_hidrologico.getAtributo(idVar, idVarInterna, AttComumVariavelAleatoriaInterna_nome, std::string()));
					processoEstocastico_hidrologico_buffer.vetorVariavelAleatoria.at(idVar).vetorVariavelAleatoriaInterna.add(varInterna);
					processoEstocastico_hidrologico_buffer.vetorVariavelAleatoria.at(idVar).vetorVariavelAleatoriaInterna.at(idVarInterna).setMatriz_forced(AttMatrizVariavelAleatoriaInterna_cenarios_realizacao_espaco_amostral, a_dados.processoEstocastico_hidrologico.getMatriz(idVar, idVarInterna, AttMatrizVariavelAleatoriaInterna_cenarios_realizacao_espaco_amostral, Periodo(), IdCenario(), double()));
					processoEstocastico_hidrologico_buffer.vetorVariavelAleatoria.at(idVar).vetorVariavelAleatoriaInterna.at(idVarInterna).setVetor_forced(AttVetorVariavelAleatoriaInterna_tendencia_temporal, a_dados.processoEstocastico_hidrologico.getVetor(idVar, idVarInterna, AttVetorVariavelAleatoriaInterna_tendencia_temporal, Periodo(), double()));

				}
			}
			a_dados.processoEstocastico_hidrologico.esvaziar();
			a_dados.processoEstocastico_hidrologico = ProcessoEstocastico();
			a_dados.processoEstocastico_hidrologico = processoEstocastico_hidrologico_buffer;
		}

		// FINAL DEV NOVO PROC ESTOCASTICO
		
		calculaEngolimentoMaximo(a_dados, horizonte_estudo, horizonte_otimizacao_DC.at(horizonte_otimizacao_DC.getIteradorFinal()), lido_turbinamento_maximo_from_relato_e_avl_turb_max_DC, menor_cenario, maior_cenario);

		////////////////////////////////////
		//Pre-config da programação diária
		// //Nota: depois do engolimento máximo para a vazao_turbinada_disponivel_maxima
		////////////////////////////////////
		atualizar_valores_com_DadosEntradaPD_PRECONFIG(a_dados, a_dados.getAtributo(AttComumDados_diretorio_entrada_dados, std::string()) + "_PRECONFIG" + "//DadosEntradaPD_PRECONFIG");


		//Algumas usinas podem ter instanciado o volume_util_maximo no método determina_restricoes_hidraulicas_especiais() e precisa verificar com o percentual_volume_util_maximo
		atualiza_volume_util_maximo_com_percentual_volume_util_maximo(a_dados); 

		//////////////////////////////////////////////////////////////

		leitura_coeficientes_evaporacao_from_dec_cortes_evap_DC(a_dados, a_diretorio + "//DadosAdicionais" + "//dec_cortes_evap.csv");

		a_dados.validacao_operacional_Submercado(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);

		a_dados.validacao_operacional_Intercambio(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);

		a_dados.validacao_operacional_Termeletrica(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);

		a_dados.validacao_operacional_Hidreletrica(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);

		a_dados.validacao_operacional_UsinasElevatorias(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);

		a_dados.validacao_operacional_Intercambio_Hidraulico(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);

		a_dados.validacao_operacional_BaciaHidrografica(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);

		sequenciarRestricoesEletricas(a_dados);

		a_dados.validacao_operacional_RestricaoEletrica(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);

		////////////////

		atualiza_restricao_operativa_UHE_tipoRestricaoHidraulica_energia_armazenada(a_dados, a_diretorio, maior_ONS_REE); //Para criar as restrições por energia é necessário calcular a produtibilidade_acumulada_EAR (que dependia de aplicar das modificações)
		sequenciarRestricoesHidraulicas(a_dados);
		a_dados.validacao_operacional_RestricaoOperativaUHE(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);

		a_dados.validacao_operacional_Contrato(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);
		
		a_dados.validacao_operacional_DemandaEspecial(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);
		
		a_dados.validacao_operacional_ReservaPotencia(entradaSaidaDados, diretorio_att_operacionais, diretorio_att_premissas, imprimir_att_operacionais_sem_recarregar);


		////////////////

		if (hidreletricasPreConfig_instanciadas)
			a_dados.valida_preconfig_hidraulica(lista_jusante_hidreletrica, lista_jusante_desvio_hidreletrica);

		imprime_na_tela_avisos_de_possiveis_inviabilidades_fph(a_dados);


		////////////////////////////////////////////////////
		// Detecta se existe arquivo de cortes NEWAVE
		////////////////////////////////////////////////////
		if (idProcesso == IdProcesso_mestre && nomeArquivo_cortes_NW != "nenhum") {
			bool must_read_nwlistcf = false;

			//Se existe expansão do horizonte, tem que colocar o arquivo de cortes nwlistcf.rel. Caso contrário, pode ser nwlistcf.rel ou fcfnwn.rvX
			if (get_periodo_ultimo_sobreposicao_com_horizonte_DC(a_dados) < horizonte_estudo.getIteradorFinal())
				must_read_nwlistcf = true;

			leitura_cortes_NEWAVE(a_dados, horizonte_estudo, nomeArquivo_cortes_NW, must_read_nwlistcf, diretorio_att_premissas, maior_ONS_REE, horizonte_processo_estocastico, percentual_duracao_patamar_carga_original);

		}//if (idProcesso == IdProcesso_mestre && nomeArquivo_cortes_NW != "nenhum") {


		//
		// Esvazia Atributos Processo Estocástico Hidrológico
		//

		a_dados.processoEstocastico_hidrologico = ProcessoEstocastico();

	}//try {
	catch (const std::exception& erro) { throw std::invalid_argument("LeituraCEPEL::validacoes_DC: \n" + std::string(erro.what())); }

} // void LeituraCEPEL::validacoes_DC(Dados & a_dados){